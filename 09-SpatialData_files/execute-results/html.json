{
  "hash": "2268528de8406959624c9b111d6b72c2",
  "result": {
    "engine": "knitr",
    "markdown": "# Пространственные данные {#spatial}\n\n\n\n\n\n## Предварительные требования {#spatial_prerequisites}\n\nДанный модуль посвящен введению в работу с пространственными данными в R. Рассмотрены общие вопросы моделирования реального мира средствами моделей пространственных данных. Рассматривается чтение векторных и растровых данных, их визуализация стандартными средствами.\n\nНеобходимые для работы пакеты:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(sf)\nlibrary(stars)\nlibrary(mapview)\nlibrary(dplyr)\nlibrary(readr)\n```\n:::\n\n\n## Модели пространственных данных {#spatial_models}\n\n**Пространственные данные** (spatial data) --- это данные о пространственных объектах и их наборах. В свою очередь, пространственный объект определяется как *цифровая модель материального или абстрактного объекта реального или виртуального мира с указанием его идентификатора, координатных и атрибутивных данных* [^09-spatialdata-1].\n\n[^09-spatialdata-1]: ГОСТ Р 52438-2005 \\<\\<Географические информационные системы. Термины и определения\\>\\>. В стандарте поясняется, что объектом может быть неподвижный или движущийся простой или сложный объект, явление, событие, процесс и ситуация. Моделируемый объект может относиться к территории, акватории, недрам и воздушному пространству Земли, околоземному космическому пространству, другим космическим телам и небесной сфере. В широком смысле под пространственным объектом в геоинформатике понимается как сам объект, так и адекватная ему цифровая модель\n\nЕсли говорить по сути, то пространственные данные можно определить как *данные о географических объектах или явлениях, фиксирующие их местоположение и/или распределение в системе координат, привязанной к телу Земли или любого другого небесного тела*. Таким образом, отличительной особенностью пространственных данных перед непространственными является координатное описание местоположения. На профессиональном жаргоне пространственные данные также часто называют **геоданными**. Следует помнить, что этот термин не является научным, и его не следует использовать в публикациях и квалификационных работах.\n\nВажно знать отличия между векторной и растровой моделью пространственных данных.\n\n**Векторная модель** пространственных данных включает описание координатных данных пространственных объектов и, опционально, топологических отношений между ними. Векторные данные фиксируют местоположение и форму объектов в виде геометрических примитивов, таких как точки, линии, полигоны, объемные тела. Выбор модели объекта (например, представить город точкой или полигоном) зависит от масштаба анализа и целей исследования. Векторная модель данных является объектно-ориентированной.\n\n**Растровая модель** описывает не объекты, а пространственное распределение некоторой (выбранной исследователем) характеристики. Пространство разбивается регулярной сеткой ячеек, в каждой ячейке фиксируется значение исследуемого параметра (путем статистического осреднения, семплирования в центре ячейки и т.п.). Растровые данные могут быть как количественными (например, поле температуры), так и качественными (например, растр классифицированного снимка, каждая ячейка которого фиксирует принадлежность к тому или иному типу объекта). Таким образом, растровая модель является пространственно-ориентированной (или феномен-ориентированной).\n\nСуществуют и другие модели пространственных данных, однако их рассмотрение выходит за рамки настоящей лекции.\n\nВ настоящей лекции мы познакомимся с чтением и визуализацией пространственных данных в векторном и растровом формате, а также рассмотрим вопросы связанные с использованием картографических проекций.\n\n## Векторные данные {#vector_data_r}\n\n### Simple Features {#simple_features}\n\n**Simple Features** (официально *Simple Features Access*) --- это стандарт [OGC 06-103](http://www.opengeospatial.org/standards/sfa), разработанный Open Geospatial Consortium (OGC) и реализованный также в виде международного стандарта [ISO 19125](https://www.iso.org/standard/40114.html), который определяет общую модель хранения и доступа к векторным объектам (точка, линия, многоугольник, мульти точечные, мультилинии и т. д.), в географических информационных системах.\n\nГеометрическое представление пространственных объектов базируется на следующих принципах:\n\n-   Все геометрии состоят из точек.\n-   Точки являются координатами в 2-, 3- или 4-мерном пространстве.\n-   Все точки в геометрии имеют одинаковую размерность.\n\nВ дополнение к координатам $X$ и $Y$ имеются два дополнительных дополнительных параметра:\n\n-   координата $Z$, обозначающая высоту\n-   координата $M$, обозначающая некоторую меру, связанную с точкой, а не с признаком в целом (в этом случае это будет атрибут объекта). Измерение $M$ может быть использовано, например, для представления времени или линейных координат (для маршрутов).\n\nКоординаты простой геометрии всегда содержат компоненты $X$ и $Y$, поэтому все разнообразие возможных представлений определяется наличием или отсутствием дополнительных измерений $Z$ и $M$. Таким образом, получаем **четыре** варианта геометрии:\n\n-   двумерные точки $XY$\n-   трехмерные точки $XYZ$\n-   трехмерные точки $XYM$\n-   четырехмерные точки $XYZM$\n\nВ случае использования широт и долгот $X$ соответствует долготе, $Y$ соответствует широте.\n\nВсего стандарт **Simple Features** включает в себя 17 типов геометрий. Из них наиболее употребительными являются следующие 7:\n\n| Тип                  | Описание                                                                                                                                                                                                                                         |\n|----------------------|--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|\n| `POINT`              | нуль-мерная геометрия, содержащая одну точку                                                                                                                                                                                                     |\n| `LINESTRING`         | последовательность точек, соединенных прямыми, несамопересекающимися отрезками; одномерная геометрия                                                                                                                                             |\n| `POLYGON`            | геометрия с положительной площадью (двумерная); последовательность точек, отрезки между которыми формируют замкнутое кольцо без самопересечений; первое кольцо является внешним, ноль и более остальных колец представляют дырки внутри полигона |\n| `MULTIPOINT`         | множество точек; геометрия типа `MULTIPOINT` называется *простой* если ни одна пара точек в `MULTIPOINT` не совпадает                                                                                                                            |\n| `MULTILINESTRING`    | множество линий                                                                                                                                                                                                                                  |\n| `MULTIPOLYGON`       | множество полигонов                                                                                                                                                                                                                              |\n| `GEOMETRYCOLLECTION` | множество геометрий произвольного типа за исключением `GEOMETRYCOLLECTION`                                                                                                                                                                       |\n\nПримеры различных видов геометрий представлены на рисунке ниже:\n\n\n::: {.cell}\n\n:::\n\n::: {.cell}\n::: {.cell-output-display}\n![](09-SpatialData_files/figure-html/unnamed-chunk-3-1.png){width=100%}\n:::\n:::\n\n\nОставшиеся виды геометрий *Simple Features* включают: `CIRCULARSTRING`, `COMPOUNDCURVE`, `CURVEPOLYGON`, `MULTICURVE`, `MULTISURFACE`, `CURVE`, `SURFACE`, `POLYHEDRALSURFACE`, `TIN`, `TRIANGLE`.\n\nСуществует два официально закрепленных формата представления SF: *Well-Known Text (WKT)* и *Well-Known Binary (WKB)*, которые необходимы для чтения таких данных человеком и машиной соответственно.\n\n**Well-Known Text (WKT)** --- стандарт представления геометрии в виде множества списков координат, в которых координаты вершин разделены пробелами, вершины разделены запятыми, а компоненты полигонов и мультигеометрий заключены в круглые скобки и также разделены запятыми. Вышеприведенной картинке соответствуют следующие строки *WKT*:\n\n\n::: {.cell}\n\n```\n## POINT (0.5 0.5)\n## LINESTRING (0 1, 0.5 1.5, 1.2 1.2, 2 1.3, 3 2)\n## POLYGON ((0.5 0.5, 2 0, 3 2, 1.5 4, 0 3, 0.5 0.5), (1 1, 0.8 2, 2 2.2, 1.4 1.1, 1 1))\n## MULTIPOINT ((0.5 0.5), (1 3), (2 1), (0.2 2), (2 3), (1.5 1.5))\n## MULTILINESTRING ((0.5 1.5, 1.2 1.2, 2 1.3), (0 1.5, 0.5 2, 1.2 1.7), (2 1.8, 3 2.5))\n## MULTIPOLYGON (((0.5 0.5, 2 0, 3 2, 1.5 4, 0 3, 0.5 0.5), (1 1, 0.8 2, 2 2.2, 1.4 1.1, 1 1)), ((3 3.3, 3.5 3.1, 4 3, 4 3.7, 3.7 3.96, 3.2 4, 3 3.3), (3.2 3.4, 3.8 3.2, 3.8 3.7, 3.3 3.8, 3.2 3.4)), ((3 1.2, 2.5 0.2, 3.5 0.2, 3.5 1.2, 3 1.2)), ((0 1, 0.1 0.8, 0.2 0.5, 0.1 0.3, 0 0.7, 0 1)))\n## GEOMETRYCOLLECTION (POLYGON ((0.5 0.5, 2 0, 3 2, 1.5 4, 0 3, 0.5 0.5), (1 1, 0.8 2, 2 2.2, 1.4 1.1, 1 1)), MULTIPOINT ((3.5 -0.5), (4 2), (5 0), (3.2 1), (5 2), (4.5 0.5)), MULTILINESTRING ((3 3.5, 3.7 3.2, 4.5 3.3), (2.5 3.5, 3 4, 3.7 3.7), (4.5 3.8, 5.5 4.5)))\n```\n:::\n\n\n**Well-Known Binary (WKB)** --- бинарный формат хранения координат. Именно этот формат фактически используется в базах данных, поскольку он обеспечивает высокую скорость чтения и записи данных (в отличие от текстового). Однако внешний вид данных в формате WKB мало о чем говорит человеку, поскольку он предназначен для чтения компьютером. Например, вышеприведенная строка `LINESTRING` будет выглядеть так:\n\n\n::: {.cell}\n\n```\n## 01 02 00 00 00 05 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 f0 3f 00 00 00 00 00 00 e0 3f 00 00 00 00 00 00 f8 3f 33 33 33 33 33 33 f3 3f 33 33 33 33 33 33 f3 3f 00 00 00 00 00 00 00 40 cd cc cc cc cc cc f4 3f 00 00 00 00 00 00 08 40 00 00 00 00 00 00 00 40\n```\n:::\n\n\n### Базовые библиотеки {#vector_data_packages}\n\nВ R существует высоко развитая инфраструктура для работы с векторными данными, которая обеспечивается пакетом [**sf**](https://cran.r-project.org/web/packages/sf/index.html).\n\nПакет **sf** базируется на библиотеках [PROJ](https://proj.org), [GDAL](https://gdal.org), [GEOS](https://trac.osgeo.org/geos/) и [S2](https://s2geometry.io), которые устанавливаются вместе с ним. Их назначение кратко описано на следующем рисунке:\n\n\n::: {.cell}\n::: {.cell-output-display}\n![Архитектура программных библиотек для работы с пространственными данными в R](images/sf_architecture_new.svg){width=100%}\n:::\n:::\n\n\nСо многими функциями **sf** мы познакомимся в последующих разделах нашего курса. Некоторые из них (такие как `arrange`, `filter`, `mutate` из пакета **dplyr**), должны быть уже знакомы вам по предыдущим лекциям. Можно обратить внимание на то, что практически все функции начинаются с префикса `st_`, что означает **\"spatiotemporal\"**. Данные префиксы были выбраны для унификации с аналогичными названиями функций, используемых в широко распространенной СУБД PostgreSQL для оперирования объектами *Simple Features*.\n\n### Чтение {#vector_data_reading}\n\nСуществует большое количество форматов хранения пространственных данных. Но в общем и целом их можно разделить на две категории: файловые форматы (наиболее привычные пользователям) и хранение данных в СУБД --- системах управления базами данных. Благодаря библиотеке GDAL пакет **sf** имеет возможность читать и записывать [более 90 различных форматов векторных даных](http://www.gdal.org/ogr_formats.html).\n\nИсторически наиболее распространенным форматом был (и остается) [ESRI Shapefile](https://www.esri.com/library/whitepapers/pdfs/shapefile.pdf). Данный формат, однако не отвечает современным техническим требованиям с точки зрения гибкости, соответствия стандартам и возможностям хранения разнообразных типов геометрий (напомним, что в стандарте **Simple Features** их 17, а с учетом четырех вариантов размерности точек получается целых 68 ). Современный формат, который обеспечивает полную поддержку стандарта **Simple Features** (и не только) --- это [GeoPackage](http://www.geopackage.org). Именно его мы и будем использовать в нашем практикуме.\n\nДля чтения данных средствами sf необходимо использовать функцию `st_read()`:\n\n\n::: {.cell}\n\n```{.r .cell-code}\ncountries = st_read('data/ne/countries.gpkg')\n## Reading layer `admin_0_map_units' from data source \n##   `/Users/tsamsonov/GitHub/r-geo-course/data/ne/countries.gpkg' \n##   using driver `GPKG'\n## Simple feature collection with 183 features and 72 fields\n## Geometry type: MULTIPOLYGON\n## Dimension:     XY\n## Bounding box:  xmin: -180 ymin: -90 xmax: 180 ymax: 83.64513\n## Geodetic CRS:  WGS 84\n```\n:::\n\n\nЛог функции сообщил нам следующую информацию:\n\n-   Набор данных представляет собой коллекцию из 183 пространственных объектов с 72 атрибутами\n-   Тип геометрии `MULTIPOLYGON`\n-   Размерность геометрии $XY$\n-   Ограничивающий прямоугольник (разброс координат) по осям $X$ и $Y$ имеет диапазон $[-180, 180] \\times [-90, 83.64513]$\n-   Проекция (CRS --- coordinate reference system) имеет название *WGS 84*.\n\nПодгрузим также для работы данные по другим типам объектов:\n\n\n::: {.cell}\n\n```{.r .cell-code}\noceans = st_read('data/ne/oceans.gpkg')\n## Reading layer `ocean' from data source \n##   `/Users/tsamsonov/GitHub/r-geo-course/data/ne/oceans.gpkg' \n##   using driver `GPKG'\n## Simple feature collection with 2 features and 4 fields\n## Geometry type: POLYGON\n## Dimension:     XY\n## Bounding box:  xmin: -180 ymin: -85.60904 xmax: 180 ymax: 90\n## Geodetic CRS:  WGS 84\nrivers = st_read('data/ne/rivers.gpkg')\n## Reading layer `rivers_lake_centerlines' from data source \n##   `/Users/tsamsonov/GitHub/r-geo-course/data/ne/rivers.gpkg' \n##   using driver `GPKG'\n## Simple feature collection with 13 features and 8 fields\n## Geometry type: LINESTRING\n## Dimension:     XY\n## Bounding box:  xmin: -135.3134 ymin: -33.99358 xmax: 129.956 ymax: 72.90651\n## Geodetic CRS:  WGS 84\nlakes = st_read('data/ne/lakes.gpkg')\n## Reading layer `lakes' from data source \n##   `/Users/tsamsonov/GitHub/r-geo-course/data/ne/lakes.gpkg' using driver `GPKG'\n## Simple feature collection with 25 features and 8 fields\n## Geometry type: POLYGON\n## Dimension:     XY\n## Bounding box:  xmin: -124.9536 ymin: -16.53641 xmax: 109.9298 ymax: 66.9693\n## Geodetic CRS:  WGS 84\ncities = st_read('data/ne/cities.gpkg')\n## Reading layer `populated_places' from data source \n##   `/Users/tsamsonov/GitHub/r-geo-course/data/ne/cities.gpkg' \n##   using driver `GPKG'\n## Simple feature collection with 243 features and 103 fields\n## Geometry type: POINT\n## Dimension:     XY\n## Bounding box:  xmin: -175.2206 ymin: -41.29999 xmax: 179.2166 ymax: 64.15002\n## Geodetic CRS:  WGS 84\n```\n:::\n\n\n### Внутренняя структура {#sf_structure}\n\nТрадиционно во всех ГИС-приложениях и базах пространственных данных множество пространственных объектов представляется в виде таблицы атрибутов, где каждая строка соответствует объекту, а каждый столбец --- атрибуту объекта. С каждой строкой таблицы должна быть ассоциирована информация о геометрии объекта, которая, в зависимости от формата данных, может либо храниться непосредственно в таблице (в специальном столбце), либо быть вынесена в отдельную структуру данных, которая связана с таблицей атрибутов посредством ключа[^09-spatialdata-2].\n\n[^09-spatialdata-2]: Например, в широко распространенном формате **Esri Shapefile** атрибутивная таблица хранится в файле `*.dbf` формата *DBASE*, геометрия хранится в отдельном файле `*.shp`, а связь между ними осуществляется через файл `*.shx`. Разбиение формата хранения на несколько файлов --- это одна из уязвимостей шейп-файлов: при отсутствии хотя бы одного из этих файлов данные прочесть стандартными средствами (без дополнительного хакинга) будет нельзя.\n\nВ **R** используется первый подход, в котором информация о геометрии хранится в специальном столбце таблицы. Каждая ячейка этого столбца соответствует геометрическому объекту *Simple Features*. Представление геометрических объектов реализовано стандартными средствами, такими как списки, матрицы и векторы. Эти структуры данных упорядоченным образом хранят координаты объектов и естественным образом соответствуют способу организации данных, который регламентируется стандартом *Simple Features*. Поскольку геометрический столбец хранит не обычные переменные, а структуры данных, он реализуется в виде так называемого *списка-колонки (list-column)*, каждый элемент которой соответствует отдельному объекту.\n\nИсходя из этих соображений, представление пространственных объектов реализовано в **R** в виде иерархии из трех классов объектов:\n\n1.  `sf` (simple features) --- объект класса `data.frame`, представляющий множество пространственных объектов со списком-колонкой для хранения геометрии\n2.  `sfc` (simple features geometry column) --- список-колонка в объекте `sf`, представляющий множество геометрий пространственных объектов\n3.  `sfg` (simple feature geometry) --- геометрия пространственного объекта внутри списка `sfc`\n\nВ соответствии с перечисленными спецификациями происходит работа с пространственными объектами. То что, объекты типа Simple Features реализованы в виде самых обычных фреймов данных, означает что *любая операция, применимая к фрейму данных, будет также применима к объекту типа* `sf`. Это очень важная особенность объектов типа sf, которой сильно не хватало в экосистеме исторического пакета `sp`.\n\nПосмотрим, как все это реализовано, на конкретном примере:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nclass(countries)\n## [1] \"sf\"         \"data.frame\"\n```\n:::\n\n\nДанная форма записи говорит о том, что прочитанный слой имеет класс *sf*, который, в свою очередь, является расширением класса *data.frame*.\n\nА теперь посмотрим на последние колонки в первых строках таблицы:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nhead(countries[tail(colnames(countries))])\n## Simple feature collection with 6 features and 5 fields\n## Geometry type: MULTIPOLYGON\n## Dimension:     XY\n## Bounding box:  xmin: -73.41544 ymin: -55.25 xmax: 75.15803 ymax: 42.68825\n## Geodetic CRS:  WGS 84\n##   tiny homepart min_zoom min_label max_label                       geometry\n## 1  -99        1        0         3         7 MULTIPOLYGON (((61.21082 35...\n## 2  -99        1        0         3         7 MULTIPOLYGON (((23.90415 -1...\n## 3  -99        1        0         5        10 MULTIPOLYGON (((21.02004 40...\n## 4  -99        1        0         4         9 MULTIPOLYGON (((51.57952 24...\n## 5  -99        1        0         2         7 MULTIPOLYGON (((-66.95992 -...\n## 6  -99        1        0         5        10 MULTIPOLYGON (((43.58275 41...\n```\n:::\n\n\nВидно, что геометрия пространственных объектов хранится в заключительном столбце с названием `geometry`. Данный столбец можно быстро извлечь, применив функцию `st_geometry()`. Полученный объект будет иметь тип **sfc** (Simple Feature Geometry Column)\n\n\n::: {.cell}\n\n```{.r .cell-code}\noutlines = st_geometry(countries)\nclass(outlines)\n## [1] \"sfc_MULTIPOLYGON\" \"sfc\"\n```\n:::\n\n\nПолученный вывод говорит нам о том, что наши объекты имеют класс `sfc_MULTIPOLYGON`, который является расширением класса `sfc` (simple feature geometry column).\n\nТеперь если просмотреть начало данных, то мы увидим, что это больше не фрейм данных, а аннотированный список:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nhead(outlines)\n## Geometry set for 6 features \n## Geometry type: MULTIPOLYGON\n## Dimension:     XY\n## Bounding box:  xmin: -73.41544 ymin: -55.25 xmax: 75.15803 ymax: 42.68825\n## Geodetic CRS:  WGS 84\n## First 5 geometries:\n```\n:::\n\n\nДалее можно опуститься на базовый уровень геометрии, получив доступ к отдельному объекту. Поскольку объект класса `sfc` представляет собой список, любой элемент можно извлечь по его порядковому номеру. Класс полученного объекта будет:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nclass(outlines[[8]])\n## [1] \"XY\"           \"MULTIPOLYGON\" \"sfg\"\n```\n:::\n\n\nИсходя из полученной информации можно сделать вывод, что геометрия 8-го объекта таблицы `countries` имеет класс `sfg`, реализованный в виде мультиполигонов (`MULTIPOLYGON`) с плоскими координатами (`XY`)\n\nНаконец, чтобы добраться до координат в чистом виде, необходимо развернуть иерархию списков, из которых состоит объект `sfg`. Количество уровней вложенности всегда зависит от конкретного объекта, их может быть достаточно много, особенно если объекты представлены мультиполигонами (несколько компонент связности), каждый из которых также состоит из полигонов с дырками. В нашем случае все достаточно просто, так как в слое `countries` дырок в полигонах нет, а 8-й по счету полигон состоит из одной-единственной геометрии, координаты которой в виде матрицы можно извлечь как:\n\n\n::: {.cell}\n\n```{.r .cell-code}\noutlines[[8]][[1]]\n## [[1]]\n##          [,1]     [,2]\n##  [1,] 68.9350 -48.6250\n##  [2,] 69.5800 -48.9400\n##  [3,] 70.5250 -49.0650\n##  [4,] 70.5600 -49.2550\n##  [5,] 70.2800 -49.7100\n##  [6,] 68.7450 -49.7750\n##  [7,] 68.7200 -49.2425\n##  [8,] 68.8675 -48.8300\n##  [9,] 68.9350 -48.6250\n```\n:::\n\n\n### Визуализация {#sf_plotting}\n\n#### Базовая графическая система {#sf_plotting_basic}\n\nЕсли попытаться применить функцию `plot()` к геометрии объекта, она попытается нарисовать тематические карты по всем имеющимся атрибутам (но остановится, если их более 9):\n\n\n::: {.cell}\n\n```{.r .cell-code}\nplot(countries)\n```\n\n::: {.cell-output-display}\n![](09-SpatialData_files/figure-html/unnamed-chunk-15-1.png){width=100%}\n:::\n:::\n\n\nЕсли задача стоит нарисовать границы объектов, то нужно отображать объект **sfc**:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nplot(outlines, col = 'red')\n```\n\n::: {.cell-output-display}\n![](09-SpatialData_files/figure-html/unnamed-chunk-16-1.png){width=100%}\n:::\n:::\n\n\nДля быстрого построения тематических карт по выбранному показателю необходимо при вызове функции `plot()` указать соответствующий атрибут фрейма данных:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nplot(countries['sovereignt'], key.pos = NULL) # Здесь легенда не нужна\n```\n\n::: {.cell-output-display}\n![](09-SpatialData_files/figure-html/unnamed-chunk-17-1.png){width=100%}\n:::\n:::\n\n\nДля отображения координатной сетки надо указать параметр `graticule = TRUE`, а подписей координат --- `axes = TRUE`:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nplot(countries['gdp_md_est'], graticule = TRUE, axes = TRUE)\n```\n\n::: {.cell-output-display}\n![](09-SpatialData_files/figure-html/unnamed-chunk-18-1.png){width=100%}\n:::\n:::\n\n\nДля совмещения нескольких слоев на одной карте необходимо при втором и последующих вызовах функции `plot()` указать параметр `add = TRUE`. Все остальные настройки визуализации работают так же,как и в обычной графике:\n\n\n::: {.cell}\n\n```{.r .cell-code}\ncities_large = cities |> \n  filter(scalerank == 0, \n         ! name %in% c('Washington, D.C.', 'Paris', 'Riyadh', 'Rome', 'São Paulo', 'Kolkata'))\n\nplot(st_geometry(countries), lwd = 0.5, border = 'gray')\nplot(oceans, col = 'steelblue1', border = 'steelblue', add = TRUE)\nplot(lakes, col = 'steelblue1', border = 'steelblue', add = TRUE)\nplot(rivers, col = 'steelblue', add = TRUE)\nplot(cities_large, col = 'black', pch = 19, cex = 0.25, add = TRUE)\ntext(cities_large$longitude, cities_large$latitude, \n     label = cities_large$name, cex = 0.5, pos = 2, offset = 0.25)\n```\n\n::: {.cell-output-display}\n![](09-SpatialData_files/figure-html/unnamed-chunk-19-1.png){width=100%}\n:::\n:::\n\n\n> **Внимание**: чтобы слои совместились на карте, они должна иметь одинаковую систему координат.\n\nЯсно, что на полученных нами картах можно много что улучшить, однако это мы отложим до следующей главы, где подробно разбирается построение тематических карт в **R**.\n\n> **Внимание**: чтобы слои данных можно было совместно анализировать и наносить на одну карту, они должны иметь одну и ту же координатную систему (проекцию).\n\n#### Интерактивные карты {#spatial_interactive}\n\nR предоставляет возможности для интерактивного просмотра пространственных данных средствами библиотек веб-картографирования. В данном разделе мы кратко познакомимся с возможностями пакета [**mapview**](https://r-spatial.github.io/mapview/), который использует возможности библиотеки [Leaflet](https://leafletjs.com/). Функции данного пакета не предназначены для создания тематических карт высокого качества и рассчитаны на выполнение исследовательского анализа данных.\n\nЧтобы отобразить векторный или растровый слой средствами mapview, достаточно вызвать одноименную функцию данного пакета:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmapview(countries)\n```\n:::\n\n::: {.cell}\n::: {.cell-output-display}\n![](images/mapview1.png){width=100%}\n:::\n:::\n\n\nЧтобы отобразить определенный показатель, можно использовать параметр `zcol`, а палитру передать в параметр `col.regions`:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nnconts = length(unique(countries$continent))\nmapview(countries, zcol = 'continent', \n        col.regions = RColorBrewer::brewer.pal(nconts, 'Set1'))\n```\n:::\n\n::: {.cell}\n::: {.cell-output-display}\n![](images/mapview2.png){width=100%}\n:::\n:::\n\n\nЧтобы скомбинировать несколько слоев, необходимо сложить несколько вызовов `mapview()`:\n\n\n::: {.cell}\n\n```{.r .cell-code}\n{ mapview(countries, zcol = 'continent', \n        col.regions = RColorBrewer::brewer.pal(nconts, 'Set1')) + \n  mapview(cities_large, col.regions = 'black', label = 'name', cex = 3) } |> \n  leafem::addStaticLabels(cities_large, label = cities_large$name,\n                          offset = c(0.1, 0),\n                          style = list(\"color\" = \"black\", \"font-weight\" = \"bold\"))\n```\n:::\n\n::: {.cell}\n::: {.cell-output-display}\n![](images/mapview3.png){width=100%}\n:::\n:::\n\n\n### Атрибутивные операции {#sf_attrs}\n\nПоскольку пространственные объекты хранятся в фреймах данных, к ним можно применять стандартные операции выборки по атрибутам и преобразования таблиц. Например, можно выбрать Италию и отобразить ее на отдельной карте:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nitaly = countries |> \n  filter(sovereignt == 'Italy')\nplot(st_geometry(italy))\n```\n\n::: {.cell-output-display}\n![](09-SpatialData_files/figure-html/unnamed-chunk-26-1.png){width=100%}\n:::\n:::\n\n\nСледующий пример иллюстрирует как выбрать страны с населением более 100 млн человек:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlargest = countries |> \n  select(pop_est) |> \n  filter(pop_est > 100000000)\nplot(outlines, col = 'lightgrey')\nplot(largest, col = 'red', add = TRUE)\n```\n\n::: {.cell-output-display}\n![](09-SpatialData_files/figure-html/unnamed-chunk-27-1.png){width=100%}\n:::\n:::\n\n\nОбратите внимание на то, что при вызове функции `select()` столбец `geometry` не был указан в числе выбираемых переменных. Тем не менее, то, что мы смогли построить карту по результатам выборки, говорит о том, что данный столбец был сохранен. *Функции **dplyr** определены для объектов `sf` таким образом, чтобы всегда сохранять геометрический столбец.*\n\nЕще интереснее работает агрегирование объектов по атрибутам. В случае, когда агрегируются пространственные объекты, необходимо объединять и их геометрию. При этом если у агрегируемых объектов имеется общая граница, ее необходимо удалить, а если объекты разнесены в пространстве, из них нужно собрать новый мульти-объект.\n\nНапример, мы можем агрегировать валовой региональный продукт по континентам:\n\n\n::: {.cell}\n\n```{.r .cell-code}\ncontinents = countries %>% # этот пайп из пакета magrittr для подстановки в точку\n  filter(., st_is_valid(.)) |>\n  group_by(continent) |>  \n  summarise(gdp = sum(gdp_md_est))\nplot(continents['gdp'])\n```\n\n::: {.cell-output-display}\n![](09-SpatialData_files/figure-html/unnamed-chunk-28-1.png){width=100%}\n:::\n:::\n\n\nПотрясающе просто, не правда ли? Вдобавок, мы еще и получили границы континентов (достаточно условные, конечно), которых у нас раньше не было. Данный пример также показывает, что атрибутивные операции над пространственными объектами всегда учитывают их геометрию.\n\n### Создание пространственных объектов {#sf_creation}\n\nПространственные объекты в R можно собирать \"вручную\", если есть такая необходимость. Например, вам известны координаты границ участков полевого обследования, полученные посредством GPS, а вам необходимо превратить их в полигоны, чтобы выполнить анализ и картографирование. Придется из координат собрать полигоны программным путем. Процесс создания пространственных объектов осуществляется в последовательности их иерархического соподчинения: **sfg** \\> **sfc** \\> **sf**.\n\n#### Геометрические объекты (sfg) {#sf_sfg}\n\nДля создания геометрических объектов в пакете sf существует ряд функций с говорящими названиями:\n\n| Функция                   | Тип пространственного объекта |\n|---------------------------|-------------------------------|\n| `st_point()`              | *POINT*                       |\n| `st_linestring()`         | *LINESTRING*                  |\n| `st_polygon()`            | *POLYGON*                     |\n| `st_multipoint()`         | *MULTIPOINT*                  |\n| `st_multilinestring()`    | *MULTILINESTRING*             |\n| `st_multipolygon()`       | *MULTIPOLYGON*                |\n| `st_geometrycollection()` | *GEOMETRYCOLLECTION*          |\n\nВ зависимости от типа создаваемого объекта, данные функции принимают координаты, организованные в виде одной из трех структур данных:\n\n-   Вектор координат (*POINT*)\n-   Матрица координат (*MULTIPOINT* или *LINESTRING*), в которой строки соответствуют точкам, столбцы --- координатам\n-   Список (для всех остальных типов)\n\nПроще всего создаются отдельные **точки** (*POINT*):\n\n\n::: {.cell}\n\n```{.r .cell-code}\nst_point(c(0, 2)) # XY POINT\nst_point(c(0, 2, -1)) # XYZ POINT\nst_point(c(0, 2, 5), dim = 'XYM') # XYM POINT\nst_point(c(0, 2, -1, 5)) # XYZM POINT\n```\n:::\n\n\nДополнительный параметр `dim=` служит для уточнения типа геометрии точек и по сути нужен только тогда, когда необходимо создать редко используемые точки типа *XYM*. во всех остальных случаях (*XY*, *XYZ*, *XYZM*) размерность геометрии распознается по умолчанию.\n\nПри создании **мультиточек** (*MULTIPOINT*) и **линий** (*LINESTRING*) необходимо подавать на вход функции уже матрицу координат:\n\n\n::: {.cell}\n\n```{.r .cell-code}\ncoords = matrix(c(\n  0, 2,\n  1, 3,\n  3, 1,\n  5, 0\n), ncol = 2, byrow = TRUE)\n\nmp = st_multipoint(coords) # XY MULTIPOINT\nprint(mp)\n\nls = st_linestring(coords) # XY LINESTRING\nprint(ls)\n```\n:::\n\n\nВ первом случае геометрия состоит из отдельных точек. Во втором случае те же самые точки соединены линией:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nplot(ls)\nplot(mp, col = 'red', pch = 19, add = TRUE)\n```\n\n::: {.cell-output-display}\n![](09-SpatialData_files/figure-html/unnamed-chunk-31-1.png){width=100%}\n:::\n:::\n\n\nСоздание трех-(*XYZ*, *XYM*) и четырехмерных (*ZYXM*) мультиточек и линий выполняется аналогично, но матрица должна содержать не 2, а, соответственно 3 или 4 столбца, и при необходимости параметр `dim = 'XYM'`.\n\nСоздание **полигонов** (*POLYGON*), **мультиполигонов** (*MULTIPOLYGON*) и **мультилиний** (*MULTILINESTRING*) требует уже создания списков из матриц.\n\nПочему нельзя представить обычный (не мульти) полигон просто матрицей координат? Потому что полигон может содержать дырки. Например, контур леса может содержать дырку в том месте, где находится озеро. Или озеро может содержать дырку в том месте, где находится остров. Природа предлагает нам бесконечное число таких примеров. В целях универсализации приходится закладываться на возможность наличия дырок в полигонах, поэтому даже полигоны без дырок представляются в виде списков. При этом действу.т следующее правила:\n\n-   Первая матрица координат в списке отвечает за контур полигона\n-   Все остальные матрицы координат отвечают за дыры в полигоне\n-   Координаты первой и последней точки в каждой матрице должны совпадать\n\nЕсли дыр в полигоне нет, его список будет содержать только одну матрицу. Рассмотрим оба примера построения **полигонов**:\n\n\n::: {.cell}\n\n```{.r .cell-code}\ncoords = matrix(c( # Координаты главного полигона\n  1, 0,\n  0, 2,\n  2, 3,\n  4, 2,\n  3, 0.5,\n  1, 0\n), ncol = 2, byrow = TRUE)\n\npol = st_polygon(list(coords)) # Простой полигон\nprint(pol)\n\nplot(pol, col = 'lightblue')\n```\n\n::: {.cell-output-display}\n![](09-SpatialData_files/figure-html/unnamed-chunk-32-1.png){width=100%}\n:::\n\n```{.r .cell-code}\n\nhole = matrix(c( # Координаты дыры\n  2, 1,\n  3, 1.5,\n  3, 2,\n  2, 2,\n  1.5, 1.5,\n  2, 1\n), ncol = 2, byrow = TRUE)\n\npol2 = st_polygon(list(coords, hole)) # Полигон с дырой\nprint(pol2)\n\nplot(pol2, col = 'lightblue')\n```\n\n::: {.cell-output-display}\n![](09-SpatialData_files/figure-html/unnamed-chunk-32-2.png){width=100%}\n:::\n:::\n\n\nМультиполигоны (*MULTIPOLYGON*) и мультилинии (*MULTILINESTRING*) требуются тогда, когда один и тот же географический объект состоит из нескольких геометрических объектов. Простейший пример --- островные государства. Чтобы представить страну, занимающую архипелаг (Багамские острова, Индонезия, Япония и т.д.) как один пространственный объект, необходимо создать мультиполигон. Все компоненты мультиполигона будут иметь общий набор атрибутов (непространственных характеристик). Мультилинии используются реже мультиполигонов и необходимы для представления линейных объектов, разорванных в пространстве. Примером такого объекта может быть любая река или канал, которые разорваны в тех местах, где они протекают через озеро или водохранилище, представленное полигональным объектом.\n\nВ мультиполигонах добавляется еще один уровень списка, то есть искомые матрицы координат будут располагаться как минимум на втором уровне вложенности:\n\n\n::: {.cell}\n\n```{.r .cell-code}\ncoords1 = matrix(c(\n  0.5, 0,\n  0, 1,\n  1, 1.5,\n  2, 1,\n  1.5, 0.25,\n  0.5, 0\n), ncol = 2, byrow = TRUE)\n\ncoords2 = matrix(c(\n  3, 1,\n  2.5, 2,\n  3.5, 2.5,\n  4, 2,\n  4, 1.25,\n  3, 1\n), ncol = 2, byrow = TRUE)\n\nmpol = st_multipolygon(list(list(coords1), list(coords2)))\nprint(mpol)\n\nplot(pol, col = 'grey') # Обычный полигон (серый)\nplot(mpol, col = 'pink', add = TRUE) # Мультиполигон (розовый)\n```\n\n::: {.cell-output-display}\n![](09-SpatialData_files/figure-html/unnamed-chunk-33-1.png){width=100%}\n:::\n:::\n\n\nКак насчет острова на озере? Если остров и суша, окружающая озеро, составляют единое целое (например, подлежат учету как единый массив леса), их можно собрать как мультиполигон. В этом случае первая компонента мультиполигона будет представлять собой полигон с дыркой, а вторая компонента --- остров. Порядок компонент в данном случае роли не играет:\n\n\n::: {.cell}\n\n```{.r .cell-code}\ncoords4 = matrix(c(\n  2.2, 1.2,\n  2.8, 1.5,\n  2.8, 1.8,\n  2.2, 1.8,\n  2.0, 1.6,\n  2.2, 1.2\n), ncol = 2, byrow = TRUE)\n\nisland = st_polygon(list(coords4))\n\nmpol2 = st_multipolygon(list(pol2, island))\n\nprint(mpol2)\n\nplot(mpol2, col = 'darkolivegreen4')\n```\n\n::: {.cell-output-display}\n![](09-SpatialData_files/figure-html/unnamed-chunk-34-1.png){width=100%}\n:::\n:::\n\n\nИз данного примера также видно, что при сборе мультиполигона на самом нижнем уровне вложенности можно подавать не списки матриц координат, а готовые полигоны.\n\nМультилиния, в отличие от мультиполигона, не требует дополнительного списка верхнего уровня, поскольку линии не могут содержать дыр. Например, можно собрать мультилинию из двух частей, соответствующих участкам реки до и после озера:\n\n\n::: {.cell}\n\n```{.r .cell-code}\ncoords1 = matrix(c(\n  -3, 0,\n  -1, 2,\n  0, 2\n), ncol = 2, byrow = TRUE)\n\ncoords2 = matrix(c(\n  4, 2,\n  5, 3,\n  6, 5\n), ncol = 2, byrow = TRUE)\n\nmline = st_multilinestring(list(coords1, coords2))\nprint(mline)\n\nplot(mline, lwd = 3, col = 'blue')\nplot(pol2, col = 'lightblue', add = TRUE)\n```\n\n::: {.cell-output-display}\n![](09-SpatialData_files/figure-html/unnamed-chunk-35-1.png){width=100%}\n:::\n:::\n\n\nНаконец, еще один вид геометрии --- это геометрическая коллекция (GEOMETRYCOLLECTION), который позволяет хранить вместе любые виды геометрий. Эта возможность используется достаточно редко, тем не менее, рассмотреть ее нужно. Геометрическая коллекция собирается из списка объектов с простыми типами геометрии (мы создали их ранее):\n\n\n::: {.cell}\n\n```{.r .cell-code}\ncol = st_geometrycollection(list(ls, mp, mline, pol2))\nprint(col)\nplot(col)\n```\n\n::: {.cell-output-display}\n![](09-SpatialData_files/figure-html/unnamed-chunk-36-1.png){width=100%}\n:::\n:::\n\n\n#### Списки геометрических объектов (sfc) {#sf_sfc}\n\nСписки геометрических объектов (класс `sfc`) используются в таблицах пространственных объектов в качестве столбца, который хранит геометрию объектов. Создание таких списков осуществляется функцией `st_sfc()`, которой достаточно передать в качестве перечня параметров объекты типа `sfg`. Рассмотрим создание списка геометрий на примере точечных объектов (для остальных типов объектов порядок действий не меняется):\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmoscow.sfg = st_point(c(37.615, 55.752))\nirkutsk.sfg = st_point(c(104.296, 52.298))\npetro.sfg = st_point(c(158.651, 53.044))\n\ncities.sfc = st_sfc(moscow.sfg, irkutsk.sfg, petro.sfg)\nprint(cities.sfc)\n## Geometry set for 3 features \n## Geometry type: POINT\n## Dimension:     XY\n## Bounding box:  xmin: 37.615 ymin: 52.298 xmax: 158.651 ymax: 55.752\n## CRS:           NA\n```\n:::\n\n\nПри создании списка геометрий для него может быть определена система координат (это можно сделать и позднее при создании таблицы пространственных объектов). Для этого используем уже знакомую нам функцию `st_crs()`:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nst_crs(cities.sfc) = st_crs(4326) # WGS84\nprint(cities.sfc)\n## Geometry set for 3 features \n## Geometry type: POINT\n## Dimension:     XY\n## Bounding box:  xmin: 37.615 ymin: 52.298 xmax: 158.651 ymax: 55.752\n## Geodetic CRS:  WGS 84\n```\n:::\n\n\n> Для списка геометрий может быть определена только одна система координат\n\nМожно посмотреть, куда легли наши точки:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nplot(cities.sfc, pch = 19)\ncountries |> \n  filter(sovereignt == 'Russia') |> \n  st_geometry() |>\n  plot(add = TRUE)\n```\n\n::: {.cell-output-display}\n![](09-SpatialData_files/figure-html/unnamed-chunk-39-1.png){width=100%}\n:::\n:::\n\n\n#### Пространственные объекты (sf) {#sf_sf}\n\nПространственные объекты (класс `sf`) организуются в виде фрейма данных, один из столбцов которого имеет класс `sfc`. Для этого следует сначала создать обычный фрейм данных с атрибутами, а затем соединить его со списком геометрий посредством функции `st_sf`:\n\n\n::: {.cell}\n\n```{.r .cell-code}\ncity.attr = data.frame(\n  name = c('Москва', 'Иркутск', 'Петропавловск-Камчатский'),\n  established = c(1147, 1661, 1740),\n  population = c(12500, 620, 180)\n)\n\ncites.sf = st_sf(city.attr, geometry = cities.sfc)\nprint(cites.sf)\n## Simple feature collection with 3 features and 3 fields\n## Geometry type: POINT\n## Dimension:     XY\n## Bounding box:  xmin: 37.615 ymin: 52.298 xmax: 158.651 ymax: 55.752\n## Geodetic CRS:  WGS 84\n##                       name established population               geometry\n## 1                   Москва        1147      12500  POINT (37.615 55.752)\n## 2                  Иркутск        1661        620 POINT (104.296 52.298)\n## 3 Петропавловск-Камчатский        1740        180 POINT (158.651 53.044)\n```\n:::\n\n\n#### Точки по координатам {#sf_geom_points}\n\nДостаточно распространенной является следующая задача: имеются координаты точек в табличной форме, необходимо создать на их основе набор пространственных объектов. Для решения этой задачи можно воспользоваться функцией `st_as_sf()`. Рассмотрим задачу на примере файла координат станций из базы метеорологических данных [**ВНИИГМИ-МЦД**](http://meteo.ru/):\n\n\n::: {.cell}\n\n```{.r .cell-code}\n(stations = read_fwf('data/vniigmi/stations.txt', \n                    col_positions = fwf_widths(diff(c(1, 7, 42, 47, 53, 59, 67, 71)), \n                                               col_names = c('id', 'name', 'lat', 't1', 'lon', 't2', 'z')),\n                    locale = locale(encoding = 'CP1251')))\n## # A tibble: 1,124 × 7\n##       id name                  lat t1      lon t2        z\n##    <dbl> <chr>               <dbl> <chr> <dbl> <chr> <dbl>\n##  1 20046 Им.Э.Т.Кренкеля,ГМО  80.6 с.ш.   58   в.д.     21\n##  2 20069 Остров_Визе          79.5 с.ш.   77.0 в.д.     10\n##  3 20087 Голомянный           79.6 с.ш.   90.6 в.д.      7\n##  4 20107 Баренцбург           78.1 с.ш.   14.2 в.д.     73\n##  5 20289 Русский              77.2 с.ш.   96.4 в.д.      9\n##  6 20292 Им.Е.К.Федорова,ГМО  77.7 с.ш.  104.  в.д.     12\n##  7 20353 мыс_Желания          77.0 с.ш.   68.6 в.д.      9\n##  8 20476 Стерлегова           75.4 с.ш.   88.9 в.д.     10\n##  9 20667 Им.М.В.Попова        73.3 с.ш.   70.0 в.д.      4\n## 10 20674 Остров_Диксон        73.5 с.ш.   80.4 в.д.     42\n## # ℹ 1,114 more rows\n```\n:::\n\n\nТеперь создадим пространственные точки на основе этой таблицы, взяв координаты из столбцов *lat* и *lon* соответственно и указав код системы координат:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nsf_stations = st_as_sf(stations, coords = c(\"lon\", \"lat\"), crs = 4326)\n\nplot(st_geometry(sf_stations), pch = 19, col = 'red', cex = 0.25)\nplot(st_geometry(countries), border = 'grey', add = TRUE)\nbox()\n```\n\n::: {.cell-output-display}\n![](09-SpatialData_files/figure-html/unnamed-chunk-42-1.png){width=100%}\n:::\n:::\n\n\n#### Преобразование типов геометрии {#sf_cast}\n\nДля преобразования типов геометрии существует функция `st_cast()`. Функция принимает объекты классов `sfg`, `sfc` или `sf`, а также название типа геометрии, к которому необходимо привести входные объекты. Довольно часто возникает задача конвертации площадного объекта в линейный и обратно, а также задача получения координат вершин линейного или площадного объекта в виде точек. Примеры преобразований:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nitaly.borders = st_cast(italy, 'MULTILINESTRING')\nclass(st_geometry(italy.borders))\n## [1] \"sfc_MULTILINESTRING\" \"sfc\"\n\nitaly.regions = st_cast(italy.borders, 'MULTIPOLYGON')\nclass(st_geometry(italy.regions))\n## [1] \"sfc_MULTIPOLYGON\" \"sfc\"\n\nitaly.points = st_cast(italy.borders, 'POINT')\nclass(st_geometry(italy.points))\n## [1] \"sfc_POINT\" \"sfc\"\n\nplot(st_geometry(italy.regions), lwd = 0.5)\nplot(italy.points, pch = 20, add = TRUE)\n```\n\n::: {.cell-output-display}\n![](09-SpatialData_files/figure-html/unnamed-chunk-43-1.png){width=100%}\n:::\n:::\n\n\n#### Полигонизация и разбиение линий {#sf_polygonize}\n\n**Полигонизация** --- это процесс преобразования линии или мультилинии в полигон(ы). Полигон может быть образован последовательностью из одной и более линий, для которых выполняются следующие условия:\n\n1.  Каждая линия является простой (не имеет самопересечений)\n2.  Линии касаются только своими начальными и конечными точками\n3.  Линии образуют замкнутую последовательность (т.е. выйдя из любой конечной точки и двигаясь вдоль множества линий, можно вернуться в ту же точку.)\n\nПолигонизация может применяться только к одному геометрическому объекту (simple feature geometry). Соответственно, это должна быть либо просто замкнутая линия, либо мультилиния, компоненты которой образуют замкнутую последовательность.\n\nРассмотрим операции полигонизации и добавления узлов на простом примере трех пересекающихся отрезков:\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Создадим три линии\ncoords1 = rbind(c(0, 0), c(0, 6))\nline1 = st_linestring(coords1)\n\ncoords2 = rbind(c(-1,1), c(5,1))\nline2 = st_linestring(coords2)\n\ncoords3 = rbind(c(-1,5), c(4,0))\nline3 = st_linestring(coords3)\n\n# Создадим мультилинию\nmls = st_multilinestring(list(line1, line2, line3))\nplot(mls)\n\n# Посмотрим на ее точки\npoints = st_cast(mls, 'MULTIPOINT')\nplot(points, pch = 20, add = TRUE)\n```\n\n::: {.cell-output-display}\n![](09-SpatialData_files/figure-html/unnamed-chunk-44-1.png){width=100%}\n:::\n:::\n\n\nИз рисунка видно, что линии образуют треугольную замкнутую область. Также рисунок показывает, что у компонент мультилинии нет вершин в точках пересечения. Мы можем попытаться найти замкнутые области и превратить их в полигоны, используя `st_polygonize()`:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nst_polygonize(mls)\n```\n:::\n\n\nОперация завершилась возвратом пустой геометрической коллекции, то есть программа не смогла выделить замкнутые области. Это произошло по причине того, что линии не разбиты в точках пересечения. Разбить их на компоненты можно, используя функцию `st_node()`:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmls2 = st_node(mls)\npoly2 = st_polygonize(mls2)\npoints2 = st_cast(mls2, 'MULTIPOINT')\n\nplot(mls2)\nplot(poly2, col = 'grey', add = TRUE)\nplot(points2, pch = 20, add = TRUE)\n```\n\n::: {.cell-output-display}\n![](09-SpatialData_files/figure-html/unnamed-chunk-46-1.png){width=100%}\n:::\n:::\n\n\nТаким образом, после разбиения линий на куски в точках пересечения стала возможной операция полигонизации.\n\n### Геометрические атрибуты {#sf_geom_attrs}\n\nК описательным характеристикам геометрии относятся ограничивающий прямоугольник, периметр (для линий и полигонов), площадь (для полигонов), центроид и список координат, которые можно получить с помощью функций `st_bbox()`, `st_length()`, `st_area()`, `st_centroid()` и `st_coordinates()` соответственно. Функции корректно работают для простых объектов, мультиобъектов, списков геометрий и пространственных объектов. Применительно к полигону Италии эти параметры будут учитывать части геометрии, занимаемые островами:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nst_bbox(italy)        # Координаты органичивающего прямоугольника\n##      xmin      ymin      xmax      ymax \n##  6.749955 36.619987 18.480247 47.115393\nst_area(italy)        # Площадь\n## 314577521836 [m^2]\nst_length(italy)      # Периметр\n## 0 [m]\nst_centroid(italy) |> st_geometry()    # Центроид (может быть не внутри для невыпуклых фигур)\n## Geometry set for 1 feature \n## Geometry type: POINT\n## Dimension:     XY\n## Bounding box:  xmin: 12.2687 ymin: 42.67074 xmax: 12.2687 ymax: 42.67074\n## Geodetic CRS:  WGS 84\nst_point_on_surface(italy) |> st_geometry() # Точка гарантированно внутри, но не обязательно в центре\n## Geometry set for 1 feature \n## Geometry type: POINT\n## Dimension:     XY\n## Bounding box:  xmin: 12.63118 ymin: 42.55822 xmax: 12.63118 ymax: 42.55822\n## Geodetic CRS:  WGS 84\nst_coordinates(italy) |> head() # Список координат\n##             X        Y L1 L2 L3\n## [1,] 10.44270 46.89355  1  1  1\n## [2,] 11.04856 46.75136  1  1  1\n## [3,] 11.16483 46.94158  1  1  1\n## [4,] 12.15309 47.11539  1  1  1\n## [5,] 12.37649 46.76756  1  1  1\n## [6,] 13.80648 46.50931  1  1  1\n```\n:::\n\n\nОбратите внимание на то, что площадь и периметр выводятся с указанием единиц измерений! Это возможно благодаря тому, что объекты типа `sf` поддерживают единицы измерений на основе пакета [units](https://cran.r-project.org/web/packages/units/index.html).\n\n> Если данные находятся в плоской прямоугольной системе координат, то единицы измерения как правило указываются в параметрах проекции --- следовательно, они могут быть использованы при вычислении геометрических параметров объектов. Если же данные хранятся в широтах и долготах, то вычисление геометрических параметров осуществляется пакетом *sf* по формулам сферической тригонометрии через пакет [geosphere](https://cran.r-project.org/web/packages/geosphere/index.html). Это позволяет выводить результат в плоских единицах измерения.\n\nОграничивающий прямоугольник можно быстро преобразовать в полигон и нанести на карту, применив функцию `st_as_sfc()`:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nbox = st_as_sfc(st_bbox(italy)) # Ограничивающий прямоугольник\n\nplot(italy |> st_geometry(), \n     col = 'lightgrey')\nplot(box, \n     border = 'orangered', \n     add = TRUE)\nplot(st_centroid(italy), \n     col = 'darkgreen', \n     pch = 19,\n     add = TRUE)\nplot(st_point_on_surface(italy), \n     col = 'steelblue4', \n     pch = 19,\n     add = TRUE)\n```\n\n::: {.cell-output-display}\n![](09-SpatialData_files/figure-html/unnamed-chunk-48-1.png){width=100%}\n:::\n:::\n\n\nКак видно, в данном случае центроид и характерная точка расположились относительно рядом. Однако так бывает далеко не всегда. Выполним аналогичные вычисления для Индонезии:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nindonesia = countries |> filter(sovereignt == 'Indonesia')\n\nbox = st_as_sfc(st_bbox(indonesia))\n\nplot(indonesia |> st_geometry(), \n     col = 'lightgrey')\nplot(box, \n     border = 'red', \n     add = TRUE)\nplot(st_centroid(indonesia), \n     col = 'darkgreen', \n     pch = 19,\n     add = TRUE)\nplot(st_point_on_surface(indonesia), \n     col = 'steelblue4', \n     pch = 19,\n     add = TRUE)\n```\n\n::: {.cell-output-display}\n![](09-SpatialData_files/figure-html/unnamed-chunk-49-1.png){width=100%}\n:::\n:::\n\n\nКак видно, в данном случае центроид мультиполигона оказался за пределами какой-либо из его полигональных компонент, в то время как характерная точка находится внутри одного из полигонов. Таким образом, если необходимо получить точку, находящуюся гарантированно в пределах исходного множества, следует использовать `st_point_on_surface()`. При этом следует помнить, что характерная точка, в отличие от центроида, может не располагаться в визуальном центре тяжести множества объектов, и выбор между этими способами описания геометрии остается за разработчиком.\n\n### Экспорт {#sf_export}\n\nДля экспорта векторных пространственных данных можно воспользоваться функцией `st_write()`, которая определит формат выходного файла по указанному вами расширению:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nst_write(cites.sf, 'data/mycities.shp') # Шейп-файл\n```\n:::\n\n\n## Растровые данные {#raster_data_r}\n\nРабота с растровыми данными в целом гораздо проще, чем работа с векторными объектами. Это обусловлено в том числе жесткой сеточной структурой данных, которая предоставляет не так много свободы в различных сценариях обработки данных. В то же время, эта структура позволяет сделать растровые алгоритмы универсальными и робастными, многие задачи решаются в растровом виде быстрее и проще, чем в векторном.\n\n### Теоретические сведения {#raster_data}\n\n**Растр** представляет из себя матрицу значений. Каждой ячейке матрицы соответствует прямоугольная пространственная область фиксированного размера, которая называется *пикселом*. Различают растры *непрерывные* и *категориальные (классифицированные)*. Также необходимо разделять *одноканальные* и *многоканальные растры*. Примером одноканального растра является цифровая модель рельефа. В виде многоканальных растров часто представляют космические снимки.\n\nВ отличие от векторных данных, которые требуют указания координат для каждой вершины, регулярно-ячеистый характер растровой модели позволяет вычислять координаты пикселов на основе их индексов. Поэтому фактически растровые данные хранятся в виде линейно упорядоченного списка значений *(raster values)* и описания геометрии растра *(raster geometry)*.\n\n**Геометрия растра** определяет, где именно располагаются в пространстве пикселы растра и может быть описана путем указания следующих компонент[^09-spatialdata-3]:\n\n[^09-spatialdata-3]: Названия перечисленных компонент геометрии растра укоренились благодаря распространенности стандарта [Esri ASCII Grid](https://en.wikipedia.org/wiki/Esri_grid)\n\n| Параметр    | Назначение                                       |\n|-------------|--------------------------------------------------|\n| `NCOLS`     | Количество столбцов                              |\n| `NROWS`     | Количество строк                                 |\n| `XLLCENTER` | Координата $X$ центра левой нижней ячейки растра |\n| `YLLCENTER` | Координата $Y$ центра левой нижней ячейки растра |\n| `CELLSIZE`  | Размер ячейки                                    |\n\nИногда вместо параметров `XLLCENTER`/`YLLCENTER` указываются `XLLCORNER`/`YLLCORNER`, которые кодируют координаты левого нижнего угла, а не центра левой нижней ячейки растра. Выбор одного из двух этих вариантов определяет тип *регистрации растра*, а их значения указывают, в какое именно место необходимо \"посадить\" растр, чтобы его ячейки заняли соответствующие им области в системе координат. Если геометрия растра характеризуется *анизотропией*, то вместо одного значения `CELLSIZE` могут быть указаны разные размеры ячеек по осям координат `CELLSIZEX` и `CELLSIZEY`.\n\nВ отличие от векторной модели, которая позволяет хранить данные только о нужных географических локациях, растровая модель такой свободы не предоставляет. Матрица ячеек растра всегда покрывает область данных целиком, и за простоту растровой структуры приходится расплачиваться ее неэкономичностью. Поскольку часто данные имеются не на всю территорию, возникает необходимость кодирования ячеек, для которых данные не известны, специальным числом (назовем его условно `NODATA_VALUE`). Значение этого числа хранится в метаданных растра и позволяет интерпретировать соответствующие ячейки как пустые.\n\nВ настоящее время для работы с растровыми данными в R используются два пакета: [**stars**](https://r-spatial.github.io/stars/) и [**terra**](https://cran.r-project.org/web/packages/terra/index.html). **terra** является наследником пакета [raster](https://cran.r-project.org/web/packages/terra/index.html), который исторически был основным средством работы с растровыми данными и обладает широким спектром функций растрового анализа. **stars** --- относительно новый, разработан с целью поддержки многомерных данных и более тесного взаимодействия с пакетом `sf`. В целом можно сказать, что пакеты **terra** и **stars** частично пересекаются по функциональности, но скорее дополняют друг друга, нежели дублируют.\n\nВ этой и ближайших лекциях мы будем работать с растрами в формате **stars**, поскольку он концептуально близок к пакету **sf**.\n\n### Чтение {#raster_read}\n\nДля чтения растров любой размерности можно использовать функцию `read_stars()`:\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndem = read_stars('data/world/gebco.tif') # Цифровая модель рельефа\ndem\n## stars object with 2 dimensions and 1 attribute\n## attribute(s):\n##              Min. 1st Qu. Median      Mean 3rd Qu. Max.\n## gebco.tif  -10348   -4287  -2458 -1890.525     215 6581\n## dimension(s):\n##   from  to offset delta refsys point x/y\n## x    1 900   -180   0.4 WGS 84 FALSE [x]\n## y    1 450     90  -0.4 WGS 84 FALSE [y]\n\nimg = read_stars('data/world/BlueMarbleJuly.tif') # Цветной космический снимок (RGB)\nimg\n## stars object with 3 dimensions and 1 attribute\n## attribute(s):\n##                     Min. 1st Qu. Median     Mean 3rd Qu. Max.\n## BlueMarbleJuly.tif     1      13     33 63.13569      75  255\n## dimension(s):\n##      from  to offset delta refsys point x/y\n## x       1 720   -180   0.5 WGS 84 FALSE [x]\n## y       1 360     90  -0.5 WGS 84 FALSE [y]\n## band    1   3     NA    NA     NA    NA\n```\n:::\n\n\n### Внутренняя структура {#stars_inner}\n\nДля работы с данными типа stars необходимо понимать их внутреннюю структуру. Для начала можно взглянуть на нее посредством стандартной функции `str()`:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nstr(img)\n## List of 1\n##  $ BlueMarbleJuly.tif: num [1:720, 1:360, 1:3] 6 4 7 7 7 7 7 8 8 8 ...\n##  - attr(*, \"dimensions\")=List of 3\n##   ..$ x   :List of 7\n##   .. ..$ from  : num 1\n##   .. ..$ to    : num 720\n##   .. ..$ offset: num -180\n##   .. ..$ delta : num 0.5\n##   .. ..$ refsys:List of 2\n##   .. .. ..$ input: chr \"WGS 84\"\n##   .. .. ..$ wkt  : chr \"GEOGCRS[\\\"WGS 84\\\",\\n    ENSEMBLE[\\\"World Geodetic System 1984 ensemble\\\",\\n        MEMBER[\\\"World Geodetic Sys\"| __truncated__\n##   .. .. ..- attr(*, \"class\")= chr \"crs\"\n##   .. ..$ point : logi FALSE\n##   .. ..$ values: NULL\n##   .. ..- attr(*, \"class\")= chr \"dimension\"\n##   ..$ y   :List of 7\n##   .. ..$ from  : num 1\n##   .. ..$ to    : num 360\n##   .. ..$ offset: num 90\n##   .. ..$ delta : num -0.5\n##   .. ..$ refsys:List of 2\n##   .. .. ..$ input: chr \"WGS 84\"\n##   .. .. ..$ wkt  : chr \"GEOGCRS[\\\"WGS 84\\\",\\n    ENSEMBLE[\\\"World Geodetic System 1984 ensemble\\\",\\n        MEMBER[\\\"World Geodetic Sys\"| __truncated__\n##   .. .. ..- attr(*, \"class\")= chr \"crs\"\n##   .. ..$ point : logi FALSE\n##   .. ..$ values: NULL\n##   .. ..- attr(*, \"class\")= chr \"dimension\"\n##   ..$ band:List of 7\n##   .. ..$ from  : num 1\n##   .. ..$ to    : int 3\n##   .. ..$ offset: num NA\n##   .. ..$ delta : num NA\n##   .. ..$ refsys: chr NA\n##   .. ..$ point : logi NA\n##   .. ..$ values: NULL\n##   .. ..- attr(*, \"class\")= chr \"dimension\"\n##   ..- attr(*, \"raster\")=List of 4\n##   .. ..$ affine     : num [1:2] 0 0\n##   .. ..$ dimensions : chr [1:2] \"x\" \"y\"\n##   .. ..$ curvilinear: logi FALSE\n##   .. ..$ blocksizes : int [1:3, 1:2] 720 720 720 1 1 1\n##   .. .. ..- attr(*, \"dimnames\")=List of 2\n##   .. .. .. ..$ : NULL\n##   .. .. .. ..$ : chr [1:2] \"x\" \"y\"\n##   .. ..- attr(*, \"class\")= chr \"stars_raster\"\n##   ..- attr(*, \"class\")= chr \"dimensions\"\n##  - attr(*, \"class\")= chr \"stars\"\n```\n:::\n\n\nВидно, что данный трёхканальный растр представляет собой список из единственного элемента с названием `BlueMarbleJuly.tif` --- это имя было присвоено автоматически при чтении растра. Каждый такой элемент соответствует *переменной* данных. В данном случае переменная одна --- это интенсивность цвета. Хранится она в виде трехмерного массива (`array`) размерностью $720 \\times 360 \\times 3$:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nstr(img[[1]])\n##  num [1:720, 1:360, 1:3] 6 4 7 7 7 7 7 8 8 8 ...\nimg[[1]][100, 200, 2]\n## [1] 14\n```\n:::\n\n\nКаждой оси этого массива соответствует измерение (`dimension`), которое определяет параметры отображения индексов массива на соответствующую систему координат (пространственную, временную, спектральную и т.д.). Например, чтобы понять, что ячейка растра с индексами `[36, 18, ]` имеет географические координаты (широту и долготу) `(0, 0)`, нужно знать направления осей растра, размер ячейки и координаты одной из угловых ячеек растра. Необходимая информация находится в атрибуте `dimensions` объекта `stars`, т.е. является общей для всех переменных. При печати параметры измерений выводятся в удобном табличном виде:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nattr(img, 'dimensions')\n##      from  to offset delta refsys point x/y\n## x       1 720   -180   0.5 WGS 84 FALSE [x]\n## y       1 360     90  -0.5 WGS 84 FALSE [y]\n## band    1   3     NA    NA     NA    NA\n```\n:::\n\n\nЭтот атрибут представляет собой список, длина которого равна количеству измерений в массиве данных переменной. Обычно измерения имеют имена, в данном случае это `x`, `y` и `band`. Описание каждого измерения выполнено по единому шаблону, который включает следующие параметры:\n\n-   `from`: начальный индекс (будет меняться при обрезке растра при постоянной точке отсчета индексов);\n-   `to`: конечный индекс (будет меняться при обрезке растра при постоянной точке отсчета индексов);\n-   `offset`: координата первого пиксела (точки отсчета);\n-   `delta`: размер ячейки;\n-   `refsys`: координатная (референцная) система: для систем счета координат, времени, высот и других измерений будет своя;\n-   `point`: логическое значение, которое указывает, следует ли интерпретировать элементы растра по этой оси как измеренные в точке (мгновенные) или агрегированные по площади (за временной период);\n-   `values`: значения координат ячеек по данной оси\n    -   `NULL` (используется в большинстве случаев, т.к. координаты могут быть вычислены на основе `from`, `delta` и индекса пиксела),\n    -   вектор координат (используется для представления ректилинейных растров в переменным размром пиксела),\n    -   объект класса `intervals` (список из двух векторов --- начал и концов интервалов), or\n    -   матрица координат такой же размерности, что и пространственные измерения растра. В случае стекущего примера будет иметь размер $720 \\times 360$. Используется для представления *криволинейных* растров.\n\nНапример, посмотрим параметры измерения `x` растра:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nattr(img, 'dimensions')[['x']]\n## $from\n## [1] 1\n## \n## $to\n## [1] 720\n## \n## $offset\n## [1] -180\n## \n## $delta\n## [1] 0.5\n## \n## $refsys\n## Coordinate Reference System:\n##   User input: WGS 84 \n##   wkt:\n## GEOGCRS[\"WGS 84\",\n##     ENSEMBLE[\"World Geodetic System 1984 ensemble\",\n##         MEMBER[\"World Geodetic System 1984 (Transit)\"],\n##         MEMBER[\"World Geodetic System 1984 (G730)\"],\n##         MEMBER[\"World Geodetic System 1984 (G873)\"],\n##         MEMBER[\"World Geodetic System 1984 (G1150)\"],\n##         MEMBER[\"World Geodetic System 1984 (G1674)\"],\n##         MEMBER[\"World Geodetic System 1984 (G1762)\"],\n##         MEMBER[\"World Geodetic System 1984 (G2139)\"],\n##         ELLIPSOID[\"WGS 84\",6378137,298.257223563,\n##             LENGTHUNIT[\"metre\",1]],\n##         ENSEMBLEACCURACY[2.0]],\n##     PRIMEM[\"Greenwich\",0,\n##         ANGLEUNIT[\"degree\",0.0174532925199433]],\n##     CS[ellipsoidal,2],\n##         AXIS[\"geodetic latitude (Lat)\",north,\n##             ORDER[1],\n##             ANGLEUNIT[\"degree\",0.0174532925199433]],\n##         AXIS[\"geodetic longitude (Lon)\",east,\n##             ORDER[2],\n##             ANGLEUNIT[\"degree\",0.0174532925199433]],\n##     USAGE[\n##         SCOPE[\"Horizontal component of 3D system.\"],\n##         AREA[\"World.\"],\n##         BBOX[-90,-180,90,180]],\n##     ID[\"EPSG\",4326]]\n## \n## $point\n## [1] FALSE\n## \n## $values\n## NULL\n## \n## attr(,\"class\")\n## [1] \"dimension\"\n```\n:::\n\n\nНаконец, дополнительно к этому атрибут `dimensions` имеет свой собственный атрибут `raster`, который необходим для того чтобы определить какие именно измерения растра являются пространственными, а также установить преобразования, которые будут над ними производиться при анализе или визулизации:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nimg |> attr('dimensions') |> attr('raster') |> str()\n## List of 4\n##  $ affine     : num [1:2] 0 0\n##  $ dimensions : chr [1:2] \"x\" \"y\"\n##  $ curvilinear: logi FALSE\n##  $ blocksizes : int [1:3, 1:2] 720 720 720 1 1 1\n##   ..- attr(*, \"dimnames\")=List of 2\n##   .. ..$ : NULL\n##   .. ..$ : chr [1:2] \"x\" \"y\"\n##  - attr(*, \"class\")= chr \"stars_raster\"\n```\n:::\n\n\nВидно, что атрибут `raster` содержит 3 элемента:\n\n-   `dimensions`: названия измерений, которые являются пространственными\n-   `affine`: параметры аффинного преобразования, которое будет применяться к пространственным измерениям перед их отображением или применением в операциях пространственного анализа\n-   `curvilinear`: логическое значение, которое устанавливает, является ли растр криволинейным (в этом случае в параметре `values` пространственных измерений должна быть матрица координат)\n\n### Визуализация {#raster_viz}\n\n#### Статичные карты {#raster_viz_static}\n\nДля визуализации одноканальных растров используется функция `plot()`. В простейшем виде ей достаточно просто передать визуализируемый растр:\n\n\n::: {.cell}\n\n```{.r .cell-code}\npar(mfrow = c(1,1))\nplot(dem)\n```\n\n::: {.cell-output-display}\n![](09-SpatialData_files/figure-html/unnamed-chunk-57-1.png){width=100%}\n:::\n:::\n\n\nПоскольку растры часто используют в классифицированном виде, вы можете сформировать вектор граничных значений классов, вектор цветов классов, и передать их в параметры `breaks` и `col` функции `plot()` соответственно. Если параметр `breaks` не определять, то весь диапазон значений растра будет разбит на равные интервалы соответственно количеству цветов. Если не определять параметр `col`, то будет применена стандартная палитра `terrain.colors`. Вы также можете использовать одну из готовых палитр цветов или создать ее вручную (см. посвященную графической подсистеме R):\n\n\n::: {.cell}\n\n```{.r .cell-code}\nbrks = c(-12000, -5000, -2500, -1000, -200, 0, 200, 500, 1000, 2000, 4000, 8000)\nclrs = c(\n  \"steelblue4\",\n  \"steelblue3\",\n  \"steelblue2\",\n  \"steelblue1\",\n  \"lightskyblue1\",\n  \"darkseagreen\",\n  \"lightgoldenrod1\",\n  \"darkgoldenrod1\",\n  \"darkorange\",\n  \"coral2\",\n  \"firebrick3\")\n\nplot(dem, breaks = brks, col = clrs)\n```\n\n::: {.cell-output-display}\n![](09-SpatialData_files/figure-html/unnamed-chunk-58-1.png){width=100%}\n:::\n\n```{.r .cell-code}\n\nplot(dem, col = colorRampPalette(c(\"black\", \"white\"))(255))\n```\n\n::: {.cell-output-display}\n![](09-SpatialData_files/figure-html/unnamed-chunk-58-2.png){width=100%}\n:::\n\n```{.r .cell-code}\n\nplot(dem, col = rainbow(10))\n```\n\n::: {.cell-output-display}\n![](09-SpatialData_files/figure-html/unnamed-chunk-58-3.png){width=100%}\n:::\n:::\n\n\nДля синтезирования цветного изображения на основе многоканального растра необходимо объект `stars` предварительно подать в функцию `st_rgb()`:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nplot(st_rgb(img))\n```\n\n::: {.cell-output-display}\n![](09-SpatialData_files/figure-html/unnamed-chunk-59-1.png){width=100%}\n:::\n:::\n\n\nПоскольку при визуализации космических снимков часто используют различные варианты синтеза каналов (чтобы лучше дешифрировать те или иные категории объектов), функция `st_rgb()` предоставляет такую возможность. Достаточно перечислить последовательность каналов растрового стека (по умолчанию эти каналы будут подставлены в каналы R, G и B соответственно):\n\n\n::: {.cell}\n\n```{.r .cell-code}\nst_rgb(img[,,,c(1, 2, 3)]) |> plot()\n```\n\n::: {.cell-output-display}\n![](09-SpatialData_files/figure-html/unnamed-chunk-60-1.png){width=100%}\n:::\n\n```{.r .cell-code}\nst_rgb(img[,,,c(1, 3, 2)]) |> plot()\n```\n\n::: {.cell-output-display}\n![](09-SpatialData_files/figure-html/unnamed-chunk-60-2.png){width=100%}\n:::\n\n```{.r .cell-code}\nst_rgb(img[,,,c(2, 1, 3)]) |> plot()\n```\n\n::: {.cell-output-display}\n![](09-SpatialData_files/figure-html/unnamed-chunk-60-3.png){width=100%}\n:::\n\n```{.r .cell-code}\nst_rgb(img[,,,c(2, 3, 1)]) |> plot()\n```\n\n::: {.cell-output-display}\n![](09-SpatialData_files/figure-html/unnamed-chunk-60-4.png){width=100%}\n:::\n\n```{.r .cell-code}\nst_rgb(img[,,,c(3, 1, 2)]) |> plot()\n```\n\n::: {.cell-output-display}\n![](09-SpatialData_files/figure-html/unnamed-chunk-60-5.png){width=100%}\n:::\n\n```{.r .cell-code}\nst_rgb(img[,,,c(3, 2, 1)]) |> plot()\n```\n\n::: {.cell-output-display}\n![](09-SpatialData_files/figure-html/unnamed-chunk-60-6.png){width=100%}\n:::\n:::\n\n\nВы можете совмещать на картах несколько растровых и векторных слоев точно так же как и при совмещении векторных данных (указав параметр `add = TRUE` при вызове функции `plot()`):\n\n\n::: {.cell}\n\n```{.r .cell-code}\nplot(st_rgb(img), reset = FALSE)\nplot(outlines, border = rgb(1,1,1,0.5), lwd = 0.5, add = TRUE)\n```\n\n::: {.cell-output-display}\n![](09-SpatialData_files/figure-html/unnamed-chunk-61-1.png){width=100%}\n:::\n:::\n\n\n#### Интерактивные карты {#raster_viz_inter}\n\nОбъекты типа stars могут быть визуализированы аналогично векторным на интерактивных картах `mapview`:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmapview(dem, at = brks, col = clrs)\n```\n:::\n\n::: {.cell}\n::: {.cell-output-display}\n![](images/mapview4.png){width=100%}\n:::\n:::\n\n\n### Обрезка {#raster_crop}\n\nОдна из распространенных задач при работе с растрами --- это обрезка, то есть удаление растровых данных, находящихся за пределами указанной территории. Чаще всего обрезку делают либо ограничивающим прямоугольником, либо полигональным объектом. Рассмотрим оба варианта:\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Обрезка по ограничивающему прямоугольнику\nbox = st_bbox(c(xmin = -80, xmax = -10, ymax = 85, ymin = 58), crs = st_crs(4326))\ndem_greenland = dem[box]\n\ndem_greenland\n## stars object with 2 dimensions and 1 attribute\n## attribute(s):\n##             Min. 1st Qu. Median     Mean 3rd Qu. Max.\n## gebco.tif  -4041    -811    -49 70.50328 1187.25 3228\n## dimension(s):\n##   from  to offset delta refsys point x/y\n## x  251 425   -180   0.4 WGS 84 FALSE [x]\n## y   13  80     90  -0.4 WGS 84 FALSE [y]\n\nplot(dem_greenland)\n```\n\n::: {.cell-output-display}\n![](09-SpatialData_files/figure-html/unnamed-chunk-64-1.png){width=100%}\n:::\n:::\n\n\nАналогичным образом можено обрезать растр контуром выбранной страны:\n\n\n::: {.cell}\n\n```{.r .cell-code}\ncountry = countries |> \n  filter(name == 'Afghanistan')\ndem_country = dem[country]\ndem_country\n## stars object with 2 dimensions and 1 attribute\n## attribute(s):\n##            Min. 1st Qu. Median     Mean 3rd Qu. Max. NA's\n## gebco.tif   261   877.5   1628 1824.854    2635 5036  485\n## dimension(s):\n##   from  to offset delta refsys point x/y\n## x  602 638   -180   0.4 WGS 84 FALSE [x]\n## y  129 152     90  -0.4 WGS 84 FALSE [y]\nplot(dem_country)\n```\n\n::: {.cell-output-display}\n![](09-SpatialData_files/figure-html/unnamed-chunk-65-1.png){width=100%}\n:::\n:::\n\n\n### Индексирование\n\nОртогональная структура объектов типа stars позволяет выполнять по ним различные срезы, отсекая ненужные данные. Для этого используется привычный по работе с векторами оператор квадратной скобки `[`, который работает следующим образом:\n\n-   первый аргумент выбирает атрибут\n-   второй и последующий аргументы выбирают измерения.\n\nТаким образом, при работе с растрами, которые содержат один атрибут, вам необходимо указать 4 индекса: `[var, x, y, band]`, где `var` - это название или порядковый номер атрибута, а `x, y, band` --- порядковые номера двух координатных и одного семантического измерения.\n\nНапример:\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# выбрать 1 канал\nch1 = img[,,,1] \nch1\n## stars object with 3 dimensions and 1 attribute\n## attribute(s):\n##                     Min. 1st Qu. Median    Mean 3rd Qu. Max.\n## BlueMarbleJuly.tif     1       5     14 51.1141      47  255\n## dimension(s):\n##      from  to offset delta refsys point x/y\n## x       1 720   -180   0.5 WGS 84 FALSE [x]\n## y       1 360     90  -0.5 WGS 84 FALSE [y]\n## band    1   1     NA    NA     NA    NA\nplot(ch1)\n```\n\n::: {.cell-output-display}\n![](09-SpatialData_files/figure-html/unnamed-chunk-66-1.png){width=100%}\n:::\n\n```{.r .cell-code}\n\n# выбрать диапазон ячеек растра\nfrag = img[, 320:470, 100:255, ] \nfrag\n## stars object with 3 dimensions and 1 attribute\n## attribute(s):\n##                     Min. 1st Qu. Median     Mean 3rd Qu. Max.\n## BlueMarbleJuly.tif     1      20     50 65.96065     106  221\n## dimension(s):\n##      from  to offset delta refsys point x/y\n## x     320 470   -180   0.5 WGS 84 FALSE [x]\n## y     100 255     90  -0.5 WGS 84 FALSE [y]\n## band    1   3     NA    NA     NA    NA\nplot(st_rgb(frag))\n```\n\n::: {.cell-output-display}\n![](09-SpatialData_files/figure-html/unnamed-chunk-66-2.png){width=100%}\n:::\n:::\n\n\n### Манипуляции\n\nОбъекты типа `stars` поддерживают манипуляции, аналогичные тем, что могут применяться к векторным данным. Посмотрим это на примере данных по высоте земной поверхности с учетом и без покровного оледенения:\n\n\n::: {.cell}\n\n```{.r .cell-code}\netopo = read_stars(c('data/etopo1_bed.tif', 'data/etopo1_ice.tif'))\netopo\n## stars object with 2 dimensions and 2 attributes\n## attribute(s):\n##        Min. 1st Qu.  Median      Mean 3rd Qu. Max.\n## bed  -10632   -4287 -2451.5 -2113.199      86 6159\n## ice  -10632   -4287 -2451.5 -1892.726     215 6159\n## dimension(s):\n##   from  to offset delta refsys point x/y\n## x    1 720   -180   0.5 WGS 84 FALSE [x]\n## y    1 360     90  -0.5 WGS 84 FALSE [y]\n```\n:::\n\n\nДля начала переименуем переменные:\n\n\n::: {.cell}\n\n```{.r .cell-code}\netopo = etopo |> setNames(c('bed', 'ice'))\netopo\n## stars object with 2 dimensions and 2 attributes\n## attribute(s):\n##        Min. 1st Qu.  Median      Mean 3rd Qu. Max.\n## bed  -10632   -4287 -2451.5 -2113.199      86 6159\n## ice  -10632   -4287 -2451.5 -1892.726     215 6159\n## dimension(s):\n##   from  to offset delta refsys point x/y\n## x    1 720   -180   0.5 WGS 84 FALSE [x]\n## y    1 360     90  -0.5 WGS 84 FALSE [y]\n```\n:::\n\n\nПосле этого посчитаем, например, толщину покровного оледеления как разность `ice` и `bed` через *мутирование*:\n\n\n::: {.cell}\n\n```{.r .cell-code}\netopo = etopo |>\n  mutate(depth = ice - bed)\n\nplot(etopo['depth'], \n     col = cm.colors(5),\n     breaks = c(0, 500, 1000, 2000, 3000, 4000),\n     main = 'Мощность покровного оледенения',\n     reset = FALSE)\nplot(oceans, col = 'steelblue', add = TRUE)\n```\n\n::: {.cell-output-display}\n![](09-SpatialData_files/figure-html/unnamed-chunk-69-1.png){width=100%}\n:::\n:::\n\n\n*Фильтрация* происходит по измерениям, но применяется не к индексам ячеек, а к соответствующим величинам измерений:\n\n\n::: {.cell}\n\n```{.r .cell-code}\ngreenland = etopo |> \n  filter(x > -80, x < -10, y > 58, y < 85)\n\nplot(greenland)\n```\n\n::: {.cell-output-display}\n![](09-SpatialData_files/figure-html/unnamed-chunk-70-1.png){width=100%}\n:::\n:::\n\n\n*Выбор* переменной позволяет оставить только ее:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nicedepth = etopo |> \n  select(depth)\n\nicedepth\n## stars object with 2 dimensions and 1 attribute\n## attribute(s):\n##        Min. 1st Qu. Median     Mean 3rd Qu. Max.\n## depth  -198       0      0 220.4736       0 4286\n## dimension(s):\n##   from  to offset delta refsys point x/y\n## x    1 720   -180   0.5 WGS 84 FALSE [x]\n## y    1 360     90  -0.5 WGS 84 FALSE [y]\n```\n:::\n\n\n### Экспорт {#raster_export}\n\nЧтобы экспортировать (сохранить в файл) любой растр, можно воспользоваться функцией `write_stars()`, указав имя выходного файла:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nwrite_stars(greenland, 'data/world/greenland.tif')\n```\n:::\n\n\n## Пространственная привязка {#spatref}\n\n### Компоненты пространственной привязки {#spatref_components}\n\n**Пространственная привязка** (*spatial reference* или *georeference*) --- важнейшая составляющая пространственных данных, которая говорит нам о том, как правильно интерпретировать координаты объектов. Пространственная привязка в простейшем случае включает несколько фундаментальных компонент:\n\n1.  *Эллипсоид вращения* --- тело, по отношению к которому вычисляются геодезические координаты точек (широты и долготы)\n2.  *Исходные геодезические даты (датум)* --- параметры положения эллипсоида в теле Земли\n3.  *Географическая система координат* --- включает датум, положение начального меридиана и единицы измерения широт и долгот\n4.  *Проекция* --- математический способ перехода от географических координат на эллипсоиде к плоским прямоугольным координатам карты.\n5.  *Плоская прямоугольная система координат* --- включает проекцию, ее параметры и единицы измерения координат.\n\nЕсли точки имеют также координаты $Z$, то для их правильной интерпретации необходимы дополнительные компоненты пространственной привязки:\n\n1.  *Система счета высот* (геодезические, нормальные, ортометрические) - определяют содержательный смысл и порядок вычисления высот и глубин (координата Z)\n2.  *Модель геоида, квазигеоида или эллипсоида* --- определяет поверхность, относительно которой вычисляются высоты точек.\n3.  *Вертикальная система координат* --- фактическая реализация системы счета высот относительно конкретной поверхности относимости с заданным положением нулевого уровня. Например, в России это *Балтийская система нормальных высот* с нулем в г. Кронштадт.\n\nАналогичным образом требуется введение системы счета дополнительных координат $M$, если они используются в представлении координат.\n\n### Форматы описания пространственной привязки {#spatref_formats}\n\nСуществует три распространенных способа задания (хранения) пространственной привязки:\n\n-   *PROJ.4 String* --- представление в виде строки.\n-   *WKT (Well-Known Text)* --- представление в виде иерархического списка. Это *наиболее полный* формат описания пространственной привязки, который рекомендуется к использованию для избежания неоднозначностей.\n-   *EPSG (European Petroleum Survey Group)* --- представление в виде числового кода.\n\nДля поиска проекций в перечисленных форматах представления удобно воспользоваться порталом [spatialreference.org](spatialreference.org).\n\n**PROJ.4 String** --- строковый формат представления информации о пространственной привязки, используемый в библиотеке [**PROJ**](http://proj.org). Данная библиотека лежит в основе координатных систем пространственных данных, используется в **R**, **Python**, **QGIS** и прочих средах. Основные параметры строки:\n\n```         \n+datum     Datum name (see `proj -ld`)\n+ellps     Ellipsoid name (see `proj -le`)\n+lat_0     Latitude of origin\n+lat_1     Latitude of first standard parallel\n+lat_2     Latitude of second standard parallel\n+lat_ts    Latitude of true scale\n+lon_0     Central meridian\n+proj      Projection name (see `proj -l`)\n+units     meters, US survey feet, etc.\n+vunits    vertical units.\n+x_0       False easting\n+y_0       False northing\n+zone      UTM zone\n```\n\nПримеры записи координат в формате PROJ.4:\n\n-   Географические координаты в *WGS84* (без проекции):\n\n\n::: {.cell}\n\n:::\n\n\n-   Координаты в проекции *Web Mercator* (проекция Google Maps, Яндекс.Карт и т.д.):\n\n\n::: {.cell}\n\n:::\n\n\n-   Координаты в *конической равнопромежуточной проекции*:\n\n\n::: {.cell}\n\n:::\n\n\n-   Координаты в проекции *UTM, зона 37*:\n\n\n::: {.cell}\n\n:::\n\n\n**WKT** предполагает представление вышеуказанных компонент пространственной привязки к виде иерархического списка. Например, так будет выглядеть информация о *полярной стереографической проекции для карт России*:\n\n```         \nPROJCS[\"WGS 84 / EPSG Russia Polar Stereographic\",\n    GEOGCS[\"WGS 84\",\n        DATUM[\"WGS_1984\",\n            SPHEROID[\"WGS 84\",6378137,298.257223563,\n                AUTHORITY[\"EPSG\",\"7030\"]],\n            AUTHORITY[\"EPSG\",\"6326\"]],\n        PRIMEM[\"Greenwich\",0,\n            AUTHORITY[\"EPSG\",\"8901\"]],\n        UNIT[\"degree\",0.0174532925199433,\n            AUTHORITY[\"EPSG\",\"9122\"]],\n        AUTHORITY[\"EPSG\",\"4326\"]],\n    PROJECTION[\"Polar_Stereographic\"],\n    PARAMETER[\"latitude_of_origin\",90],\n    PARAMETER[\"central_meridian\",105],\n    PARAMETER[\"scale_factor\",0.994],\n    PARAMETER[\"false_easting\",2000000],\n    PARAMETER[\"false_northing\",2000000],\n    UNIT[\"metre\",1,\n        AUTHORITY[\"EPSG\",\"9001\"]],\n    AXIS[\"X\",EAST],\n    AXIS[\"Y\",NORTH],\n    AUTHORITY[\"EPSG\",\"5940\"]]\n```\n\n**EPSG (European Petroleum Survey Group)** --- европейская рабочая группа нефтегазовой области, которая ведет реестр систем координат с уникальными цифровыми кодами вида `EPSG:xxxxxx`. Коды EPSG оказались настолько удобны, что используются повсеместно для быстрой инициализации проекций со стандартными параметрами. Например, вышеприведенные проекции имеют следующие коды EPSG:\n\n-   *WGS84*: `EPSG:4326`\n-   *Web Mercator*: `EPSG:3857`\n-   *UTM*: `EPSG:326..` , например для UTM 37N: `EPSG:32637`\n\n### Преобразование координат {#spatref_transform}\n\nПреобразование координат включает три различных операции:\n\n1.  **Трансформирование** --- пересчет географических координат с одного датума на другой\n\n2.  **Проецирование** --- переход от географических координат к плоским прямоугольным\n\n3.  **Обратное проецирование** --- переход от плоских координат к географическим.\n\nНапример, чтобы пересчитать координаты *UTM* в проекцию *Гаусса-Крюгера*, необходимо:\n\n1.  Обратно проецировать координаты в географические *WGS84*\n2.  Трансформировать географические координаты c *WGS84* в *ГСК-2011*\n3.  Проецировать координаты *ГСК-2011* в проекцию *Гаусса-Крюгера*\n\n*Несоответствие датумов часто является причиной того, что данные из разных наборов плохо совмещаются друг с другом*\n\n### Работа с пространственной привязкой в R {#sf_crs}\n\nРабота с пространственной привязкой данных в R состоит в основном из четырех операций:\n\n-   чтение информации о системе координат\n-   создание информации о системе координат\n-   замена информации о системе координат\n-   изменение системы координат (проецирование)\n\nПервые три операции (чтение, создание, замена) осуществляются функцией `st_crs()`. Чтобы прочитать информацию о проекции, достаточно передать в качестве параметра объект типа `sf`:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nst_crs(countries)    # Координатная система\n## Coordinate Reference System:\n##   User input: WGS 84 \n##   wkt:\n## GEOGCRS[\"WGS 84\",\n##     ENSEMBLE[\"World Geodetic System 1984 ensemble\",\n##         MEMBER[\"World Geodetic System 1984 (Transit)\"],\n##         MEMBER[\"World Geodetic System 1984 (G730)\"],\n##         MEMBER[\"World Geodetic System 1984 (G873)\"],\n##         MEMBER[\"World Geodetic System 1984 (G1150)\"],\n##         MEMBER[\"World Geodetic System 1984 (G1674)\"],\n##         MEMBER[\"World Geodetic System 1984 (G1762)\"],\n##         MEMBER[\"World Geodetic System 1984 (G2139)\"],\n##         ELLIPSOID[\"WGS 84\",6378137,298.257223563,\n##             LENGTHUNIT[\"metre\",1]],\n##         ENSEMBLEACCURACY[2.0]],\n##     PRIMEM[\"Greenwich\",0,\n##         ANGLEUNIT[\"degree\",0.0174532925199433]],\n##     CS[ellipsoidal,2],\n##         AXIS[\"geodetic latitude (Lat)\",north,\n##             ORDER[1],\n##             ANGLEUNIT[\"degree\",0.0174532925199433]],\n##         AXIS[\"geodetic longitude (Lon)\",east,\n##             ORDER[2],\n##             ANGLEUNIT[\"degree\",0.0174532925199433]],\n##     USAGE[\n##         SCOPE[\"Horizontal component of 3D system.\"],\n##         AREA[\"World.\"],\n##         BBOX[-90,-180,90,180]],\n##     ID[\"EPSG\",4326]]\n```\n:::\n\n\nЭта же функция позволяет создать новую координатную систему, путем передачи ей кода *EPSG* или строки *PROJ.4*:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nst_crs(3857) # Проекция Меркатора для карт мира\n## Coordinate Reference System:\n##   User input: EPSG:3857 \n##   wkt:\n## PROJCRS[\"WGS 84 / Pseudo-Mercator\",\n##     BASEGEOGCRS[\"WGS 84\",\n##         ENSEMBLE[\"World Geodetic System 1984 ensemble\",\n##             MEMBER[\"World Geodetic System 1984 (Transit)\"],\n##             MEMBER[\"World Geodetic System 1984 (G730)\"],\n##             MEMBER[\"World Geodetic System 1984 (G873)\"],\n##             MEMBER[\"World Geodetic System 1984 (G1150)\"],\n##             MEMBER[\"World Geodetic System 1984 (G1674)\"],\n##             MEMBER[\"World Geodetic System 1984 (G1762)\"],\n##             MEMBER[\"World Geodetic System 1984 (G2139)\"],\n##             ELLIPSOID[\"WGS 84\",6378137,298.257223563,\n##                 LENGTHUNIT[\"metre\",1]],\n##             ENSEMBLEACCURACY[2.0]],\n##         PRIMEM[\"Greenwich\",0,\n##             ANGLEUNIT[\"degree\",0.0174532925199433]],\n##         ID[\"EPSG\",4326]],\n##     CONVERSION[\"Popular Visualisation Pseudo-Mercator\",\n##         METHOD[\"Popular Visualisation Pseudo Mercator\",\n##             ID[\"EPSG\",1024]],\n##         PARAMETER[\"Latitude of natural origin\",0,\n##             ANGLEUNIT[\"degree\",0.0174532925199433],\n##             ID[\"EPSG\",8801]],\n##         PARAMETER[\"Longitude of natural origin\",0,\n##             ANGLEUNIT[\"degree\",0.0174532925199433],\n##             ID[\"EPSG\",8802]],\n##         PARAMETER[\"False easting\",0,\n##             LENGTHUNIT[\"metre\",1],\n##             ID[\"EPSG\",8806]],\n##         PARAMETER[\"False northing\",0,\n##             LENGTHUNIT[\"metre\",1],\n##             ID[\"EPSG\",8807]]],\n##     CS[Cartesian,2],\n##         AXIS[\"easting (X)\",east,\n##             ORDER[1],\n##             LENGTHUNIT[\"metre\",1]],\n##         AXIS[\"northing (Y)\",north,\n##             ORDER[2],\n##             LENGTHUNIT[\"metre\",1]],\n##     USAGE[\n##         SCOPE[\"Web mapping and visualisation.\"],\n##         AREA[\"World between 85.06°S and 85.06°N.\"],\n##         BBOX[-85.06,-180,85.06,180]],\n##     ID[\"EPSG\",3857]]\nst_crs('+proj=robin') # Проекция Робинсона для карт мира\n## Coordinate Reference System:\n##   User input: +proj=robin \n##   wkt:\n## PROJCRS[\"unknown\",\n##     BASEGEOGCRS[\"unknown\",\n##         DATUM[\"World Geodetic System 1984\",\n##             ELLIPSOID[\"WGS 84\",6378137,298.257223563,\n##                 LENGTHUNIT[\"metre\",1]],\n##             ID[\"EPSG\",6326]],\n##         PRIMEM[\"Greenwich\",0,\n##             ANGLEUNIT[\"degree\",0.0174532925199433],\n##             ID[\"EPSG\",8901]]],\n##     CONVERSION[\"unknown\",\n##         METHOD[\"Robinson\"],\n##         PARAMETER[\"Longitude of natural origin\",0,\n##             ANGLEUNIT[\"degree\",0.0174532925199433],\n##             ID[\"EPSG\",8802]],\n##         PARAMETER[\"False easting\",0,\n##             LENGTHUNIT[\"metre\",1],\n##             ID[\"EPSG\",8806]],\n##         PARAMETER[\"False northing\",0,\n##             LENGTHUNIT[\"metre\",1],\n##             ID[\"EPSG\",8807]]],\n##     CS[Cartesian,2],\n##         AXIS[\"(E)\",east,\n##             ORDER[1],\n##             LENGTHUNIT[\"metre\",1,\n##                 ID[\"EPSG\",9001]]],\n##         AXIS[\"(N)\",north,\n##             ORDER[2],\n##             LENGTHUNIT[\"metre\",1,\n##                 ID[\"EPSG\",9001]]]]\n\n# Проекция UTM, зона 37.\nst_crs('+proj=utm +zone=37 +datum=WGS84 +units=m')\n## Coordinate Reference System:\n##   User input: +proj=utm +zone=37 +datum=WGS84 +units=m \n##   wkt:\n## PROJCRS[\"unknown\",\n##     BASEGEOGCRS[\"unknown\",\n##         DATUM[\"World Geodetic System 1984\",\n##             ELLIPSOID[\"WGS 84\",6378137,298.257223563,\n##                 LENGTHUNIT[\"metre\",1]],\n##             ID[\"EPSG\",6326]],\n##         PRIMEM[\"Greenwich\",0,\n##             ANGLEUNIT[\"degree\",0.0174532925199433],\n##             ID[\"EPSG\",8901]]],\n##     CONVERSION[\"UTM zone 37N\",\n##         METHOD[\"Transverse Mercator\",\n##             ID[\"EPSG\",9807]],\n##         PARAMETER[\"Latitude of natural origin\",0,\n##             ANGLEUNIT[\"degree\",0.0174532925199433],\n##             ID[\"EPSG\",8801]],\n##         PARAMETER[\"Longitude of natural origin\",39,\n##             ANGLEUNIT[\"degree\",0.0174532925199433],\n##             ID[\"EPSG\",8802]],\n##         PARAMETER[\"Scale factor at natural origin\",0.9996,\n##             SCALEUNIT[\"unity\",1],\n##             ID[\"EPSG\",8805]],\n##         PARAMETER[\"False easting\",500000,\n##             LENGTHUNIT[\"metre\",1],\n##             ID[\"EPSG\",8806]],\n##         PARAMETER[\"False northing\",0,\n##             LENGTHUNIT[\"metre\",1],\n##             ID[\"EPSG\",8807]],\n##         ID[\"EPSG\",16037]],\n##     CS[Cartesian,2],\n##         AXIS[\"(E)\",east,\n##             ORDER[1],\n##             LENGTHUNIT[\"metre\",1,\n##                 ID[\"EPSG\",9001]]],\n##         AXIS[\"(N)\",north,\n##             ORDER[2],\n##             LENGTHUNIT[\"metre\",1,\n##                 ID[\"EPSG\",9001]]]]\n```\n:::\n\n\nЗамена координатной системы требуется в тех случаях, когда слой не имеет пространственной привязки, или же она задана некорректно. В этом случае необходимо вызвать для слоя функцию `st_crs()` и перезаписать результат.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nst_crs(countries) = NA\nst_crs(countries) \n## Coordinate Reference System: NA\n\nst_crs(countries) = st_crs(4326)\nst_crs(countries)\n## Coordinate Reference System:\n##   User input: EPSG:4326 \n##   wkt:\n## GEOGCRS[\"WGS 84\",\n##     ENSEMBLE[\"World Geodetic System 1984 ensemble\",\n##         MEMBER[\"World Geodetic System 1984 (Transit)\"],\n##         MEMBER[\"World Geodetic System 1984 (G730)\"],\n##         MEMBER[\"World Geodetic System 1984 (G873)\"],\n##         MEMBER[\"World Geodetic System 1984 (G1150)\"],\n##         MEMBER[\"World Geodetic System 1984 (G1674)\"],\n##         MEMBER[\"World Geodetic System 1984 (G1762)\"],\n##         MEMBER[\"World Geodetic System 1984 (G2139)\"],\n##         ELLIPSOID[\"WGS 84\",6378137,298.257223563,\n##             LENGTHUNIT[\"metre\",1]],\n##         ENSEMBLEACCURACY[2.0]],\n##     PRIMEM[\"Greenwich\",0,\n##         ANGLEUNIT[\"degree\",0.0174532925199433]],\n##     CS[ellipsoidal,2],\n##         AXIS[\"geodetic latitude (Lat)\",north,\n##             ORDER[1],\n##             ANGLEUNIT[\"degree\",0.0174532925199433]],\n##         AXIS[\"geodetic longitude (Lon)\",east,\n##             ORDER[2],\n##             ANGLEUNIT[\"degree\",0.0174532925199433]],\n##     USAGE[\n##         SCOPE[\"Horizontal component of 3D system.\"],\n##         AREA[\"World.\"],\n##         BBOX[-90,-180,90,180]],\n##     ID[\"EPSG\",4326]]\n```\n:::\n\n\n> **Внимание**: замена координатной системы не осуществляет перепроецирования данных и не меняет координаты точек. Она лишь влияет на то, как эти координаты будут интерпретироваться. Если вместо проецирования выполнить замену информации о координатной системе, данные будут позиционироваться в неправильном месте.\n\nДля проецирования данных в другую систему координат следует использовать функцию `st_tranform(x, crs)`. Данная функция принимает в качестве параметров класс объектов *sf* и координатную систему, в которую необходимо проецировать данные.\n\n\n::: {.cell crop='true'}\n\n```{.r .cell-code}\n# Проекция Меркатора\ncountries_merc = st_transform(countries, 3857)\npar(mar = c(2,16,2,16))\nplot(st_geometry(countries_merc), \n     col = 'lightgray',\n     lwd = 0.5,\n     graticule = TRUE, \n     axes = TRUE)\n```\n\n::: {.cell-output-display}\n![](09-SpatialData_files/figure-html/unnamed-chunk-80-1.png){width=100%}\n:::\n:::\n\n::: {.cell crop='true'}\n\n```{.r .cell-code}\n# Проекция Мольвейде (используем dplyr)\ncountries_moll = countries |> st_transform('+proj=moll')\nplot(st_geometry(countries_moll), \n     col = 'lightgray',\n     lwd = 0.5,\n     graticule = TRUE, \n     axes = TRUE)\n```\n\n::: {.cell-output-display}\n![](09-SpatialData_files/figure-html/unnamed-chunk-81-1.png){width=100%}\n:::\n:::\n\n::: {.cell crop='true'}\n\n```{.r .cell-code}\n# Зарубежная Европа в Конической равнопромежуточной проекции. \n# Задаем только необходимые параметры проекции\ncountries_eqdc = countries |> \n  filter(continent == 'Europe' & sovereignt != 'Russia') |> \n  st_transform('+proj=eqdc +lon_0=10 +lat_1=30 +lat_2=60 +datum=WGS84 +units=m')\n\nplot(st_geometry(countries_eqdc), \n     col = 'lightgray',\n     lwd = 0.5,\n     graticule = TRUE, \n     axes = TRUE)\n```\n\n::: {.cell-output-display}\n![](09-SpatialData_files/figure-html/unnamed-chunk-82-1.png){width=100%}\n:::\n:::\n\n\nРабота с проекцией растровых данных также предполагает четыре возможных процедуры: чтение, создание, замена и проецирование:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nst_crs(dem) # читаем систему координат\n## Coordinate Reference System:\n##   User input: WGS 84 \n##   wkt:\n## GEOGCRS[\"WGS 84\",\n##     ENSEMBLE[\"World Geodetic System 1984 ensemble\",\n##         MEMBER[\"World Geodetic System 1984 (Transit)\"],\n##         MEMBER[\"World Geodetic System 1984 (G730)\"],\n##         MEMBER[\"World Geodetic System 1984 (G873)\"],\n##         MEMBER[\"World Geodetic System 1984 (G1150)\"],\n##         MEMBER[\"World Geodetic System 1984 (G1674)\"],\n##         MEMBER[\"World Geodetic System 1984 (G1762)\"],\n##         MEMBER[\"World Geodetic System 1984 (G2139)\"],\n##         ELLIPSOID[\"WGS 84\",6378137,298.257223563,\n##             LENGTHUNIT[\"metre\",1]],\n##         ENSEMBLEACCURACY[2.0]],\n##     PRIMEM[\"Greenwich\",0,\n##         ANGLEUNIT[\"degree\",0.0174532925199433]],\n##     CS[ellipsoidal,2],\n##         AXIS[\"geodetic latitude (Lat)\",north,\n##             ORDER[1],\n##             ANGLEUNIT[\"degree\",0.0174532925199433]],\n##         AXIS[\"geodetic longitude (Lon)\",east,\n##             ORDER[2],\n##             ANGLEUNIT[\"degree\",0.0174532925199433]],\n##     USAGE[\n##         SCOPE[\"Horizontal component of 3D system.\"],\n##         AREA[\"World.\"],\n##         BBOX[-90,-180,90,180]],\n##     ID[\"EPSG\",4326]]\nst_crs(dem) = NA # очищаем систему координат\nst_crs(dem)\n## Coordinate Reference System: NA\nst_crs(dem) = st_crs(4326) # создаем систему координат\nst_crs(dem)\n## Coordinate Reference System:\n##   User input: EPSG:4326 \n##   wkt:\n## GEOGCRS[\"WGS 84\",\n##     ENSEMBLE[\"World Geodetic System 1984 ensemble\",\n##         MEMBER[\"World Geodetic System 1984 (Transit)\"],\n##         MEMBER[\"World Geodetic System 1984 (G730)\"],\n##         MEMBER[\"World Geodetic System 1984 (G873)\"],\n##         MEMBER[\"World Geodetic System 1984 (G1150)\"],\n##         MEMBER[\"World Geodetic System 1984 (G1674)\"],\n##         MEMBER[\"World Geodetic System 1984 (G1762)\"],\n##         MEMBER[\"World Geodetic System 1984 (G2139)\"],\n##         ELLIPSOID[\"WGS 84\",6378137,298.257223563,\n##             LENGTHUNIT[\"metre\",1]],\n##         ENSEMBLEACCURACY[2.0]],\n##     PRIMEM[\"Greenwich\",0,\n##         ANGLEUNIT[\"degree\",0.0174532925199433]],\n##     CS[ellipsoidal,2],\n##         AXIS[\"geodetic latitude (Lat)\",north,\n##             ORDER[1],\n##             ANGLEUNIT[\"degree\",0.0174532925199433]],\n##         AXIS[\"geodetic longitude (Lon)\",east,\n##             ORDER[2],\n##             ANGLEUNIT[\"degree\",0.0174532925199433]],\n##     USAGE[\n##         SCOPE[\"Horizontal component of 3D system.\"],\n##         AREA[\"World.\"],\n##         BBOX[-90,-180,90,180]],\n##     ID[\"EPSG\",4326]]\n```\n:::\n\n\nДля проецирования растра в новую систему координат необходимо использовать функцию `st_warp()` Приведем несколько примеров проецирования.\n\nПроекция *Меркатора*:\n\n\n::: {.cell crop='true'}\n\n```{.r .cell-code}\nimg_merc = st_warp(img, crs = 3857)\n\nplot(st_rgb(img_merc), main = NULL, reset = FALSE)\nplot(st_geometry(countries_merc), \n     border = rgb(1,1,1,0.5), lwd = 0.25, add = TRUE)\n```\n\n::: {.cell-output-display}\n![](09-SpatialData_files/figure-html/unnamed-chunk-84-1.png){width=100%}\n:::\n:::\n\n\nПроекция *Мольвейде*:\n\n\n::: {.cell crop='true'}\n\n```{.r .cell-code}\nimg_moll = st_warp(img, crs = st_crs('+proj=moll'), use_gdal = TRUE)\nplot(st_rgb(img_moll, probs = c(0.01, 0.99),\n       stretch = \"percent\"), main = NULL, reset = FALSE)\nplot(st_geometry(countries_moll), \n     border = rgb(1,1,1,0.5), lwd = 0.5, add = TRUE)\n```\n\n::: {.cell-output-display}\n![](09-SpatialData_files/figure-html/unnamed-chunk-85-1.png){width=100%}\n:::\n:::\n\n\nПроекция *коническая равнопромежуточная*:\n\n\n::: {.cell crop='true'}\n\n```{.r .cell-code}\nprj = '+proj=eqdc +lon_0=10 +lat_1=30 +lat_2=60 +datum=WGS84 +units=m'\n\nimg_eqdc = st_warp(\n  img, \n  crs = st_crs(prj)\n)\n\nimg_eqdc_euro = img_eqdc[st_bbox(countries_eqdc)]\n\nplot(st_rgb(img_eqdc_euro), main = NULL, reset = FALSE)\nplot(st_geometry(countries_eqdc), \n     border = rgb(1,1,1,0.5), lwd = 0.5, add = TRUE)\n```\n\n::: {.cell-output-display}\n![](09-SpatialData_files/figure-html/unnamed-chunk-86-1.png){width=50%}\n:::\n:::\n\n\nБолее подробно вопросы выбора проекций и построения сеток координат рассматриваются в следующей главе.\n\n## Краткий обзор {#temporal_review}\n\nДля просмотра презентации щелкните на ней один раз левой кнопкой мыши и листайте, используя кнопки на клавиатуре:\n\n\n::: {.cell}\n<iframe src=\"https://tsamsonov.github.io/r-geo-course-slides/09_SpatialData.html#1\" width=\"100%\" height=\"390px\" data-external=\"1\"></iframe>\n:::\n\n\n> Презентацию можно открыть в отдельном окне или вкладке браузере. Для этого щелкните по ней правой кнопкой мыши и выберите соответствующую команду.\n\n## Контрольные вопросы и упражнения {#questions_tasks_spatial}\n\n### Вопросы {#questions_spatial}\n\n1.  Что такое пространственные данные и какие модели пространственных данных существуют?\n2.  Назовите номер стандарта ISO, в котором описана модель *Simple Features*.\n3.  Перечислите основные принципы представления объектов в рамках стандарта *Simple Features*.\n4.  Какие размерности координат допустимы в объектах *Simple Features*?\n5.  Перечислите основные 7 типов геометрий. Сколько всего их описано в стандарте *Simple Features*?\n6.  Как называются основные два формата представления объектов *Simple Features*?\n7.  Перечислите основные компоненты пространственной привязки.\n8.  Перечислите основные форматы описания пространственной привязки.\n9.  Дайте расшифровку основных параметров строки *PROJ.4*.\n10. Какой номер *EPSG* имеет географическая система координат *WGS84*?\n11. В чем отличие трансформирования координат и проецирования?\n12. Какие три программных библиотеки составляют основу функциональности пакета **sf**? Каково их назначение?\n13. В чем отличие объектов типа **sp** от **sf**?\n14. Что означает префикс `st_`, используемый в названиях функций пакета **sf**?\n15. Какая функция используется для чтения данных средствами пакета **sf**?\n16. Перечислите три класса, слагающих иерархию представления пространственных объектов, реализуемую пакетом **sf**.\n17. Какой тип данных имеет колонка с геометрией объекта **sf**?\n18. Какая функция позволяет извлечь геометрическую колонку из объекта **sf**?\n19. С помощью какой структуры данных фактически реализован класс объектов **sfg**?\n20. Сколько карт будет построено функцией `plot()` применительно к объекту **sf**?\n21. Как с помощью функции `plot()` нарисовать только геометрию объектов, не отображая атрибутивные характеристики?\n22. Какой параметр функции `plot()` отвечает за отображение/не отображение градусной сетки координат?\n23. Каким способом можно узнать и задать систему координат объекта **sf**?\n24. Какая функция позволяет осуществить проецирование данных?\n25. Можно ли применять к объектам типа **sf** стандартные манипуляции **dplyr**?\n26. Что произойдет с геометрией пространственных объектов при выполнении агрегирования данных по группам значений заданных атрибутов?\n27. Перечислите функции, с помощью которых создаются объекты типа **sfg**, и структуры данных с координатами, которые должны быть поданы на вход этих функций.\n28. Назовите три правила, которым подчиняется формат представления координат вершин *полигональных* объектов.\n29. Может ли обычный полигон **sf** содержать дырку, или же для этого требуется создание мультиполигона?\n30. Как можно быстро собрать слой точечных объектов по их координатам, не собирая объекты вручную?\n31. Какая функция позволяет осуществлять преобразование типа геометрии **sf**?\n32. Перечислите требования, которым должно удовлетворять множество линейных объектов для того, чтобы к нему была применима операция полигонизации?\n33. Назовите функции **sf**, реализующие операцию добавления вершин в точках пересечения линий и операцию полигонизации линий.\n34. Перечислите названия функций **sf**, позволяющих получать ограничивающий прямоугольник, периметр, площадь, центроид, характерную точку и координаты объекта.\n35. С помощью какой функции осуществляется запись (экспорт) **sf** в файлы пространственных данных?\n36. Назовите основные параметры, определяющие геометрию растра.\n37. Какие пакеты отвечают за поддержку растровых данных в **R**?\n38. Как можно прочитать одноканальный и многоканальный растры в **R**?\n39. Какие функции можно использовать для визуализации одноканальных и многоканальных растров?\n40. Можно ли совмещать растровые и векторные слои на одном изображении? Если да, то как эта возможность реализуется?\n41. Каким образом можно узнать и задать пространственную привязку растрового набора данных?\n42. Какая функция отвечает за проецирование растровых данных? Перечислите ее параметры и их назначение.\n43. Объясните систему индексирования объектов типа **stars**.\n44. Как вычислить новую переменную объекта типа **stars**?\n45. Как осуществить экспорт растра в файл?\n\n### Упражнения {#tasks_spatial}\n\n1.  Преобразуйте точки землетрясений из набора данных *quakes* в пространственные объекты и отобразите их сначала средствами стандартной графической подсистемы, а затем на интерактивной карте средствами пакета **mapview**. Передайте магнитуду землетрясения в параметр `zcol` функции `mapview()`, чтобы дифференцировать точки цветом по этому параметру.\n\n2.  Таблица *storms* из пакета **dplyr** содержит данные трекинга тропических циклонов c 1975 по 2015 год. Выберите любой циклон и постройте для него линию трека прохождения и точки прохождения. Отобразите эти данные средствами стандартной графической подсистемы, а затем на интерактивной карте средствами **mapview**. Напишите программу таким образом, чтобы можно было выбирать имя циклона и программа отображала его трек на интерактивной карте.\n\n3.  Скачайте [базу данных](https://github.com/tsamsonov/r-geo-course/blob/master/data/Satino.gpkg) и [цифровую модель рельефа](https://github.com/tsamsonov/r-geo-course/blob/master/data/Satino_DEM.zip) на территорию Сатинского полигона МГУ. Изучите содержимое базы данных и постройте на основе этих данных общегеографическую карту средствами стандартной графической подсистемы.\n\n|                                                                                                                                                                                                                    |\n|--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|\n| *Самсонов Т.Е.* **Визуализация и анализ географических данных на языке R.** М.: Географический факультет МГУ, 2023. DOI: [10.5281/zenodo.901911](https://doi.org/10.5281/zenodo.901911) |\n",
    "supporting": [
      "09-SpatialData_files"
    ],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}