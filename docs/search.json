[
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Визуализация и анализ географических данных на языке R",
    "section": "",
    "text": "Введение\nДобро пожаловать в курс “Визуализация и анализ географических данных на языке R”! В данном курсе мы освоим азы программирования на языке R, а затем научимся использовать его для решения географических задач. Никаких предварительных знаний и навыков программирования не требуется.",
    "crumbs": [
      "Введение"
    ]
  },
  {
    "objectID": "index.html#программное-обеспечение",
    "href": "index.html#программное-обеспечение",
    "title": "Визуализация и анализ географических данных на языке R",
    "section": "Программное обеспечение",
    "text": "Программное обеспечение\nДля успешного прохождения курса на вашем компьютере должно быть установлено следующее программное обеспечение:\n\nЯзык R\nСреда разработки RStudio\n\nВыбирайте инсталлятор, соответствующий вашей операционной системе. Обратите внимание на то, что RStudio не будет работать, пока вы не установите базовые библиотеки языка R. Поэтому обе вышеуказанные компоненты ПО обязательны для установки.",
    "crumbs": [
      "Введение"
    ]
  },
  {
    "objectID": "index.html#установка-и-подключение-пакетов",
    "href": "index.html#установка-и-подключение-пакетов",
    "title": "Визуализация и анализ географических данных на языке R",
    "section": "Установка и подключение пакетов",
    "text": "Установка и подключение пакетов\nСуществует множество дополнительных пакетов R практически на все случаи жизни (вы тоже можете написать свой). Как и дистрибутив R, они доступны через CRAN (Comprehensive R Archive Network). Одним из таких пакетов является, например, пакет writexl, позволяющий записывать файлы в форматах Microsoft Excel.\nНаиболее часто используются два способа установки пакетов в RStudio.\nВо-первых, вы можете сделать это в графическом интерфесе, нажав кнопку Install на панели Packages (по умолчанию эта панель расположена в нижней правой четверти окна программы). В появившемся окне введите название пакета и нажмите Install:\n\n\n\n\n\nУстановка пакета\n\n\n\n\nВо-вторых, вы можете вызвать из консоли команду install.packages(), передав ей в качестве параметра название пакета, заключенное в кавычки:\n\ninstall.packages(\"writexl\")\n\n\nНикогда не включайте команду install.packages() в тело скрипта. Это приведет к тому, что каждый раз при запуске программы среда RStudio будет пытаться заново установить пакет, который уже установлен. Запускайте эту функцию только из консоли.\n\nПодключение пакета осуществляется с помощью функции library(), при этом название пакета можно в кавычки не заключать:\n\nlibrary(writexl)",
    "crumbs": [
      "Введение"
    ]
  },
  {
    "objectID": "index.html#выполнение-программного-кода",
    "href": "index.html#выполнение-программного-кода",
    "title": "Визуализация и анализ географических данных на языке R",
    "section": "Выполнение программного кода",
    "text": "Выполнение программного кода\nЕсли в качестве среды разработки вы используете RStudio, то существует несколько способов выполнения исходного кода:\n\nВыполнить одну строку: поставить курсор в любую строку и нажать над редактором кода кнопку Run или сочетание клавиш Ctrl+Enter (Cmd+Enter для OS X).\nВыполнить несколько строк: выделить необходимые строки и нажать над редактором кода кнопку Run или сочетание клавиш Ctrl+Enter (Cmd+Enter для OS X).\nВыполнить весь код можно сразу тремя способами:\n\nВыделить весь текст и нажать над редактором кода кнопку Run или сочетание клавиш Ctrl+Enter (Cmd+Enter для OS X)\nНажать клавиатурное сочетание Ctrl+Alt+Enter (Cmd+Alt+Enter для OS X)\nНажать в правом верхнем углу редактора кода кнопку Source\n\n\n\nКоманды Source и Ctrl+Alt+Enter могут не сработать, если у вас не установлена рабочая директория, или если в пути к рабочей директории содержатся кириллические символы (не актуально для Windows 10+, macOS и Linux, которые являются системами, основанными на кодировке Unicode).\n\nСуществует также ряд дополнительных опций выполнения кода, которые вы можете найти в меню Code &gt; Run Region.\n\nВыполняя код построчно, делайте это последовательно, начиная с первой строки программы. Одна из самых распространенных ошибок новичков заключается в попытке выполнить некую строку, не выполнив предыдущий код. Нет никаких гарантий, что что-то получится, если открыть файл, поставить курсор в произвольную строку посередине программы и попытаться выполнить ее. Возможно, вам и повезет — если эта строка никак не зависит от предыдущего кода. Однако в реальных программах такие строки составляют лишь небольшую долю от общего объема. Как правило, в них происходит инициализация новых переменных стартовыми значениями.",
    "crumbs": [
      "Введение"
    ]
  },
  {
    "objectID": "index.html#установка-рабочей-директории",
    "href": "index.html#установка-рабочей-директории",
    "title": "Визуализация и анализ географических данных на языке R",
    "section": "Установка рабочей директории",
    "text": "Установка рабочей директории\nВы можете открывать и сохранять любые поддерживаемые файлы в R, указывая полный системный путь к файлу. Например, так может выглядеть открытие и сохранение таблицы в формате CSV на компьютере Mac:\n\nd = read.csv(\"/Volumes/Data/GitHub/r-geo-course/data/oxr_vod.csv\")\nwrite.csv(d, \"/Volumes/Data/GitHub/r-geo-course/data/oxr_vod_copy.csv\")\n\nОднако, если вам требуется открыть или сохранить несколько файлов (и не только данных, но и графиков, карт и т.п.), программа будет выглядеть громоздко. К тому же, прописывать каждый раз полный путь достаточно утомительно и неприятно (даже путем копирования и вставки), а главное — может привести к ошибкам.\nЧтобы облегчить работу с файлами, в R существует понятие домашней директории. Домашняя директория задается для текущей сессии R с помощью функции setwd(). После установки домашней директории R будет полагать, что все открываемые и сохраняемые файлы должны находиться в ней:\n\nsetwd(\"/Volumes/Data/GitHub/r-geo-course/data\")\n\nread.csv(\"oxr_vod.csv\")\nwrite.csv(d, \"oxr_vod_copy.csv\")\n\nКак видно, мы добавили дополнительную строчку кода, но сэкономили на длине двух других строк. При увеличении количества обращений к файлам польза домашней директории будет возрастать. При этом вы можете открывать и сохранять файлы в поддиректориях, наддиректориях и соседних директориях, используя синтаксис, стандартный для большинства операционных систем:\n\n# сохранить файл в поддиректорию data\nwrite.csv(d, \"data/oxr_vod_copy.csv\")\n\n# сохранить файл в наддиректорию по отношению к текущей директории\nwrite.csv(d, \"../oxr_vod_copy.csv\")\n\n# сохранить файл в директорию data, соседнюю по отношению к текущей директории\nwrite.csv(d, \"../data/oxr_vod_copy.csv\")\n\n\nЕсли вы перенесли код и данные с другого компьютера (возможно, вы получили их от своего коллеги или скачали с репозитория данного пособия), необходимо заменить путь, указанный в функции setwd() на путь к каталогу, в который вы положили данные.\n\n\nРабочая директория и местоположение скрипта могут не совпадать. Вы можете хранить их в разных местах. Однако рекомендуется держать их вместе, что облегчит передачу вашей программы вместе с данными другим пользователям.\n\nК сожалению, не существует надежного программного способа сказать среде выполнения R, что в качестве домашей директории следует использовать директорию в которой лежит сам скрипт (что, вообще говоря, было бы крайне удобно). Возможно, в будущем разработчики языка добавят такую полезную функцию. Однако, если для работы с R вы пользуетесь средой RStudio, задача может быть решена путем использования проектов. Подробнее читайте здесь.",
    "crumbs": [
      "Введение"
    ]
  },
  {
    "objectID": "index.html#диагностические-функции",
    "href": "index.html#диагностические-функции",
    "title": "Визуализация и анализ географических данных на языке R",
    "section": "Диагностические функции",
    "text": "Диагностические функции\nВ R существует ряд диагностических функций, которые позволяют узнавать техническую информацию об объектах и переменных. Эти функции полезны, когда необходимо понять, какого типа, размера и содержания данные хранятся в той или иной переменной. Нижеприведенный список функций не являются исчерпывающим, но охватывает часто употребляемые функции:\n\n\n\n\n\n\n\nФункция\nНазначение\n\n\n\n\nclass()\nКласс (тип данных или структура данных) объекта\n\n\nattr()\nАтрибуты объекта\n\n\nstr()\nКомпактное представление внутренней структуры объекта.\n\n\nnames()\nНазвания элементов объекта\n\n\ncolnames()\nНазвания колонок фрейма данных или матрицы\n\n\nrownames()\nНазвания строк фрейма данных или матрицы\n\n\nmode()\nРежим хранения объекта.\n\n\nlength()\nРазмер (длина) объекта.\n\n\ndim()\nИзмерение объекта.\n\n\n\nПомимо этого, часто используются следующие функции, имеющие отношение не к конкретным объектам, а к параметрам работы текущей сессии:\n\n\n\nФункция\nНазначение\n\n\n\n\nsessionInfo()\nИнформация о текущей сессии R и подключенных пакетах.\n\n\ngc()\nИнформация об объеме памяти, занимаемой текущей сессией R (находящейся под управлением сборщика мусора).\n\n\noptions()\nПолучение и установка параметров среды.\n\n\ngetwd()\nПолучение текущей рабочей директории\n\n\nsetwd()\nУстановка текущей рабочей директории\n\n\npar()\nПолучение и установка графических параметров",
    "crumbs": [
      "Введение"
    ]
  },
  {
    "objectID": "index.html#получение-справки",
    "href": "index.html#получение-справки",
    "title": "Визуализация и анализ географических данных на языке R",
    "section": "Получение справки",
    "text": "Получение справки\nПравильно оформленная функция R содержит документированное описание ее параметров и правил использования. Справку можно получить несколькими способами:\n\nНайти интересующую вас функцию вручную на вкладке Packages, выбрав нужный пакет.\nВоспользоваться строкой поиска на вкладке Help.\nВвести знак вопроса и название функции в консоли (будет искать только среди подключенных в настоящий момент пакетов):\n\n\nlibrary(writexl)\n\n?write_xlsx # равносильно вызову функции help(write_xlsx)\n\n\n\n\n\n\nСправка по функции write_xlsx\n\n\n\n\n\nВвести двойной знак вопроса и название функции в консоли (будет искать по всем установленным пакетам, независимо от того, подключены ли они в настоящий момент). Например, вот так можно найти все варианты справочных материалов по функции aggregate:\n\n&gt; ??aggregate\n\n\n\n\n\nСправочные материалы по функциям aggregate из установленных пакетов\n\n\n\n\nВо многих пакетах есть также подробная документация с примерами использования функций в виде руководств и так называемых виньеток (vignettes), которые представляют из себя расширенные руководства (статьи) по использованию пакета. С документацией пакета можно ознакомиться, щелкнув на его названии на вкладке Packages и перейдя по ссылке User guides, package vignettes and other documentation:\n\n\n\n\n\nДокументация пакета sf",
    "crumbs": [
      "Введение"
    ]
  },
  {
    "objectID": "index.html#комментарии",
    "href": "index.html#комментарии",
    "title": "Визуализация и анализ географических данных на языке R",
    "section": "Комментарии",
    "text": "Комментарии\nКомментарии — это фрагменты текста программы, начинающиеся с символа #. Комментарии не воспринимаются как исполняемый код и служат для документирования программы. При выполнении программы содержимое комментария в зависимости от настроек среды может выводиться или не выводиться в консоль, однако их содержание никак не влияет на результаты выполнения программы.\n\nВсегда пишите комментарии, чтобы по прошествии времени можно было открыть файл и быстро восстановить в памяти логику программы и смысл отдельных операций. Комментарии особенно необходимы, если вашей программой будет пользоваться кто-то другой — без них будет трудно разобраться в программном коде.\n\nДействие комментария продолжается от символа # до конца строки. Соответственно, вы можете поставить данный символ в самом начале строки и тогда комментарий будет занимать всю строку. Комментарий также можно расположить справа от исполняемого кода, и тогда он будет занимать только часть строки.\n\nПрервать комментарий и написать справа от него исполняемый код нельзя\n\nПолнострочные комментарии часто используются для выделения разделов в программе и написания объемных пояснений. Часто в них вводят имитации разделительных линий с помощью символов дефиса (-) или подчеркивания (_), а заголовки набирают прописными буквами. Короткие комментарии справа от фрагментов кода обычно служат пояснением конкретных простых операций. Подобная логика употребления комментариев не является обязательной. Вы можете оформлять их на свое усмотрение. Главное, чтобы они выполняли свою основную функцию — пояснять смысл выполняемых действий. Например:\n\n# ОПЕРАЦИИ С ЧИСЛАМИ\n# ---------------------------\n# В данном разделе рассматриваются арифметические операции, такие как сложение, вычитание, деление, деление с остатком, взятие остатка и возведение в степень:\n\na = 3 + 2 # Сложение\nb = 4 ^ 8 # Возведение в степень\nc = b %% a # Взятие остатка\n\n# Деление\nd = c / a \n\n# Умножение\ne = d * b\n\nОднако, усердствовать с комментированием каждой мелочи в программе, разумеется, не стоит. Со временем у вас выработается взвешенный подход к документированию программ и понимание того, какие ее фрагменты требуют пояснения, а какие самоочевидны.\n\nДля быстрой вставки комментария, обозначающего новый раздел программы, воспользуйтесь командой меню Code &gt; Insert Section или клавиатурным сочетанием Ctrl+Shift+R (Cmd+Shift+R для OS X)",
    "crumbs": [
      "Введение"
    ]
  },
  {
    "objectID": "index.html#стандарт-оформления-кода-на-r",
    "href": "index.html#стандарт-оформления-кода-на-r",
    "title": "Визуализация и анализ географических данных на языке R",
    "section": "Стандарт оформления кода на R",
    "text": "Стандарт оформления кода на R\nОчень важно сразу же приучить себя грамотно, структурированно и красиво оформлять код на языке R. Это существенно облегчит чтение и понимание ваших программ не только вами, но и другими пользователями и разработчиками. Помимо вышеуказанных рекомендаций по написанию комментариев существует также определенное количество хорошо зарекомендовавших себя и широко используемых практик оформления кода. Эти практики есть в каждом языке программирования и их можно найти в литературе (и в Интернете) в виде негласных сводов правил (style guides).\nВ частности, одним из полезных для изучения является стандарт tidyverse, систематизированный Хэдли Уикхемом — одним из ведущих идеологов развития языка R и его библиотек.\n\nСтандарт оформления кода иногда также называют стилем программирования. Однако под стилем программирования традиционно понимают все же фундаментальный подход (парадигму) к построению программ: процедурный, функциональный, логический, объектно-ориентированный стиль и некоторые другие.\n\nК числу негласных правил оформления кода на R можно отнести следующие:\n\nПоследовательно используйте знак присвоения &lt;- или = на протяжении всей программы. Если вы начали использовать = – применяйте его на протяжении всей программы, не используя &lt;-.\n\n\nТрадиционный подход предполагает использование &lt;-, однако все больше программистов использует знак = в своих программах, что делает R более похожим на другие языки программирования. Помните, что использование = официально не рекомендуется, поскольку существует много старого кода на R, который может ошибочно выполняться в сочетании с кодом, использующим =. Но вы, скорее всего, с такими проблемами не столкнетесь. Так что выбор за вами!\n\n\nПосле запятой всегда ставьте пробел, перед запятой – нет:\n\n\n# Правильно:\na = c(1, 2, 3, 4)\nm = matrix(a, 2, 2)\n\n# Неправильно:\na = c(1,2,3,4)\na = c(1 ,2 ,3 ,4)\na = c(1 , 2 , 3 , 4)\nm = matrix(a,2,2)\nm = matrix(a ,2 ,2)\nm = matrix(a , 2 , 2)\n\n\nОтделяйте любые бинарные операторы (такие как =, +, -, &lt;-, *) пробелами с двух сторон:\n\n\na = sin(b + pi * 0.5) # правильно\na=sin(b+pi*0.5) # неправильно\n\n\nМежду названием функции и открывающей скобкой пробела быть не должно. То же самое касается обращения к элементам вектора, матрицы и т.п.:\n\n\n# Правильно:\nsin(b)\na[2]\n\n# Неправильно:\nsin (b)\na [2]\n\n\nВ то же время, при вызове команд управления выполнением программы (условные операторы и циклы) перед и после скобок пробел должен стоять:\n\n\n# Правильно:\nif (a &gt; 0) {\n  print(a)\n}\ni = 0\nwhile (i &lt; a) {\n  print(i)\n  i = i + 1\n}\n\n# Неправильно:\nif(a &gt; 0){\n  print(a)\n}\n\ni = 0\nwhile(i &lt; a){\n  print(i)\n  i = i + 1\n}",
    "crumbs": [
      "Введение"
    ]
  },
  {
    "objectID": "index.html#зарезервированные-слова",
    "href": "index.html#зарезервированные-слова",
    "title": "Визуализация и анализ географических данных на языке R",
    "section": "Зарезервированные слова",
    "text": "Зарезервированные слова\nВ R существует небольшое количество зарезервированных слов, которые нельзя использовать в качестве имен переменных, функций и проч. Список этих слов можно получить, набрав в консоли ?Reserved. К ним относятся:\n\n\n\n\n\n\n\nСлово\nНазначение\n\n\n\n\nif\nУсловный оператор ЕСЛИ\n\n\nelse\nУсловный оператор ИНАЧЕ\n\n\nrepeat\nЦикл без внешнего условия\n\n\nwhile\nЦикл “пока верно условие, повторять”\n\n\nfunction\nФункция\n\n\nfor\nЦикл “пройти по элементам последовательности”\n\n\nin\nОператор вхождения в множество\n\n\nnext\nПереход на новую итерацию цикла\n\n\nbreak\nПринудительный выход из цикла или условного оператора\n\n\nTRUE\nЛогическое значение ИСТИНА\n\n\nFALSE\nЛогическое значение ЛОЖЬ\n\n\nNULL\nПустое значение\n\n\nInf\nБесконечность\n\n\nNaN\nНечисловое значние\n\n\nNA\nОтсутствующее значение\n\n\nNA_integer_\nОтсутствующее целое число\n\n\nNA_real_\nОтсутствующее число с плавающей точкой\n\n\nNA_complex_\nОтсутствующее комплексное число\n\n\nNA_character_\nОтсутствующая строка",
    "crumbs": [
      "Введение"
    ]
  },
  {
    "objectID": "index.html#названия-переменных",
    "href": "index.html#названия-переменных",
    "title": "Визуализация и анализ географических данных на языке R",
    "section": "Названия переменных",
    "text": "Названия переменных\nВ качестве названий переменных нельзя использовать заразервированные слова, а также не рекомендуется использовать названия общеупотребительных (диагностических) функций и констант. Также не следует давать переменным названия, совпадающие с широко распространенными функциями – например, котороткими функциями из пакета base, такими как t(), с() и т.д., так как это может привести к путанице в программе и даже ошибкам выполнения кода. Каждый раз, создавая переменную, спрашивайте себя, не совпадает ли ее название с названием одной из используемых вами функций.",
    "crumbs": [
      "Введение"
    ]
  },
  {
    "objectID": "index.html#названия-специальных-символов",
    "href": "index.html#названия-специальных-символов",
    "title": "Визуализация и анализ географических данных на языке R",
    "section": "Названия специальных символов",
    "text": "Названия специальных символов\nВ R, как и во многих других языках программирования используются различные специальные символы. Их смысл и значение мы узнаем по ходу изучения языка, а пока что ознакомьтесь с ними, чтобы понимать как их произносить, когда они будут встречаться в программе.\n\n\n\nСимвол\nНазвание\n\n\n\n\n$\nдоллар\n\n\n#\nшарп (решетка)\n\n\n&\nамперсанд (и)\n\n\n/\nслеш (косая черта)\n\n\n\\\nобратный слеш (обратная косая черта)\n\n\n|\nпайп (вертикальная черта)\n\n\n^\nциркумфлекс (крышечка)\n\n\n@\nэт (собачка)\n\n\n~\nтильда\n\n\n''\nодинарные кавычки\n\n\n\"\"\nдвойные кавычки\n\n\n``\nобратные кавычки",
    "crumbs": [
      "Введение"
    ]
  },
  {
    "objectID": "index.html#управляющие-последовательности",
    "href": "index.html#управляющие-последовательности",
    "title": "Визуализация и анализ географических данных на языке R",
    "section": "Управляющие последовательности",
    "text": "Управляющие последовательности\nПри работе со строками вам может понадобиться знание так называемых управляющих последовательностей (escape-последовательностей). Под этим понимается совокупность подряд идущих символов, которая интерпретируется обрабатывающим механизмом как единое целое. Как правило, такие последовательности начинаются с хорошо узнаваемого символа, не являющегося буквенно-цифровым (см. предыдущий раздел)\nВ частности, последовательности, начинающиеся с символа обратной косой черты (\\) используются для управления выводом программы. Например, последовательность \\n приводит к переносу строки в том месте, где она расположена, а последовательность \\t позволит вставить символ табуляции. То есть, фраза \"Визуализация и анализ\\nгеографических данных на языке R\" будет выведена в две строки с переносом после слова \"анализ\":\n\ncat(\"Визуализация и анализ\\nгеографических данных на языке R\")\n\nВизуализация и анализ\nгеографических данных на языке R\n\n\nТакая возможность бывает полезна, когда вы хотите, например, вывести длинный заголовок графика в несколько строк, а система построения графиков не умеет расставлять переносы автоматически. Управляющие символы позволяют менять не только текстовый вывод. В частности, символ \\a, будучи отправленным в консоль, приведет в извлечению звука.\nПри этом вы можете столкнуться с ситуацией, когда необходимо подавить возможность управления выводом через символы в строке. Например, если последовательность символов является частью более длинной последовательности. Классический сюжет — пути к папкам в операционной системе Windows, наподобие d:\\aikido\\training. Вы хотите вывести на экран путь к каталогу с результатами ваших тренировок по айкидо, а вместо этого программа издаёт звук и вставляет посередине пути символ табуляции:\n\ncat(\"d:\\aikido\\training\")\n\nd:\u0007ikido    raining\n\n\nЧтобы исключить подобное безобразие, следует нежелательные последовательности экранировать. Экранирование обычно делается тем же специальным символом, с которого начинается сама управляющая последовательность. То есть, вы должны принудительно вставить еще один такой же символ:\n\ncat(\"d:\\\\aikido\\\\training\")\n\nd:\\aikido\\training\n\n\nОднако в данном конкретном случае проще заменить обратные слеши на прямые — Windows может работать с путями и таким образом:\n\ncat(\"d:/aikido/training\")\n\nd:/aikido/training\n\n\n\nВ UNIX-подобных операционных системах (Linux, macOS) такой проблемы нет, поскольку для формирования пути к каталогу можно использовать только прямую косую черту (/). С учетом того, что Windows допускает и такой способ задания путей, в данном контексте рекомендуется всегде использовать прямые, а не обратные косые черты.\n\nДополнительные сведения по управляющим последовательностям в R можно почерпнуть, если набрать в консоли ?Quotes:\n\n\n\n\n\nСправка по управляющим последовательностям в R",
    "crumbs": [
      "Введение"
    ]
  },
  {
    "objectID": "index.html#ссылка-на-пособие",
    "href": "index.html#ссылка-на-пособие",
    "title": "Визуализация и анализ географических данных на языке R",
    "section": "Ссылка на пособие",
    "text": "Ссылка на пособие\nЕсли этот курс лекций оказался полезным для вас, и вы хотите процитировать его с списке литературы вашей работы, то ссылку можно оформить по следующей форме:\n\n\n\nСамсонов Т.Е. Визуализация и анализ географических данных на языке R. М.: Географический факультет МГУ, 2024. DOI: 10.5281/zenodo.901911",
    "crumbs": [
      "Введение"
    ]
  },
  {
    "objectID": "01-Basics.html#data_types",
    "href": "01-Basics.html#data_types",
    "title": "1  Типы данных",
    "section": "1.1 Типы данных",
    "text": "1.1 Типы данных\nТип данных — это класс данных, характеризуемый членами класса и операциями, которые могут быть к ним применены1. С помощью типов данных мы можем представлять привычные нам сущности, такие как числа, строки и т.д. В языке R существует 5 базовых типов данных:\n\n\n\nНазвание\nТип данных\n\n\n\n\ncomplex\nкомплексные числа\n\n\ncharacter\nсимвольный (строки)\n\n\ninteger\nцелые числа\n\n\nlogical\nлогические (булевы)\n\n\nnumeric\nчисла с плавающей точкой\n\n\n\nПомимо этого есть тип Date, который позволяет работать с датами. Рассмотрим использование каждого из перечисленных типов.\n\n1.1.1 Числа\nЧисла — основной тип данных в R. К ним относятся числа c плавающей точкой и целые числа. В терминологии R такие данные называются интервальными, поскольку к ним применимо понятие интервала на числовой прямой. Целые числа относятся к дискретным интервальным, а числа с плавающей точкой — к непрерывным интервальным. Числа можно складывать, вычитать и умножать:\n\n2 + 3\n## [1] 5\n2 - 3\n## [1] -1\n2 * 3\n## [1] 6\n\nРазделителем целой и дробной части является точка, а не запятая:\n\n2.5 + 3.1\n## [1] 5.6\n\nСуществует также специальный оператор для возведения в степень. Для этого вы можете использовать или двойной знак умножения (**) или циркумфлекс (^):\n\n2 ^ 3\n## [1] 8\n2 ** 3\n## [1] 8\n\nРезультат деления по умолчанию имеет тип с плавающей точкой:\n\n5 / 3\n## [1] 1.666667\n5 / 2.5\n## [1] 2\n\nЕсли вы хотите чтобы деление производилось целочисленным образом (без дробной части) необходимо использовать оператор %/%:\n\n5 %/% 3\n## [1] 1\n\nОстаток от деления можно получить с помощью оператора %%:\n\n5 %% 3\n## [1] 2\n\nВышеприведенные арифметические операции являются бинарными, то есть требуют наличия двух чисел. Числа называются “операндами”. Отделять операнды от оператора пробелом или нет — дело вкуса. Однако рекомендуется все же отделять, так как это повышает читаемость кода. Следующие два выражения эквивалентны. Однако сравните простоту их восприятия:\n\n5%/%3\n## [1] 1\n\n\n5 %/% 3\n## [1] 1\n\nКак правило, в настоящих программах числа в явном виде встречаются лишь иногда. Вместо этого для их обозначения используют переменные. В вышеприведенных выражениях мы неоднократно использовали число 3. Теперь представьте, что вы хотите проверить, каковы будут результаты, если вместо 3 использовать 4. Вам придется заменить все тройки на четверки. Если их много, то это будет утомительная работа, и вы наверняка что-то пропустите. Конечно, можно использовать поиск с автозаменой, но что если тройки надо заменить не везде? Одно и то же число может выполнять разные функции в разных выражениях. Чтобы избежать подобных проблем, в программе вводят переменные и присваивают им значения. Оператор присваивания значения выглядит как =\n\na = 5\nb = 3\n\nЧтобы вывести значение переменной на экран, достаточно просто ввести его:\n\na\n## [1] 5\nb\n## [1] 3\n\nМы можем выполнить над переменными все те же операции что и над константами:\n\na + b\n## [1] 8\na - b\n## [1] 2\na / b\n## [1] 1.666667\na %/% b\n## [1] 1\na %% b\n## [1] 2\n\nЛегко меняем значение второй переменной с 3 на 4 и выполняем код заново.\n\nb = 4\na + b\n## [1] 9\na - b\n## [1] 1\na / b\n## [1] 1.25\na %/% b\n## [1] 1\na %% b\n## [1] 1\n\nНам пришлось изменить значение переменной только один раз в момент ее создания, все последующие операции остались неизменны, но их результаты обновились!\nНовую переменную можно создать на основе значений существующих переменных:\n\nc = b\nd = a+c\n\nПосмотрим, что получилось:\n\nc\n## [1] 4\nd\n## [1] 9\n\nВы можете комбинировать переменные и заданные явным образом константы:\n\ne = d + 2.5\ne\n## [1] 11.5\n\nПротивоположное по знаку число получается добавлением унарного оператора - перед константой или переменной:\n\nf = -2\nf\n## [1] -2\nf = -e\nf\n## [1] -11.5\n\nОперация взятия остатка от деления бывает полезной, например, когда мы хотим выяснить, является число четным или нет. Для этого достаточно взять остаток от деления на 2. Если число является четным, остаток будет равен нулю. В данном случае c равно 4, d равно 9:\n\nc %% 2\n## [1] 0\nd %% 2\n## [1] 1\n\n\n1.1.1.1 Числовые функции\nПрежде чем мы перейдем к рассмотрению прочих типов данных и структур данных нам необходимо познакомиться с функциями, поскольку они встречаются буквально на каждом шагу. Понятие функции идентично тому, к чему мы привыкли в математике. Например, функция может называться Z, и принимать 2 аргумента: x и y. В этом случае она записывается как Z(x,y). Чтобы получить значение функции, необходимо подставить некоторые значения вместо x и y в скобках. Нас даже может не интересовать, как фактически устроена функция внутри, но важно понимать, что именно она должна вычислять. С созданием функций мы познакомимся позднее.\nВажнейшие примеры функций — математические. Это функции взятия корня sqrt(x), модуля abs(x), округления round(x, digits), натурального логарифма log(x), тригонометрические функции sin(x), cos(x), tan(x), обратные к ним asin(y), acos(y), atan(y) и многие другие. Основные математические функции содержатся в пакете base, который по умолчанию доступен в среде R и не требует подключения.\nВ качестве аргумента функции можно использовать переменную, константу, а также выражения:\n\nsqrt(a)\n## [1] 2.236068\nsin(a)\n## [1] -0.9589243\ntan(1.5)\n## [1] 14.10142\nabs(a + b - 2.5)\n## [1] 6.5\n\nВы также можете легко вкладывать функции одна в одну, если результат вычисления одной функции нужно подставить в другую:\n\nsin(sqrt(a))\n## [1] 0.7867491\nsqrt(sin(a) + 2)\n## [1] 1.020331\n\nТакже как и с арифметическими выражениями, результат вычисления функции можно записать в переменную:\n\nb = sin(sqrt(a))\nb\n## [1] 0.7867491\n\nЕсли переменной b ранее было присвоено другое значение, оно перезапишется. Вы также можете записать в переменную результат операции, выполненной над ней же. Например, если вы не уверены, что a — неотрицательное число, а вам это необходимо в дальнейших расчетах, вы можете применить к нему операцию взятия модуля:\n\nb = sin(a)\nb\n## [1] -0.9589243\nb = abs(b)\nb\n## [1] 0.9589243\n\n\n\n\n1.1.2 Строки\nСтроки — также еще один важнейший тип данных. Чтобы создать строковую переменную, необходимо заключить текст строки в кавычки:\n\ns = \"В историю трудно войти, но легко вляпаться (М.Жванецкий)\"\ns\n## [1] \"В историю трудно войти, но легко вляпаться (М.Жванецкий)\"\n\nСтроки состоят из символов, и, в отличие от некоторых других языков, в R нет отдельного типа данных для объекта, которых хранит один символ (в C++ для этого используется тип char). Поэтому при создании строк вы можете пользоваться как одинарными, так и двойными кавычками:\n\ns1 = \"Это строка\"\ns1\n\n[1] \"Это строка\"\n\ns2 = 'Это также строка'\ns2\n\n[1] \"Это также строка\"\n\n\nИногда бывает необходимо создать пустую строку (например, чтобы в нее далее что-то добавлять). В этом случае просто напишите два знака кавычек, идущих подряд без пробела между ними:\n\ns1 = \"\" # это пустая строка\ns1\n\n[1] \"\"\n\ns2 = '' # это также пустая строка\ns2\n\n[1] \"\"\n\ns3 = ' ' # а это не пустая, тут есть пробел\ns3\n\n[1] \" \"\n\n\nДлину строки в символах можно узнать с помощью функции nchar()\n\nnchar(s)\n## [1] 56\nnchar(s1)\n## [1] 0\nnchar(s3)\n## [1] 1\n\nЧтобы извлечь из строки подстроку (часть строки), можно использовать функцию substr(), указав ей номер первого и последнего символа:\n\nsubstr(s, 3, 9) # извлекаем все символы с 3-го по 9-й\n\n[1] \"историю\"\n\n\nВ частности, зная длину строки, можно легко извлечь последние \\(k\\) символов:\n\nn = nchar(s)\nk = 7\nsubstr(s, n - k, n)\n\n[1] \"анецкий)\"\n\n\nСтроки можно складывать так же как и числа. Эта операция называется конкатенацией. В результате конкатенации строки состыковываются друг с другом и получается одна строка. В отличие от чисел, конкатенация производится не оператором +, а специальной функцией paste(). Состыковываемые строки нужно перечислить через запятую, их число может быть произвольно\n\ns1 = \"В историю трудно войти,\"\ns2 = \"но легко вляпаться\"\ns3 = \"(М.Жванецкий)\"\n\nПосмотрим содержимое подстрок:\n\ns1\n## [1] \"В историю трудно войти,\"\ns2\n## [1] \"но легко вляпаться\"\ns3\n## [1] \"(М.Жванецкий)\"\n\nА теперь объединим их в одну:\n\ns = paste(s1, s2)\ns\n## [1] \"В историю трудно войти, но легко вляпаться\"\ns = paste(s1, s2, s3)\ns\n## [1] \"В историю трудно войти, но легко вляпаться (М.Жванецкий)\"\n\nНастоящая сила конкатенации проявляется когда вам необходимо объединить в одной строке некоторое текстовое описание (заранее известное) и значения переменных, которые у вас вычисляются в программе (заранее неизвестные). Предположим, вы нашли в программе что максимальная численность населения в Детройте пришлась на 1950 год и составила 1850 тыс. человек. Найденный год записан у вас в переменную year, а население в переменную pop. Вы их значения пока что не знаете, они вычислены по табличным данным в программе. Как вывести эту информацию на экран “человеческим” образом? Для этого нужно использовать конкатенацию строк.\nУсловно запишем значения переменных, как будто мы их знаем\n\nyear = 1950\npop = 1850\n\n\ns1 = \"Максимальная численность населения в Детройте пришлась на\"\ns2 = \"год и составила\"\ns3 = \"тыс. чел\"\ns = paste(s1, year, s2, pop, s3)\ns\n## [1] \"Максимальная численность населения в Детройте пришлась на 1950 год и составила 1850 тыс. чел\"\n\nОбратите внимание на то что мы конкатенировали строки с числами. Конвертация типов осуществилась автоматически. Помимо этого, функция сама вставила пробелы между строками.\n\nФункция paste() содержит параметр sep, отвечающий за символ, который будет вставляться между конкатенируемыми строками. По умолчанию sep = \" \", то есть, между строками будет вставляться пробел. Подобное поведение желательно не всегда. Например, если после переменной у вас идет запятая, то между ними будет вставлен пробел. В таком случае при вызове paste() необходимо указать sep = \"\", то есть пустую строку: paste(... sep = \"\"). Вы также можете воспользоваться функцией paste0(), которая делает [почти] то же самое, что и paste(..., sep = \"\"), но избавляет вас от задания параметра sep.\n\n\n\n1.1.3 Даты и длительности\nДля работы с временными данными в R существуют специальные типы. Чаще всего используются даты, указанные с точностью до дня. Такие данные имеют тип Date, а для их создания используется функция as.Date(). В данном случае точка — это лишь часть названия функции, а не какой-то особый оператор. В качестве аргумента функции необходимо задать дату, записанную в виде строки. Запишем дату рождения автора (можете заменить ее на свою):\n\nbirth = as.Date('1986/02/18')\nbirth\n## [1] \"1986-02-18\"\n\nСегодняшнюю дату вы можете узнать с помощью специальной функции Sys.Date():\n\ncurrent = Sys.Date()\ncurrent\n## [1] \"2023-12-19\"\n\nДаты можно вычитать. Результатом выполнения. Например, узнать продолжительность жизни в днях можно так:\n\nlivedays = current - birth\nlivedays\n## Time difference of 13818 days\n\nВы также можете прибавить к текущей дате некоторое значение. Например, необходимо узнать, какая дата будет через 40 дней:\n\ncurrent + 40\n## [1] \"2024-01-28\"\n\nИмея дату, вы можете легко извлечь из нее день, месяц и год. Существуют специальные функции для этих целей (описанные в главе 8), но прямо сейчас вы можете сделать это сначала преобразовав дату в строку, а затем выбрав из нее подстроку, соответствующую требуемой компоненте даты:\n\ncdate = as.character(current)\nsubstr(cdate, 1, 4) # Год\n\n[1] \"2023\"\n\nsubstr(cdate, 6, 7) # Месяц \n\n[1] \"12\"\n\nsubstr(cdate, 9, 10)  # День\n\n[1] \"19\"\n\n\nБолее подробно о преобразованиях типов, аналогичных функции as.character(), используемой в данном примере, рассказано далее в настоящей главе.\n\n\n1.1.4 Время и периоды\n\n\n1.1.5 Логические\nЛогические переменные возникают там, где нужно проверить условие. Переменная логического типа может принимать значение TRUE (истина) или FALSE (ложь). Для их обозначения также возможны более компактные константы T и F соответственно.\nСледующие операторы приводят к возникновению логических переменных:\n\nРАВНО (==) — проверка равенства операндов\nНЕ РАВНО (!=) — проверка неравенства операндов\nМЕНЬШЕ (&lt;) — первый аргумент меньше второго\nМЕНЬШЕ ИЛИ РАВНО (&lt;=) — первый аргумент меньше или равен второму\nБОЛЬШЕ (&gt;) — первый аргумент больше второго\nБОЛЬШЕ ИЛИ РАВНО (&gt;=) — первый аргумент больше или равен второму\n\nПосмотрим, как они работают:\n\na = 1\nb = 2\na == b\n## [1] FALSE\na != b\n## [1] TRUE\na &gt; b\n## [1] FALSE\na &lt; b\n## [1] TRUE\n\nЕсли необходимо проверить несколько условий одновременно, их можно комбинировать с помощью логических операторов. Наиболее популярные среди них:\n\nИ (&&) - проверка истинности обоих условий\nИЛИ (||) - проверка истинности хотя бы одного из условий\nНЕ (!) - отрицание операнда (истина меняется на ложь, ложь на истину)\n\n\nc = 3\n(b &gt; a) && (c &gt; b)\n## [1] TRUE\n(a &gt; b) && (c &gt; b)\n## [1] FALSE\n(a &gt; b) || (c &gt; b)\n## [1] TRUE\n!(a &gt; b)\n## [1] TRUE\n\nБолее подробно работу с логическими переменными мы разберем далее при знакомстве с условным оператором if.",
    "crumbs": [
      "Основы",
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Типы данных</span>"
    ]
  },
  {
    "objectID": "01-Basics.html#manipulations",
    "href": "01-Basics.html#manipulations",
    "title": "1  Типы данных",
    "section": "1.2 Манипуляции с типами",
    "text": "1.2 Манипуляции с типами\n\n1.2.1 Определение типа данных\nОпределение типа данных осуществляется с помощью функции class() (см. раздел Диагностические функции во Введении)\n\nclass(1)\n## [1] \"numeric\"\nclass(0.5)\n## [1] \"numeric\"\nclass(1 + 2i)\n## [1] \"complex\"\nclass(\"sample\")\n## [1] \"character\"\nclass(TRUE)\n## [1] \"logical\"\nclass(as.Date('1986-02-18'))\n## [1] \"Date\"\n\nВ вышеприведенном примере видно, что R по умолчанию “повышает” ранг целочисленных данных до более общего типа чисел с плавающей точкой, тем самым закладываясь на возможность точного деления без остатка. Если вы хотите, чтобы данные в явном виде интерпретировались как целочисленные, их нужно принудительно привести к этому типу. Операторы преобразования типов рассмотрены ниже.\n\n\n1.2.2 Преобразование типов данных\nПреобразование типов данных осуществляется с помощью функций семейства as(d, type), где d — это входная переменная, а type — название типа данных, к которому эти данные надо преобразовать (см. таблицу в начале главы). Несколько примеров:\n\nk = 1\nprint(k)\n## [1] 1\nclass(k)\n## [1] \"numeric\"\n\nl = as(k, \"integer\")\nprint(l)\n## [1] 1\nclass(l)\n## [1] \"integer\"\n\nm = as(l, \"character\")\nprint(m)\n## [1] \"1\"\nclass(m)\n## [1] \"character\"\n\nn = as(m, \"numeric\")\nprint(n)\n## [1] 1\nclass(n)\n## [1] \"numeric\"\n\nДля функции as() существуют обертки (wrappers), которые позволяют записывать такие преобразования более компактно и выглядят как as.&lt;dataype&gt;(d), где datatype — название типа данных:\n\nk = 1\nl = as.integer(k)\nprint(l)\n## [1] 1\nclass(l)\n## [1] \"integer\"\n\nm = as.character(l)\nprint(m)\n## [1] \"1\"\nclass(m)\n## [1] \"character\"\n\nn = as.numeric(m)\nprint(n)\n## [1] 1\nclass(n)\n## [1] \"numeric\"\n\nd = as.Date('1986-02-18')\nprint(d)\n## [1] \"1986-02-18\"\nclass(d)\n## [1] \"Date\"\n\nЕсли преобразовать число c плавающей точкой до целого, то дробная часть будет отброшена:\n\nas.integer(2.7)\n## [1] 2\n\nПосле преобразования типа данных, разумеется, к переменной будут применимы только те функции, которые определены для данного типа данных:\n\na = 2.5\nb = as.character(a)\nb + 2\n## Error in b + 2: non-numeric argument to binary operator\nnchar(b)\n## [1] 3\n\n\n\n1.2.3 Проверка типов данных и пустых значений\nДля проверки типа данных можно использовать функции семейства is.&lt;datatype&gt;:\n\nis.integer(2.7)\n## [1] FALSE\nis.numeric(2.7)\n## [1] TRUE\nis.character('Привет!')\n## [1] TRUE\n\nОсобое значение имеют функции проверки пустых переменных (имеющих значение NA - not available), которые могут получаться в результате несовместимых преобразований или соответствовать пропускам в исходных данных:\n\nas.integer('Привет!')\n## [1] NA\nis.na(as.integer('Привет!'))\n## [1] TRUE",
    "crumbs": [
      "Основы",
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Типы данных</span>"
    ]
  },
  {
    "objectID": "01-Basics.html#read_write_console",
    "href": "01-Basics.html#read_write_console",
    "title": "1  Типы данных",
    "section": "1.3 Ввод и вывод данных в консоли",
    "text": "1.3 Ввод и вывод данных в консоли\n\n1.3.1 Ввод данных\nДля ввода данных через консоль можно воспользоваться функцией readline(), которая будет ожидать пользовательский ввод и нажатие клавиши Enter, после чего вернет введенные данные в виде строки. Предположим, пользователь вызывает эту функцию и вводит с клавиатуры 1024:\n\na = readline()\n\nВыведем результат на экран:\n\na\n## [1] \"1024\"\n\n\nФункция readline() всегда возвращает строку, поэтому если вы ожидаете ввод числа, полученное значение необходимо явным образом преобразовать к числовому типу.\n\nВесьма полезной особенностью readline() является возможность указания строки запроса (чтобы пользователь понимал, что от него хотят). Строку запроса можно указать при вызове функции:\n\nlat = readline('Введите широту точки:')\n## Введите широту точки:\n## 54\nlat\n## [1] \"54\"\n\n\n\n1.3.2 Вывод данных\nДля вывода данных в консоль можно воспользоваться тремя способами:\n\nПросто напечатать название переменной с новой строки (не работает при запуске программы командой Source)\nВызвать функцию print()\nВызвать функцию cat()\nЗаключить выражение в круглые скобки ()\n\nПервый способ мы уже регулярно использовали ранее в настоящей главе. Следует обратить внимание на то, что он хорош для отладки программы, но выглядит некрасиво в рабочих программах, поскольку просто печатая название переменной с новой строки вы как бы явно не говорите о том, что хотите вывести ее значение в консоль, а лишь подразумеваете это. Более того, если скрипт запускается командой Source, данный метод вывода переменной просто не сработает, интерпретатор его проигнорирует.\nПоэтому после отладки следует убрать из программы все лишние выводы в консоль, а оставшиеся (действительно нужные) оформить с помощью функций print() или cat().\nФункция print() работает точно так же, как и просто название переменной с новой строки, отличаясь лишь двумя особенностями:\n\nprint() явным образом говорит о том, что вы хотите вывести в консоль некую информацию\nprint() работает при любых методах запуска программы, в том числе методом Source.\n\nНапример:\n\na = 1024\na\n## [1] 1024\nprint(a)\n## [1] 1024\n\nb = \"Fourty winks in progress\"\nb\n## [1] \"Fourty winks in progress\"\nprint(b)\n## [1] \"Fourty winks in progress\"\n\nprint(paste(\"2 в степени 10 равно\", 2^10))\n## [1] \"2 в степени 10 равно 1024\"\n\nprint(paste(\"Сегодняшняя дата - \", Sys.Date()))\n## [1] \"Сегодняшняя дата -  2023-12-19\"\n\nФункция cat() отличается от print() следующими особенностями:\n\ncat() выводит значение переменной, и не печатает ее измерения и внешние атрибуты типа двойных кавычек вокруг строки. Это означает, что cat() можно использовать и для записи данных в файл (на практике этим мало кто пользуется, но знать такую возможность надо).\ncat() принимает множество аргументов и может осуществлять конкатенацию строк аналогично функции paste()\ncat() не возвращает никакого значений, в то время как print() возвращает значение, переданное ей в качестве аргумента.\ncat() можно использовать только для атомарных типов данных. Для классов (таких как Date) она будет выводит содержимое объекта, которое может не совпадать с тем, что пользователь ожидает вывести\n\nНапример:\n\ncat(a)\n## 1024\ncat(b)\n## Fourty winks in progress\n\ncat(\"2 в степени 10 равно\", 2^10)\n## 2 в степени 10 равно 1024\n\ncat(\"Сегодняшнаяя дата -\", Sys.Date())\n## Сегодняшнаяя дата - 19710\n\nМожно видеть, что в последнем случае cat() напечатала отнюдь не дату в ее привычном представлении, а некое число, которое является внутренним представлением даты в типе данных Date. Такие типы данных являются классами объектов в R, и у них есть своя функция print(), которая и выдает содержимое объекта в виде, который ожидается пользователем. Поэтому пользоваться функцией cat() надо с некоторой осторожностью.\nЗаключительная возможность — вывод с помощью заключения выражения в круглые скобки — очень удобна на стадии отладки программы. При этом переменная, которая создается в выражении, остается доступной в программе:\n\n(a = rnorm(5)) # сгенерируем 5 случайных чисел, запишем их в переменную a и выведем на экран\n\n[1]  1.8983975  3.1158498 -0.9761858  0.2970648  1.2309851\n\n(b = 2 * a) # переменная a доступна, ее можно использовать и далее для вычислений\n\n[1]  3.7967951  6.2316996 -1.9523716  0.5941297  2.4619703",
    "crumbs": [
      "Основы",
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Типы данных</span>"
    ]
  },
  {
    "objectID": "01-Basics.html#ifelse",
    "href": "01-Basics.html#ifelse",
    "title": "1  Типы данных",
    "section": "1.4 Условный оператор",
    "text": "1.4 Условный оператор\nПроверка условий позволяет осуществлять так называемое ветвление в программе. Ветвление означает, что при определенных условиях (значениях переменных) будет выполнен один программный код, а при других условиях — другой. В R для проверки условий используется условный оператор if — else if — else следующего вида:\nif (condition) {\n  statement1\n} else if (condition) {\n  statement2\n} else {\n  statement3\n}\nСначала проверяется условие в выражении if (condition), и если оно истинно, то выполнится вложенный в фигурные скобки программный код statement1, после чего оставшиеся условия не будут проверяться. Если первое условие ложно, программа перейдет к проверке следующего условия else if (condition). Далее, если оно истинно, то выполнится вложенный код statement2, если нет — проверка переключится на следующее условие и так далее. Заключительный код statement3, следующий за словом else, выполнится только если ложными окажутся все предыдущие условия.\n\nКонструкций else if может быть произвольное количество, конструкции if и else могут встречаться в условном операторе только один раз, в начале и конце соответственно. При этом условный оператор может состоять только из конструкции if, а else if и else не являются обязательными.\n\nНапример, сгенерируем случайное число, округлим его до одного знака после запятой и проверим относительно нуля:\n\n(a = round(rnorm(1), 1))\n\n[1] 0.9\n\nif (a &lt; 0) {\n  cat('Получилось отрицательное число!')\n} else if (a &gt; 0) {\n  cat('Получилось положительное число!')\n} else {\n  cat('Получился нуль!')\n}\n\nПолучилось положительное число!\n\n\nУсловия можно использовать, в частности, для того чтобы обрабатывать пользовательский ввод в программе. Например, охарактеризуем положение точки относительно Полярного круга:\n\nphi = as.numeric(readline('Введите широту вашей точки:'))\n\nПользователь вводит 68, а мы оцениваем результат:\n\nif (!is.na(phi)) { # проверяем, является ли введенное значение числом\n  \n  if (abs(phi) &gt;= 66.562 && abs(phi) &lt;= 90) { # выполняем проверку на заполярность\n    cat('Точка находится в Заполярье')\n  } else {\n    cat('Точка не находится в Заполярье')\n  }\n  \n} else {\n  cat('Необходимо ввести число!') # оповещаем о некорректном вводе\n}\n\nТочка находится в Заполярье",
    "crumbs": [
      "Основы",
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Типы данных</span>"
    ]
  },
  {
    "objectID": "01-Basics.html#switch",
    "href": "01-Basics.html#switch",
    "title": "1  Типы данных",
    "section": "1.5 Оператор переключения",
    "text": "1.5 Оператор переключения\nОператор переключения (switch) является удобной заменой условному оператору в тех случаях, когда надо вычислить значение переменной в зависимости от значения другой переменной, которая может принимать ограниченное (заранее известное) число значений. Например:\n\nname = readline('Введите название федерального округа:')\n\nПользователь вводит:\nПриволжский\n\n# Определим центр в зависимости от названия:\ncapital = switch(name,\n                 'Центральный' = 'Москва',\n                 'Северо-Западный' = 'Санкт-Петербург',\n                 'Южный' = 'Ростов-на-Дону',\n                 'Северо-Кавказский' = 'Пятигорск',\n                 'Приволжский' = 'Нижний Новгород',\n                 'Уральский' = 'Екатеринбург',\n                 'Сибирский' = 'Новосибирск',\n                 'Дальневосточный' = 'Хабаровск')\nprint(capital)\n\n[1] \"Нижний Новгород\"",
    "crumbs": [
      "Основы",
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Типы данных</span>"
    ]
  },
  {
    "objectID": "01-Basics.html#stop",
    "href": "01-Basics.html#stop",
    "title": "1  Типы данных",
    "section": "1.6 Прерывание программы",
    "text": "1.6 Прерывание программы\nВ процессе выполнения программы могут возникнуть ситуации, при которых дальнейшее выполнение программы невозможно или недопустимо. Например, пользователь вместо числа ввёл в консоли букву. Хорошим тоном разработчика в данном случае будет не пускать ситуацию на самотёк и ждать пока программа сама споткнется и выдаст системное сообщение об ошибке, а обработать некорректный ввод сразу, сообщить об этом пользователю и остановить программу явным образом.\nПрервать выполнение программы можно разными способами. Рассмотрим две часто используемые для этого функции:\n\nstop(...) выводит на экран объекты, перечисленные через запятую в ... и завершает выполнение программы. При ручном вызове этой функции в ... целесообразно передать текстовую строку с сообщением о причине остановки программы. Вызов stop() происходит обычно после проверки некоторого условия оператором if-else.\nstopifnot(...) вызывает stop(), если хотя бы одно из выражений, перечисленных через запятую в ... имеет значение FALSE. При этом в stop() передается первое выражение, которое было оценено в FALSE.\n\nРеализуем вышеописанный пример с контролем пользовательского ввода:\n\nn = as.numeric(readline('Введите число:'))\nstopifnot(is.numeric(n)) # остановим выполнение, если получилось не число\ncat(n^2) # возведем в квадрат и выведем на экран, если все ОК\n\nЕсли пользователь введет abc, программа остановит выполнение:\n\n\nError: is.numeric(n) is not TRUE\n\n\nОбратите внимание, что R напечатал также и само выражение, которое было оценено как FALSE. Вышеприведенный код можно сделать более дружелюбным для пользователя, если воспользоваться непосредственно функцией stop():\n\nn = as.numeric(readline('Введите число:'))\nif (!is.numeric(n)) stop('Введенная строка не является числом') # остановим выполнение\ncat(n^2) # возведем в квадрат и выведем на экран, если все ОК\n\nВывод программы в случае ввода строки abc будет следующим:\n\n\nError in eval(expr, envir, enclos): Введенная строка не является числом",
    "crumbs": [
      "Основы",
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Типы данных</span>"
    ]
  },
  {
    "objectID": "01-Basics.html#basics-detail",
    "href": "01-Basics.html#basics-detail",
    "title": "1  Типы данных",
    "section": "1.7 Технические детали",
    "text": "1.7 Технические детали\nКогда вы присваиваете значение переменной другой переменной, копирования не происходит. Оба имени будут ссылаться на один и тот же объект, до тех пор, пока через одно из имен не будет предпринята попытка модифицировать объект. Это можно легко проверить с помощью функции tracemem():\n\na = 1\nb = a\ncat('a:', tracemem(a), '\\n')\n\na: &lt;0x7fda4bbd22e8&gt; \n\ncat('b:', tracemem(b), '\\n')\n\nb: &lt;0x7fda4bbd22e8&gt; \n\na = 2\ncat('a:', tracemem(a), '\\n') # объект скопирован в другую область памяти\n\na: &lt;0x7fda4bbe9ee8&gt; \n\ncat('b:', tracemem(b), '\\n')\n\nb: &lt;0x7fda4bbd22e8&gt; \n\n\n\nПодобное поведение называется copy-on-modify. Оно позволяет экономить на вычислениях в случае, когда копия и оригинал остаются неизменными. Аналогичное правило применяется когда вы копируете структуры данных, такие как векторы, списки и фреймы данных (см. Главу @ref(data-structures)). Более подробно см. параграф 2.3 в (Wickham 2019).",
    "crumbs": [
      "Основы",
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Типы данных</span>"
    ]
  },
  {
    "objectID": "01-Basics.html#review",
    "href": "01-Basics.html#review",
    "title": "1  Типы данных",
    "section": "1.8 Краткий обзор",
    "text": "1.8 Краткий обзор\nДля просмотра презентации щелкните на ней один раз левой кнопкой мыши и листайте, используя кнопки на клавиатуре:\n\n\n\n\n\nПрезентацию можно открыть в отдельном окне или вкладке браузере. Для этого щелкните по ней правой кнопкой мыши и выберите соответствующую команду.",
    "crumbs": [
      "Основы",
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Типы данных</span>"
    ]
  },
  {
    "objectID": "01-Basics.html#questions_tasks_basics",
    "href": "01-Basics.html#questions_tasks_basics",
    "title": "1  Типы данных",
    "section": "1.9 Контрольные вопросы и упражнения",
    "text": "1.9 Контрольные вопросы и упражнения\n\n1.9.1 Вопросы\n\nКакие типы данных поддерживаются в R? Каковы их англоязычные наименования?\nЧто такое переменная?\nКакой оператор используется для записи значения в переменную?\nС помощью какой функции можно узнать тип переменной?\nС помощью какого семейства функций можно преобразовывать типы переменных?\nМожно ли использовать ранее созданное имя переменной для хранения новых данных другого типа?\nМожно ли записать в переменную результат выполнения выражения, в котором она сама же и участвует?\nКакая функция позволяет прочитать пользовательский ввод с клавиатуры в консоли? Какой тип данных будет иметь возвращаемое значение?\nКакую функцию можно использовать для вывода значения переменной в консоль? Чем отличается использование этой функции от случая, когда вы просто пишете название переменной в строке программы?\nКакой символ является разделителем целой и дробной части при записи чисел с плавающей точкой?\nЧто такое операторы и операнды? Приведите примеры бинарных и унарных операторов.\nКакое значение будет имет результат деления на ноль?\nКакие функции выполняют операторы %%, %/%, ^, **?\nКак проверить, является ли число четным?\nКак определить количество символов в строке?\nКак называется операция состыковки нескольких строк и с помощью какой функции она выполняется? Как добиться того, чтобы при этом не добавлялись пробелы между строками?\nС помощью какой функции можно создать дату из строки?\nКак извлечь из даты год? Месяц? День?\nКакая функция позволяет получить дату сегодняшнего дня?\nМожно ли складывать даты и числа? Если да, то в каких единицах измерения будет выражен результат?\nКакова краткая форма записи логических значений TRUE и FALSE?\nКаким числам соответствуют логические значения TRUE и FALSE?\nСколько операндов должно быть верно, чтобы оператор логического И (&&) принял значение TRUE? Что можно сказать в этом отношении об операторе ИЛИ (||)?\nМожно ли применять арифметические операции к логическим переменным? Что произойдет, если прибавить или вычесть из числа a значение TRUE? А если заменить TRUE на FALSE?\nЧто такое условный оператор и для каких сценариев обработки данных необходимы условные операторы?\nПеречислите ключевые слова, которые могут быть использованы для организации условных операторов\nПри каких сценариях целесообразно использовать оператор переключения?\n\n\n\n1.9.2 Упражнения\n\nЗапишите условие проверки неравенства чисел a и b не менее чем тремя способами.\nНапишите программу, которая запрашивает в консоли целое число и определяет, является ли оно чётным или нечетным. Программа должна предварительно определить, является ли введенное число а) числом и б) целым числом.\n\nПодсказка: результат конвертации строки в целое число и число с плавающей точкой отличается. Вы можете использовать это для проверки, является ли введенное число целым.\n\nНапишите программу, которая считывает из консоли введенную пользователем строку и выводит в консоль количество символов в этой строке. Вывод оформите следующим образом: \"Длина введенной строки равняется ... символам\", где вместо многоточия стоит вычисленная длина.\nВ программе в виде переменных задайте координаты населенного пункта А (x1, y1), а также дирекционный угол D и расстояние L до населенного пункта B. Напишите код, который определяет координаты населенного пункта B (x2, y2).\nФункция atan2() позволяет найти математический азимут (полярный угол), если известны координаты вектора между двумя точками. Используя эту функцию, напишите программу, которая вычисляет географический азимут между точками А (x1, y1) и B (x2, y2). Координаты точек задайте в виде переменных непосредственно в коде.\n\nМатематический азимут отсчитывается от направления на восток против часовой стрелки. Географический азимут отсчитывается от направления на север по часовой стрелке).\n\n\n\n\n\nСамсонов Т.Е. Визуализация и анализ географических данных на языке R. М.: Географический факультет МГУ, 2023. DOI: 10.5281/zenodo.901911\n\n\n\n\n\n\n\nWickham, Hadley. 2019. Advanced R. 2nd ed. Chapman and Hall/CRC.",
    "crumbs": [
      "Основы",
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Типы данных</span>"
    ]
  },
  {
    "objectID": "02-DataStructures.html#data_structures_homo",
    "href": "02-DataStructures.html#data_structures_homo",
    "title": "2  Структуры данных",
    "section": "2.1 Однородные структуры данных",
    "text": "2.1 Однородные структуры данных\n\n2.1.1 Векторы\nВектор представляет собой упорядоченную последовательность объектов одного типа. Вектор может состоять только из чисел, только из строк, только из дат или только из логических значений и т.д. Числовой вектор легко представить себе в виде набора цифр, выстроенных в ряд и пронумерованных согласно порядку их расстановки.\nВектор является простейшей и одновременно базовой структурой данных в R. Понимание принципов работы с векторами необходимо для дальнейшего знакомства с более сложными структурами данных, такими как матрицы, массивы, фреймы данных, тибблы, списки и факторы.\n\n2.1.1.1 Создание\nСуществует множество способов создания векторов. Среди них наиболее употребительны:\n\nЯвное перечисление элементов\nСоздание пустого вектора (“болванки”), состоящего из заданного числа элементов\nГенерация последовательности значений\nГенерация случайного множества значений\n\nДля создания вектора путем перечисления элементов используется функция c():\n\n# вектор из строк — цвета некоторых веток Московского метро\ncolors = c(\"Красная\", \"Зеленая\", \"Синяя\", \"Коричневая\", \"Оранжевая\")\ncolors\n## [1] \"Красная\"    \"Зеленая\"    \"Синяя\"      \"Коричневая\" \"Оранжевая\"\n\n\n# вектор из чисел — длина веток в километрах (в той же последовательности)\nlengths = c(28, 40, 45, 19, 38)\nlengths\n## [1] 28 40 45 19 38\n\n\n# вектор из булевых переменных — наличие  открытых наземных участков (в той же последовательности)\nopens = c(FALSE, TRUE, TRUE, FALSE, FALSE)\nopens\n## [1] FALSE  TRUE  TRUE FALSE FALSE\n\n\nВнимание: не используйте латинскую букву ‘c’ в качестве названия переменной! Это приведет к конфликту названия встроенной функции c() и определенной вами переменной\n\nПомимо этого, распространены сценарии, когда вам нужно создать вектор, но заполнять его значениями вы будете по ходу выполнения программы — скажем, при последовательной обработке строк таблицы. В этом случае вам известно только предполагаемое количество элементов вектора и их тип. Здесь лучше всего подойдет создание пустого вектора, которое выполняется функцией vector(). Функция принимает 2 параметра:\n\nmode отвечает за тип данных и может принимать значения равные \"logical\", \"integer\", \"numeric\" (или \"double\"), \"complex\", \"character\" и \"raw\"\nlength отвечает за количество элементов\n\nНапример:\n\n# Вектор из 5 элементов, который предполагается заполнить целыми числами\nintvalues = vector(mode = \"integer\", length = 5)\nintvalues # по умолчанию заполнен нулями\n## [1] 0 0 0 0 0\n\n# Вектор из 10 элементов, который предполагается заполнить символьными данными (строками)\ncharvalues = vector(\"character\", 10)\ncharvalues # по умолчанию заполнен пустыми строками\n##  [1] \"\" \"\" \"\" \"\" \"\" \"\" \"\" \"\" \"\" \"\"\n\nОбратите внимание на то, что в первом случае подстановка параметров произведена в виде параметр = значение, а во втором указаны только значения. В данном примере оба способа эквивалентны. Однако первый способ безопаснее и понятнее. Если вы указываете только значения параметров, нужно помнить, что интерпретатор будет подставлять их именно в том порядке, в котором они перечислены в описании функции.\n\nОписание функции можно посмотреть, набрав ее название в консоли ее название со знаком вопроса в качестве префикса. Например, для вышеуказанной функции надо набрать ?vector\n\nНаконец, третий распространенный способ создания векторов — это генерация последовательности. Чтобы сформировать вектор из натуральных чисел от M до N, можно воспользоваться специальной конструкцией: M:N:\n\nindex = 1:5 # эквивалентно c(1,2,3,4,5)\nindex\n## [1] 1 2 3 4 5\nindex = 2:4 # эквивалентно c(2,3,4)\nindex\n## [1] 2 3 4\n\nСуществует и более общий способ создания последовательности — функция seq(), которая позволяет генерировать вектора значений нужной длины и/или с нужным шагом:\n\nseq(from = 1, by = 2, length.out = 10) # 10 нечетных чисел, начиная с единицы\n##  [1]  1  3  5  7  9 11 13 15 17 19\nseq(from = 2, to = 20, by = 3) # от 2 до 20 с шагом 3 (сколько поместится)\n## [1]  2  5  8 11 14 17 20\nseq(length.out = 10, to = 2, by = -2) # убывающая последовательность из 10 четных чисел с последним элементом, равным 2\n##  [1] 20 18 16 14 12 10  8  6  4  2\n\nКак видно, параметры функции seq() можно комбинировать различными способами и указывать в произвольном порядке (при условии, что вы используете полную форму (параметр = значение). Главное, чтобы их совокупность однозначно описывала последовательность. Хотя, скажем, последний пример убывающей последовательности нельзя признать удачным с точки зрения наглядности.\nАналогичным образом можно создавать последовательности дат:\n\nseq(from = as.Date('2016/09/01'), by = 1, length.out = 7) # Даты первой недели учебного 2016/2017 года\n## [1] \"2016-09-01\" \"2016-09-02\" \"2016-09-03\" \"2016-09-04\" \"2016-09-05\"\n## [6] \"2016-09-06\" \"2016-09-07\"\n\nseq(from = Sys.Date(), by = 7, length.out = 5) # Пять дат через неделю, начиная с сегодняшнего дня\n## [1] \"2023-12-19\" \"2023-12-26\" \"2024-01-02\" \"2024-01-09\" \"2024-01-16\"\n\nЧасто оказывается полезным такая функция как генерация множества случайных значений, подчиненных определенному закону распределения. Наиболее часто испольщуются функции runif() (равномерное распределение) и rnorm() (нормальное распределение):\n\nrunif(5, 0, 100) # 5 чисел равномерного распределения в диапазоне от 0 до 100\n\n[1] 98.331794 10.525306 52.130557 10.138716  0.263909\n\nrnorm(5, 10, 5) # 5 чисел нормального распределения со средним = 10 и СКО = 5\n\n[1]  7.620032  9.719107 14.128401 12.933013 20.940263\n\n\n\n\n2.1.1.2 Индексирование\nК отдельным элементам вектора можно обращаться по их индексам:\n\ncolors[1] # первый элемент вектора\n## [1] \"Красная\"\ncolors[3] # третий элемент\n## [1] \"Синяя\"\n\n\nВНИМАНИЕ: элементы векторов и других структур данных в языке R индексируются от 1 до N, где N — это длина вектора. Это отличает R от широко распространенных Си-подобных языков программирования (C, C++, C#, Java, Python), в которых индексы элементов начинаются с 0 и заканчиваются N-1. Например, первый элемент списка (аналог вектора в R) на языке Python извлекался бы как colors[0]. Будьте внимательны, особенно если программируете на нескольких языках.\n\nКоличество элементов (длину) вектора можно узнать с помощью функции length():\n\nlength(colors)\n## [1] 5\n\nПоследний элемент вектора можно извлечь, если мы знаем его длину:\n\nn = length(colors)\ncolors[n]\n## [1] \"Оранжевая\"\n\nПоследовательности удобно использовать для извлечения подвекторов. Предположим, нужно извлечь первые 4 элемента. Для этого запишем:\n\nlengths[1:4]\n## [1] 28 40 45 19\n\nИндексирующий вектор можно создать заранее. Это удобно, если номера могут меняться в программе:\n\nm = 1\nn = 4\nindex = m:n\nlengths[index]\n## [1] 28 40 45 19\n\nОбратите внимание на то что по сути один вектор используется для извлечения элементов из другого вектора. Это означает, что мы можем использовать не только простые последовательности натуральных чисел, но и векторы из прозвольных индексов. Например:\n\nindex = c(1, 3, 4) # хотим извлечь 1, 3 и 4 элемент списка\nlengths[index]\n## [1] 28 45 19\n\nindex = c(5, 1, 4, 2) # индексы могут располагаться в произвольном порядке\nlengths[index]\n## [1] 38 28 19 40\n\n\n\n2.1.1.3 Преобразование\nК числовым векторам можно применять множество функций. Прежде всего, нужно знать функции вычисления базовых параметров статистического ряда — минимум, максимум, среднее, медиана, дисперсия, размах вариации, среднеквадратическое отклонение, сумма:\n\nmin(lengths) # минимум\n## [1] 19\nmax(lengths) # максимум\n## [1] 45\nrange(lengths) # размах вариации = максимум - минимум\n## [1] 19 45\nmean(lengths) # среднее арифметическое\n## [1] 34\nmedian(lengths) # медиана\n## [1] 38\nvar(lengths) # дисперсия (по английски - вариация, variation)\n## [1] 108.5\nsd(lengths) # среднеквадратическое отклонение (standard deviation)\n## [1] 10.41633\nsum(lengths) # сумма\n## [1] 170\n\nОдной из мощнейших особенностей R является то что он не проводит различий между числами и векторами чисел. Поскольку R является матричным языком, каждое число представляется как вектор длиной 1 (или матрица \\(1х1\\)). Это означает, что любая математическая функция, применимая к числу, будет применима и к вектору:\n\nlengths * 1000 # преобразуем длины линий в метры\n## [1] 28000 40000 45000 19000 38000\nsqrt(lengths) # квадратный корень из длины каждого элемента\n## [1] 5.291503 6.324555 6.708204 4.358899 6.164414\n\nstations = c(20, 21, 22, 12, 24) # количество станций\n\ndens = stations / lengths # плотность станций по веткам метро = кол-во станций / длина \ndens\n## [1] 0.7142857 0.5250000 0.4888889 0.6315789 0.6315789\n\n\n\n2.1.1.4 Поиск и сортировка\nК важнейшим преобразованиям векторов относится их сортировка:\n\nlengths2 = sort(lengths) # сортировка по возрастанию значений\nlengths2 # отсортированный вектор\n## [1] 19 28 38 40 45\nlengths # сравним с исходным\n## [1] 28 40 45 19 38\n\nlengths2 = sort(lengths, decreasing = TRUE) # сортировка по убыванию значений. Нужно задать параметр decreasing\nlengths2 # отсортированный вектор\n## [1] 45 40 38 28 19\nlengths # сравним с исходным\n## [1] 28 40 45 19 38\n\nДругая распространенная задача — это поиск индекса элемента по его значению. Например, вы хотите узнать, какая ветка Московского метро (среди рассматриваемых) является самой длинной. Вы, конечно, легко найдете ее длину с помощью функции max(lengths). Однако это не поможет вам узнать ее название, поскольку оно находится в другом векторе, и его индекс в массиве неизвестен. Поскольку векторы упорядочены одинаково, нам достаточно узнать, под каким индексом в массиве lengths располагается максимальный элемент, и затем извлечь цвет линии метро под тем же самым индексом. Дл поиска индекса элемента используется функция match():\n\nl = max(lengths) # находим максимальное значение\nidx = match(l, lengths) # находим индекс элемента, равного l, в списке lengths\ncolor = colors[idx] # извлекаем цвет ветки метро\ncolor\n## [1] \"Синяя\"\n\nЗдесь непохо бы лишний раз потренироваться в конкатенации строк, чтобы вывести результат красиво!\n\ns = paste(color, \"ветка Московского метро — самая длинная. Ее протяженность составляет\", l, \"км\")\ns\n## [1] \"Синяя ветка Московского метро — самая длинная. Ее протяженность составляет 45 км\"\n\nНу и напоследок пример “матрешки”” из функций — как найти название самой плотной линии одним выражением:\n\ncolors[match(max(dens),dens)]\n## [1] \"Красная\"\n\n\n\n2.1.1.5 Проверка условий\nПроверка условия для вектора приводит к получению вектора логических значений:\n\nlengths &gt; 20\n\n[1]  TRUE  TRUE  TRUE FALSE  TRUE\n\n\nТакого рода условия используются для фильтрации фреймов данных (см. далее)\nДля векторов существует специальная форма векторизованного условного оператора – функция ifelse(). Она позволяет создать вектор, каждый элемент которого вычисляется по-разному в зависимости от значения элемента другого вектора в соответствующей позиции. Например, мы можем охарактеризовать каждую линию метро как длинную или короткую, установив порог в 20 км:\n\n(line_type = ifelse(lengths &gt; 20, 'Длинная', 'Короткая'))\n\n[1] \"Длинная\"  \"Длинная\"  \"Длинная\"  \"Короткая\" \"Длинная\" \n\n\n\n\n2.1.1.6 Описательные статистики\nМожно получить краткую статистическую сводку по вектору (и любой другой структуре данных) с использованием функции summary(). Для качественных переменных выдаются частоты вхождения каждого случая, для количественных — набор основных описательных статистик:\n\nsummary(lengths)\n\n   Min. 1st Qu.  Median    Mean 3rd Qu.    Max. \n     19      28      38      34      40      45 \n\nsummary(opens)\n\n   Mode   FALSE    TRUE \nlogical       3       2 \n\n\n\n\n\n2.1.2 Матрицы\nМатрица — это обобщение понятия вектора на 2 измерения. С точки зрения анализа данных матрицы ближе к реальным данным, посколько каждая матрица по сути представляет собой таблицу со столбцами и строками. Однако матрица, как и вектор, может содержать только элементы одного типа (числовые, строковые, логические и т.д.). Позже мы познакомимся с фреймами данных, которые не обладают подобным ограничением.\nМатрица, как правило, создается с помощью функции matrix, которая принимает 3 обязательных аргумента: вектор исходных значений, количество строк и количество столбцов:\n\nv = 1:12  # создадим вектор из натуральных чисел от 1 до 12\nm = matrix(v, nrow = 3, ncol = 4)\nm\n##      [,1] [,2] [,3] [,4]\n## [1,]    1    4    7   10\n## [2,]    2    5    8   11\n## [3,]    3    6    9   12\n\nПо умолчанию матрица заполняется данными вектора по столбцам, что можно видеть в выводе программы. Если вы хотите заполнить ее по строкам, необходимо указать параметр byrow = TRUE:\n\nm = matrix(v, nrow = 3, ncol = 4, byrow = TRUE)\nm\n##      [,1] [,2] [,3] [,4]\n## [1,]    1    2    3    4\n## [2,]    5    6    7    8\n## [3,]    9   10   11   12\n\nДоступ к элементам матрицы осуществляется аналогично вектору, за исключением того что нужно указать положение ячейки в строке и столбце:\n\nm[2,4]  # 2 строка, 4 толбец\n## [1] 8\nm[3,1]  # 3 строка, 1 столбец\n## [1] 9\n\nПомимо этого, из матрицы можно легко извлечь одну строку или один столбец. Для этого достаточно указать только номер строки или столбца, а номер второго измерения пропустить до или после запятой. Результат является вектором:\n\nm[2,]  # 2 строка\n## [1] 5 6 7 8\nm[,3]  # 3 cтолбец\n## [1]  3  7 11\n\nК матрицам можно применять операции, аналогичные операциям над векторами:\n\nlog(m)  # натуральный логарифм ото всех элементов\n##          [,1]      [,2]     [,3]     [,4]\n## [1,] 0.000000 0.6931472 1.098612 1.386294\n## [2,] 1.609438 1.7917595 1.945910 2.079442\n## [3,] 2.197225 2.3025851 2.397895 2.484907\nsum(m)  # сумма всех элементов матрицы\n## [1] 78\nmedian(m) # медиана\n## [1] 6.5\n\nB и получать по ним описательные статистики:\n\nsummary(m)\n\n       V1          V2           V3           V4    \n Min.   :1   Min.   : 2   Min.   : 3   Min.   : 4  \n 1st Qu.:3   1st Qu.: 4   1st Qu.: 5   1st Qu.: 6  \n Median :5   Median : 6   Median : 7   Median : 8  \n Mean   :5   Mean   : 6   Mean   : 7   Mean   : 8  \n 3rd Qu.:7   3rd Qu.: 8   3rd Qu.: 9   3rd Qu.:10  \n Max.   :9   Max.   :10   Max.   :11   Max.   :12  \n\n\nА вот сортировка матрицы приведет к тому что будет возвращен обычный вектор:\n\nsort(m)\n##  [1]  1  2  3  4  5  6  7  8  9 10 11 12\n\nК матрицам также применимы специальные функции, известные из линейной алгебры, такие как транспонирование и вычисление определителя:\n\nt(m)  # транспонированная матрица\n##      [,1] [,2] [,3]\n## [1,]    1    5    9\n## [2,]    2    6   10\n## [3,]    3    7   11\n## [4,]    4    8   12\nm2=matrix(-3:3,nrow = 3, ncol = 3)\nm2\n##      [,1] [,2] [,3]\n## [1,]   -3    0    3\n## [2,]   -2    1   -3\n## [3,]   -1    2   -2\ndet(m2) # определитель матрицы\n## [1] -21\ndet(m)  # ошибка! определитель вычисляется только для квадратных матриц\n## Error in determinant.matrix(x, logarithm = TRUE, ...): 'x' must be a square matrix\n\nМатрицы также можно перемножать с помощью специального оператора %*%. При этом, как мы помним, число столбцов в первой матрице должно равняться числу строк во второй:\n\nm2 %*% m\n##      [,1] [,2] [,3] [,4]\n## [1,]   24   24   24   24\n## [2,]  -24  -28  -32  -36\n## [3,]   -9  -10  -11  -12\nm %*% m2  # ошибка!\n## Error in m %*% m2: non-conformable arguments\n\nФункция match(), которую мы использовали для поиска элементов в векторе, не работает для матриц. Вместо этого необходимо использовать функцию which(). Если мы хотим найти в матрице m позицию числа \\(8\\), то вызов функции будет выглядеть так:\n\nwhich(m == 8, arr.ind = TRUE)\n##      row col\n## [1,]   2   4\n\nВ данном случае видно, что результат возвращен в виде матрицы \\(1 \\times 2\\). Обратите внимание на то, что колонки матрицы имеют названия. Попробуем использовать найденные индексы, чтобы извлечь искомый элемент:\n\nindexes = which(m == 8, arr.ind = TRUE)\nrow = indexes[1,1]\ncol = indexes[1,2]\nm[row,col]\n## [1] 8\n\nУра! Найденный элемент действительно равен \\(8\\).\nЕще один полезный способ создания матрицы — это собрать ее из нескольких векторов, объединив их по строкам. Для этого можно использовать функции cbind() и rbind(). На предыдущем занятии мы создали векторы с длиной и количеством станций на разных ветках метро. Можно объединить их в одну матрицу:\n\nlengths = c(28, 40, 45, 19, 38)\nstations = c(20, 21, 22, 12, 24)\ncbind(lengths, stations)  # соединим вектора в качестве столбцов\n##      lengths stations\n## [1,]      28       20\n## [2,]      40       21\n## [3,]      45       22\n## [4,]      19       12\n## [5,]      38       24\nrbind(lengths, stations)  # соединим вектора в качестве строк\n##          [,1] [,2] [,3] [,4] [,5]\n## lengths    28   40   45   19   38\n## stations   20   21   22   12   24\n\nCтроки и столбцы матрицы можно использовать как векторы при выполнении арифметических операций:\n\nmm = cbind(lengths, stations)\nmm[,2]/mm[,1]  # количество станций на 1 км пути\n## [1] 0.7142857 0.5250000 0.4888889 0.6315789 0.6315789\n\nРезультат можно присоединить к уже созданной матрице:\n\ndens = mm[,2]/mm[,1]\nmm=cbind(mm, dens)\nmm\n##      lengths stations      dens\n## [1,]      28       20 0.7142857\n## [2,]      40       21 0.5250000\n## [3,]      45       22 0.4888889\n## [4,]      19       12 0.6315789\n## [5,]      38       24 0.6315789\n\nСодержимое матрицы можно просмотреть в более привычном табличном виде для этого откройте вкладку Environment и щелкните на строку с матрицей в разделе Data\nМатрицы, однако, не дотягивают по функциональности до представления таблиц, и не предназначены для объединения разнородных данных в один набор (как мы это сделали). Если вы присоедините к матрице столбец с названиями веток метро, система не выдаст сообщение об ошибке, но преобразует матрицу в текстовую, так как текстовый тип данных способен представить любой другой тип данных:\n\ncolors = c(\"Красная\", \"Зеленая\", \"Синяя\", \"Коричневая\", \"Оранжевая\")\nmm2=cbind(mm,colors)\nmm2  # обратите внимание на то, что вокруг чисел добавились кавычки\n##      lengths stations dens                colors      \n## [1,] \"28\"    \"20\"     \"0.714285714285714\" \"Красная\"   \n## [2,] \"40\"    \"21\"     \"0.525\"             \"Зеленая\"   \n## [3,] \"45\"    \"22\"     \"0.488888888888889\" \"Синяя\"     \n## [4,] \"19\"    \"12\"     \"0.631578947368421\" \"Коричневая\"\n## [5,] \"38\"    \"24\"     \"0.631578947368421\" \"Оранжевая\"\n\nПри попытке выполнить арифметическое выражение над прежде числовыми полями, вы получите сообщение об ошибке:\n\nmm2[,2]/mm2[,1]\n## Error in mm2[, 2]/mm2[, 1]: non-numeric argument to binary operator\n\n\n\n2.1.3 Массивы\nМассивы (arrays) — это многомерные структуры данных, с колчеством измерений 3 и более. Трехмерный массив представляет собой куб однородных данных. Для создания массива используется функция array():\n\nz = array(1:36, c(3,4,2)) # вектор значений для заполнения массива, а также длина каждого измерения\nprint(z)\n## , , 1\n## \n##      [,1] [,2] [,3] [,4]\n## [1,]    1    4    7   10\n## [2,]    2    5    8   11\n## [3,]    3    6    9   12\n## \n## , , 2\n## \n##      [,1] [,2] [,3] [,4]\n## [1,]   13   16   19   22\n## [2,]   14   17   20   23\n## [3,]   15   18   21   24\n\nМассивы возникают тогда, например, когда имеются многомерные данные, зафиксированные по регулярной сетке географичесих локаций (это типично для геофизических данных). При этом 2 измерения отвечают за местоположение, а третье измерение — за временной срез или показатель.",
    "crumbs": [
      "Основы",
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Структуры данных</span>"
    ]
  },
  {
    "objectID": "02-DataStructures.html#heterogeneous",
    "href": "02-DataStructures.html#heterogeneous",
    "title": "2  Структуры данных",
    "section": "2.2 Разнородные структуры данных",
    "text": "2.2 Разнородные структуры данных\n\n2.2.1 Фреймы данных\nФреймы данных — это обобщение понятия матрицы на данные смешанных типов. Фреймы данных - наиболее распространенный формат представления табличных данных. Для краткости мы иногда будем называть их просто фреймами.\n\nМы специально не используем для перевода слова data.frame термин ‘таблица’, поскольку таблица — это достаточно общая категория, которая описывает концептуальный способ упорядочивания данных. В том же языке R для представления таблиц могут быть использованы как минимум две структуры данных: фрейм данных (data.frame) и тиббл (tibble), доступный в соответствующем пакете. Мы не будем использовать тибблы в настоящем курсе, но после его освоения вы вполне сможете ознакомиться с ними самостоятельною\n\nДля создания фреймов данных используется функция data.frame():\n\ndf = data.frame(colors,lengths,stations)\ndf  # как мы видим, уже никаких кавычек вокруг чисел\n##       colors lengths stations\n## 1    Красная      28       20\n## 2    Зеленая      40       21\n## 3      Синяя      45       22\n## 4 Коричневая      19       12\n## 5  Оранжевая      38       24\n\nК фреймам также можно пристыковывать новые столбцы:\n\ndf = cbind(df, dens)\ndf\n##       colors lengths stations      dens\n## 1    Красная      28       20 0.7142857\n## 2    Зеленая      40       21 0.5250000\n## 3      Синяя      45       22 0.4888889\n## 4 Коричневая      19       12 0.6315789\n## 5  Оранжевая      38       24 0.6315789\n\nКогда фрейм данных формируется посредством функции data.frame() и cbind(), названия столбцов берутся из названий векторов. Обратите внимание на то, что листинге выше столбцы имеют заголовки, а строки — номера.\nКак и прежде, к столбцам и строкам можно обращаться по индексам:\n\ndf[2,2]\n## [1] 40\ndf[,3]\n## [1] 20 21 22 12 24\ndf[4,]\n##       colors lengths stations      dens\n## 4 Коричневая      19       12 0.6315789\n\nВы можете обращаться к отдельным столбцам фрейма данных по их названию, используя оператор $ (доллар):\n\ndf$lengths\n## [1] 28 40 45 19 38\ndf$stations\n## [1] 20 21 22 12 24\n\nТак же как и ранее, можно выполнять различные операции над столбцами:\n\nmax(df$stations)\n## [1] 24\ndf$lengths / df$stations\n## [1] 1.400000 1.904762 2.045455 1.583333 1.583333\n\nНазвания столбцов можно получить с помощью функции colnames()\n\ncolnames(df)\n## [1] \"colors\"   \"lengths\"  \"stations\" \"dens\"\n\nЧтобы присоединить строку, сначала можно создать фрейм данных из одной строки:\n\nrow = data.frame(\"Фиолетовая\", 40.5, 22, 22/45)\n\nДалее нужно убедиться, что столбцы в этом мини-фрейме называются также как и в том фрейме, куда мы хотим присоединить строку. Для этого нужно перезаписать результат, возвращаемый функцией colnames():\n\ncolnames(row) = colnames(df)\n\nОбратите внимание на синтаксис вышеприведенного выражения. Когда функция возвращает результат, она обнаруживает свойство самого объекта, и мы можем его перезаписать. После того как столбцы приведены в соответствие, можно присоединить новую строку:\n\ndf = rbind(df,row)\n\nЧтобы отсортировать фрейм данных по значению определенного поля, необходимо узнать порядок элементов в этом поле с помощью функции order() и проиндексировать им первое измерение фрейма:\n\ndf[order(df$lengths), ]\n\n      colors lengths stations      dens\n4 Коричневая    19.0       12 0.6315789\n1    Красная    28.0       20 0.7142857\n5  Оранжевая    38.0       24 0.6315789\n2    Зеленая    40.0       21 0.5250000\n6 Фиолетовая    40.5       22 0.4888889\n3      Синяя    45.0       22 0.4888889\n\n\nЧтобы отфильтровать фрейм данных по значению определенного поля, необходимо передать условие в первое измерение фрейма:\n\ndf[df$lengths &gt; 40, ]\n\n      colors lengths stations      dens\n3      Синяя    45.0       22 0.4888889\n6 Фиолетовая    40.5       22 0.4888889\n\n\nПоскольку названия столбцов хранятся как вектор из строк, мы можем их переделать:\n\ncolnames(df) = c(\"Цвет\",\"Длина\",\"Станции\",\"Плотность\")\ncolnames(df)\n## [1] \"Цвет\"      \"Длина\"     \"Станции\"   \"Плотность\"\n\nОбратимся по новому названию столбца:\n\ndf$Длина\n## [1] 28.0 40.0 45.0 19.0 38.0 40.5\n\nК фреймам данных, так же как и к однородным структурам, можно применять функцию summary() для получения описательных статистик. При этом отчет формируется по каждому столбцу:\n\nsummary(df)\n\n     Цвет               Длина          Станции        Плотность     \n Length:6           Min.   :19.00   Min.   :12.00   Min.   :0.4889  \n Class :character   1st Qu.:30.50   1st Qu.:20.25   1st Qu.:0.4979  \n Mode  :character   Median :39.00   Median :21.50   Median :0.5783  \n                    Mean   :35.08   Mean   :20.17   Mean   :0.5800  \n                    3rd Qu.:40.38   3rd Qu.:22.00   3rd Qu.:0.6316  \n                    Max.   :45.00   Max.   :24.00   Max.   :0.7143  \n\n\n\n\n2.2.2 Списки\nСписок — это наиболее общий тип контейнера в R. Список отличается от вектора тем, что он может содержать набор объектов произвольного типа. В качестве элементов списка могут быть числа, строки, вектора, матрицы, фреймы данных — и все это в одном контейнере. Списки используются чтобы комбинировать разрозненную информацию. Результатом выполнения многих функций является список.\nНапример, можно создать список из текстового описания фрейма данных, самого фрейма данных и обобщающей статистики по нему:\n\nd = \"Этот фрейм данных содержит данные по 6 линиям Московского метро\"\ns = summary(df)  # summary() выдает обобщающую статистику вектору, матрице или фрейму данных\n\nСооружаем список из трех элементов:\n\nmetrolist = list(d, df, s)\nmetrolist\n## [[1]]\n## [1] \"Этот фрейм данных содержит данные по 6 линиям Московского метро\"\n## \n## [[2]]\n##         Цвет Длина Станции Плотность\n## 1    Красная  28.0      20 0.7142857\n## 2    Зеленая  40.0      21 0.5250000\n## 3      Синяя  45.0      22 0.4888889\n## 4 Коричневая  19.0      12 0.6315789\n## 5  Оранжевая  38.0      24 0.6315789\n## 6 Фиолетовая  40.5      22 0.4888889\n## \n## [[3]]\n##      Цвет               Длина          Станции        Плотность     \n##  Length:6           Min.   :19.00   Min.   :12.00   Min.   :0.4889  \n##  Class :character   1st Qu.:30.50   1st Qu.:20.25   1st Qu.:0.4979  \n##  Mode  :character   Median :39.00   Median :21.50   Median :0.5783  \n##                     Mean   :35.08   Mean   :20.17   Mean   :0.5800  \n##                     3rd Qu.:40.38   3rd Qu.:22.00   3rd Qu.:0.6316  \n##                     Max.   :45.00   Max.   :24.00   Max.   :0.7143\n\nМожно дать элементам списка осмысленные названия при создании:\n\nmetrolist = list(desc = d, table = df, summary = s)\nmetrolist\n## $desc\n## [1] \"Этот фрейм данных содержит данные по 6 линиям Московского метро\"\n## \n## $table\n##         Цвет Длина Станции Плотность\n## 1    Красная  28.0      20 0.7142857\n## 2    Зеленая  40.0      21 0.5250000\n## 3      Синяя  45.0      22 0.4888889\n## 4 Коричневая  19.0      12 0.6315789\n## 5  Оранжевая  38.0      24 0.6315789\n## 6 Фиолетовая  40.5      22 0.4888889\n## \n## $summary\n##      Цвет               Длина          Станции        Плотность     \n##  Length:6           Min.   :19.00   Min.   :12.00   Min.   :0.4889  \n##  Class :character   1st Qu.:30.50   1st Qu.:20.25   1st Qu.:0.4979  \n##  Mode  :character   Median :39.00   Median :21.50   Median :0.5783  \n##                     Mean   :35.08   Mean   :20.17   Mean   :0.5800  \n##                     3rd Qu.:40.38   3rd Qu.:22.00   3rd Qu.:0.6316  \n##                     Max.   :45.00   Max.   :24.00   Max.   :0.7143\n\nТеперь можно обратиться к элементу списка по его названию:\n\nmetrolist$summary\n##      Цвет               Длина          Станции        Плотность     \n##  Length:6           Min.   :19.00   Min.   :12.00   Min.   :0.4889  \n##  Class :character   1st Qu.:30.50   1st Qu.:20.25   1st Qu.:0.4979  \n##  Mode  :character   Median :39.00   Median :21.50   Median :0.5783  \n##                     Mean   :35.08   Mean   :20.17   Mean   :0.5800  \n##                     3rd Qu.:40.38   3rd Qu.:22.00   3rd Qu.:0.6316  \n##                     Max.   :45.00   Max.   :24.00   Max.   :0.7143\n\nПоскольку summary сама является фреймом данных, из нее можно извлечь столбец:\n\nmetrolist$summary[,3]\n##                                                                         \n## \"Min.   :12.00  \" \"1st Qu.:20.25  \" \"Median :21.50  \" \"Mean   :20.17  \" \n##                                     \n## \"3rd Qu.:22.00  \" \"Max.   :24.00  \"\n\nК элементу списка можно также обратиться по его порядковому номеру или названию, заключив их в двойные квадратные скобки:\n\nmetrolist[[1]]\n## [1] \"Этот фрейм данных содержит данные по 6 линиям Московского метро\"\nmetrolist[[\"desc\"]]\n## [1] \"Этот фрейм данных содержит данные по 6 линиям Московского метро\"\n\nИспользование двойных скобок отличает списки от векторов.\nВызов функции summary() в приложении к списку выведет статистику по типам и количеству элементов списка:\n\nsummary(metrolist)\n\n        Length Class      Mode     \ndesc     1     -none-     character\ntable    4     data.frame list     \nsummary 24     table      character",
    "crumbs": [
      "Основы",
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Структуры данных</span>"
    ]
  },
  {
    "objectID": "02-DataStructures.html#factors",
    "href": "02-DataStructures.html#factors",
    "title": "2  Структуры данных",
    "section": "2.3 Факторы",
    "text": "2.3 Факторы\nПонятие фактора в терминологии R используется для обозначения категориальной (качественной) переменной. Как известно, такие переменные могут быть номинальными (с неопределенным порядком) и порядковыми (с заданным отношением порядка). Проблема взаимодействия с категориальными переменными заключается в том, что они могут приобретать разнообразные формы: быть выражены в виде чисел и строк. Эта форма может быть обманчивой. Например, модели самолетов Boeing и Sukhoi SuperJet обознаются числами (747, 100 и т.д.). Однако очевидно, что складывать и вычитать такие числа смысла нет, они являются формой представления номинальной переменной. Другой пример: названия месяцев записываются в виде строк. Если попытаться отсортировать месяцы цветения различных видов деревьев, то получится бессмысленный алфавитный порядок, в котором апрель следует за августом. В данном случае проблема заключается в том, что мы имеем дело с категориальной переменной, в которой задан порядок следования допустимых значений.\nВ географических данных категориальные переменные тоже достаточно распространены. К номинальной шкале измерений относятся всевозможные числовые коды: почтовые, ОКАТО и т.д. К порядковой шкале - административный статус населенного пункта, сила землетрясения по шкале Рихтера. Для того, чтобы соответствующие данные в среде R правильно обрабатывались статистическими функциями и отображались в виде подходящих графических способов, необходимо явным образом проинформировать об этом программу. Для этого и создаются факторы.\nФактор построен по принципу ассоциативного массива и является надстройкой над вектором, в которой каждому значению вектора присваивается некий код. Вы можете управлять этими кодами, а можете оставить их на усмотрение программы.\nНапример, каждая линия Московского метро имеет свой номер. Создадим небольшей фрейм данных с электродепо по интересующим нас веткам метро и рассчитаем по ним описательные статистики:\n\ndepots = data.frame(\n  depot = c('Северное', 'Черкизово', 'Сокол', 'Замоскворецкое', \n            'Братеево', 'Измайлово', 'Фили', 'Митино', \n            'Красная Пресня', 'Калужское', 'Свиблово'),\n  year_opened = c(1935, 1990, 1938, 1969, \n                  2014, 1950, 1962, 2016,\n                  1954, 1962, 1978),\n  line_number = c(1, 1, 2, 2, 2, 3, 3, 3, 5, 6, 6)\n)\nprint(depots)\n\n            depot year_opened line_number\n1        Северное        1935           1\n2       Черкизово        1990           1\n3           Сокол        1938           2\n4  Замоскворецкое        1969           2\n5        Братеево        2014           2\n6       Измайлово        1950           3\n7            Фили        1962           3\n8          Митино        2016           3\n9  Красная Пресня        1954           5\n10      Калужское        1962           6\n11       Свиблово        1978           6\n\nsummary(depots)\n\n    depot            year_opened    line_number   \n Length:11          Min.   :1935   Min.   :1.000  \n Class :character   1st Qu.:1952   1st Qu.:2.000  \n Mode  :character   Median :1962   Median :3.000  \n                    Mean   :1970   Mean   :3.091  \n                    3rd Qu.:1984   3rd Qu.:4.000  \n                    Max.   :2016   Max.   :6.000  \n\n\nКак видно, R посчитал нам средний номер линии метро - 3.091, что выглядит, мягко говоря, странновато. Чтобы этого не происходило, укажем в явном виде с помощью функции factor(), что номер линии метров является номинальной переменной:\n\ndepots$line_number = as.factor(depots$line_number)\nprint(depots$line_number)\n\n [1] 1 1 2 2 2 3 3 3 5 6 6\nLevels: 1 2 3 5 6\n\n\nМы видим, что у переменной появился дополнительный атрибут Levels, который отвечает за список уникальных значений номинальной переменной. Отношение порядка мы здесь не вводим, поскольку номер является условным обозначением.\nПопробуем теперь посчитать описательные статистики по переменной и таблице в целом:\n\nmean(depots$line_number)\n\n[1] NA\n\nsummary(depots)\n\n    depot            year_opened   line_number\n Length:11          Min.   :1935   1:2        \n Class :character   1st Qu.:1952   2:3        \n Mode  :character   Median :1962   3:3        \n                    Mean   :1970   5:1        \n                    3rd Qu.:1984   6:2        \n                    Max.   :2016              \n\n\nТеперь мы видим, что вместо стандартных статистик R для переменной line_number выдает таблицу частот, из которой ясно, что на первой линии два депо, на второй линии три депо и так далее.",
    "crumbs": [
      "Основы",
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Структуры данных</span>"
    ]
  },
  {
    "objectID": "02-DataStructures.html#vector_desc",
    "href": "02-DataStructures.html#vector_desc",
    "title": "2  Структуры данных",
    "section": "2.4 Описание структуры данных",
    "text": "2.4 Описание структуры данных\nДля описания структуры данных можно использовать две широко используемые диагностические функции: class() выведет тип структуры, а str() выведет детальную выписку по компонентам этой структуры:\n\nclass(depots) # тип объекта\n\n[1] \"data.frame\"\n\nstr(depots) # структура объекта\n\n'data.frame':   11 obs. of  3 variables:\n $ depot      : chr  \"Северное\" \"Черкизово\" \"Сокол\" \"Замоскворецкое\" ...\n $ year_opened: num  1935 1990 1938 1969 2014 ...\n $ line_number: Factor w/ 5 levels \"1\",\"2\",\"3\",\"5\",..: 1 1 2 2 2 3 3 3 4 5 ...",
    "crumbs": [
      "Основы",
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Структуры данных</span>"
    ]
  },
  {
    "objectID": "02-DataStructures.html#cycles",
    "href": "02-DataStructures.html#cycles",
    "title": "2  Структуры данных",
    "section": "2.5 Циклы",
    "text": "2.5 Циклы\nЦикл — это разновидность управляющей конструкции, предназначенная для организации многократного исполнения набора инструкций. В R циклы наиболее часто используются для пакетной обработки данных, ввода и вывода. Типичными примерами использования циклов являются чтение множества файлов входных данных, а также построение серий графиков и карт одного типа по различным данным. При этом обработка множества строк таблиц в R обычно организуется не средствами циклов, а средствами функций семейства lapply, о которых мы поговорим в главе, посвященной техникам программирования на R.\nЦиклы обычно связаны с проходом по элементам списка/вектора либо с созданием такого списка/вектора. Поэтому они излагаются в настоящей главе.\nВ R, как и во многих других языках программирования, существует несколько вариантов циклов. Первый вид циклов — это конструкция for с синтаксисом for (x in X) statement. Она означает, что:\n\nпеременная x должна пробежать по всем элементам последовательности X. В качестве последовательности может выступать любой вектор или список.\nкаждый раз, когда x будет присвоено значение очередного элемента из X, будет выполнено выражение statement, которое называют телом цикла. Соответственно, цикл выполнится столько раз, сколько элементов содержится в последовательности X.\n\n\nВыполнение тела цикла на каждом проходе называют итерацией.\n\nНапример, с помощью цикла можно вывести на экран числа от 1 до 10, по одному с каждой строки:\n\n## ЦИКЛЫ\n\nfor (i in 1:10) print(i)\n## [1] 1\n## [1] 2\n## [1] 3\n## [1] 4\n## [1] 5\n## [1] 6\n## [1] 7\n## [1] 8\n## [1] 9\n## [1] 10\n\nЕсли тело цикла содержит более одной инструкции R, оно должно быть заключено в фигурные скобки, иначе выполнится только первое выражение, а оставшиеся будут запущены один раз после выхода из цикла:\n\nfor (i in 1:10) {\n  a = factorial(i) # факториал i\n  b = exp(i) # e в степени i\n  print(a/b) # факториал растет быстрее экспоненты\n}\n## [1] 0.3678794\n## [1] 0.2706706\n## [1] 0.2987224\n## [1] 0.4395753\n## [1] 0.8085536\n## [1] 1.784702\n## [1] 4.595885\n## [1] 13.52585\n## [1] 44.78295\n## [1] 164.7473\n\nДругой вариант цикла организуется с помощью конструкции while, имеющей синтаксис while (condition) statement. Такая конструкция означает, что тело цикла будет выполняться, пока значение выражения condition (условия) равно TRUE. Как правило, в теле цикла обновляется некоторая переменная, которая участвует в проверке условия, и предполагается, что рано или поздно оно станет равным FALSE, что приведет к выходу из цикла. Например, вышеприведенный цикл, печатающий числа от 1 до 10, можно переписать на while следуюшим образом:\n\ni = 0\nwhile(i &lt; 10) {\n  i = i+1\n  print(i)\n}\n## [1] 1\n## [1] 2\n## [1] 3\n## [1] 4\n## [1] 5\n## [1] 6\n## [1] 7\n## [1] 8\n## [1] 9\n## [1] 10\n\nОбратите внимание на то, что мы внутри цикла обновляем значение переменной i.\n\nУвеличение значения переменной цикла называется инкрементом, а уменьшение — декрементом.\n\nОдной из самых распространенных ошибок программистов (особенно начинающих, но и професионалы ее не избегают) является забытая инструкция инкремента (или декремента) переменной цикла, в результате чего цикл становится бесконечным. В этом плане конструкция for более надежна.\nВ качестве примера приведем проход по столбцам фрейма данных и вычисление медианного значения для каждого столбца таблицы линий метро:\n\nn = ncol(df)\nmedians = vector('numeric', n)\n\nfor (i in 1:n) {\n  if(is.numeric(df[, i])){\n    medians[i] = median(df[, i])\n  } else {\n    medians[i] = NA\n  }\n}\ncolnames(df) # Переменные\n\n[1] \"Цвет\"      \"Длина\"     \"Станции\"   \"Плотность\"\n\nmedians # Медианные значения\n\n[1]         NA 39.0000000 21.5000000  0.5782895\n\n\nАналогичным образом можно осуществлять проход в цикле по строкам. Выведем информацию о длине каждой станции:\n\nk = nrow(df)\n\nfor (i in 1:k) {\n  cat(df[i, 'colors'],  'ветка метро имеет длину', \n      df[i, 'lengths'], 'км', fill = TRUE)\n}\n\n ветка метро имеет длину км\n ветка метро имеет длину км\n ветка метро имеет длину км\n ветка метро имеет длину км\n ветка метро имеет длину км\n ветка метро имеет длину км\n\n\nСуществуют специальные операторы, позволяющие принудительно прервать текущую итерацию цикла и перейти на следующую, а также выйти из цикла вообще. Они называются next и break. Они бывают полезны, когда в теле цикла может произойти событие, делающее невозможным (или бессмысленным) его дальнейшее выполнение. Например, мы можем выводить информацию об электродепо, имеющихся на линии метро с введенным пользователем номером, до тех пор, пока он не введет символ q. Чтобы цикл был бесконечным, используем специальную форму while (TRUE):\n\nwhile (TRUE) {\n  cat('Введите номер ветки метро:')\n  input = readline()\n  if (input == 'q')\n    break\n  else {\n    n = as.numeric(input)\n    if (!is.na(n))\n      depots[depots$line_number == n, ]\n  }\n}\n\nОператор next используется реже, так как в принципе он взаимозаменяем с конструкцией if-else. Он бывет удобен, когда в длинном цикле имеется несколько мест, в которых возможен переход на следующую итерацию. При использовании next последующий код нет необходимости табулировать и забирать в скобки. Следующие паттерны идентичны, но вариант с next позволяет остаться на том же уровне вложенности:\nПаттерн 1:\n\nwhile (...) {\n  if (condition1)\n    next\n  ... # сюда попадем, только если condition1 == FALSE\n  \n  if (condition2)\n    next\n  ... # сюда попадем, только если condition2 == FALSE\n}\n\nПаттерн 2:\n\nwhile (...) {\n  if (!condition1) {\n    ... # сюда попадем, только если condition1 == FALSE\n    \n    if (!condition2) {\n      ... # сюда попадем, только если condition2 == FALSE\n    }\n  }\n}",
    "crumbs": [
      "Основы",
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Структуры данных</span>"
    ]
  },
  {
    "objectID": "02-DataStructures.html#structures-detail",
    "href": "02-DataStructures.html#structures-detail",
    "title": "2  Структуры данных",
    "section": "2.6 Технические детали",
    "text": "2.6 Технические детали\nВнутреннюю структуру и размер объекта можно исследовать с помощью пакета lobstr. Например, посмотрим, как организован в пямяти объект metrolist:\n\nlibrary(lobstr)\nref(metrolist)\n\n█ [1:0x7f783cea8c98] &lt;named list&gt; \n├─desc = [2:0x7f783c9fcbd8] &lt;chr&gt; \n├─table = █ [3:0x7f786a86a7b8] &lt;df[,4]&gt; \n│         ├─Цвет = [4:0x7f783b0acb98] &lt;chr&gt; \n│         ├─Длина = [5:0x7f783b0acc78] &lt;dbl&gt; \n│         ├─Станции = [6:0x7f783b07c0e8] &lt;dbl&gt; \n│         └─Плотность = [7:0x7f783b07c388] &lt;dbl&gt; \n└─summary = [8:0x7f786b1845b0] &lt;table[,4]&gt; \n\nobj_size(metrolist)\n\n5.14 kB",
    "crumbs": [
      "Основы",
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Структуры данных</span>"
    ]
  },
  {
    "objectID": "02-DataStructures.html#review_structures",
    "href": "02-DataStructures.html#review_structures",
    "title": "2  Структуры данных",
    "section": "2.7 Краткий обзор",
    "text": "2.7 Краткий обзор\nДля просмотра презентации щелкните на ней один раз левой кнопкой мыши и листайте, используя кнопки на клавиатуре:\n\n\n\n\n\nПрезентацию можно открыть в отдельном окне или вкладке браузере. Для этого щелкните по ней правой кнопкой мыши и выберите соответствующую команду.",
    "crumbs": [
      "Основы",
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Структуры данных</span>"
    ]
  },
  {
    "objectID": "02-DataStructures.html#questions_tasks_vectors",
    "href": "02-DataStructures.html#questions_tasks_vectors",
    "title": "2  Структуры данных",
    "section": "2.8 Контрольные вопросы и упражнения",
    "text": "2.8 Контрольные вопросы и упражнения\n\n2.8.1 Вопросы\n\nНа какие две большие группы можно разделить структуры данных в R? Чем он отличаются?\nЧто такое вектор в языке R?\nКакие способы создания векторов существуют?\nМожно ли хранить в векторе данные разных типов?\nКак определить длину вектора?\nКак извлечь из вектора элемент по его индексу?\nКак извлечь из вектора множество элементов по их индексам?\nКак извлечь из вектора последний элемент?\nС помощью какой функции можно сгенерировать последовательность чисел или дат с заданным шагом?\nКак сгенерировать последовательность целых чисел с шагом 1, не прибегая к функциям?\nМожно ли применять к векторам арифметические операторы и математические функции? Что будет результатом их выполнения?\nС помощью какой функции можно отсортировать вектор? Как изменить порядок сортировки на противоположный?\nС помощью какой функции можно найти индекс элемента вектора по его значению? Что вернет функция, если этот элемент встречается в векторе несколько раз?\nКак работает функция ifelse() и для чего она используется?\nКак работает функция summary() и для чего она используется?\nКакая функция позволяет создать матрицу? По строкам или по столбцам заполняется матрица при использовании вектора как источника данных по умолчанию?\nКак извлечь элемент по его индексам из матрицы, массива, фрейма данных, списка?\nКак извлечь строку или столбец из матрицы или фрейма данных?\nС помощью какого специального символа можно обратиться к столбцу фрейма данных по его названию?\nКак получить или записать названия столбцов фрейма данных?\nКак получить или записать названия строк фрейма данных?\nКакая структура данных является результатом сортировки матрицы?\nКакая функция позволяет осуществить транспонирование матрицы?\nКакой оператор используется для умножения матриц? Каким критериям должны отвечать перемножаемые матрицы, чтобы эта операция была осуществима?\nКак добавить новый столбец в фрейм данных? Опишите несколько вариантов.\nКак добавить новую строку в фрейм данных?\nЧто произойдет, если к целочисленной матрице прибавить столбец, заполненный строками?\nКакая функция позволяет находить индексы элементов матрицы или фрейма данных по их значениям?\nЧто такое цикл и для каких сценариев обработки данных могут быть полезны циклы?\nПеречислите несколько способов организации циклов в R, необходимые ключевые слова и параметры.\nЧто такое инкремент и декремент?\nКакое ключевое слово позволяет прервать цикл и выйти из него принудительно?\nКакое ключевое слово позволяет прекратить текущую итерацию цикла и перейти сразу к новой итерации?\nЯвляются ли необходимыми фигурные скобки в случае когда цикл или условный оператор содержит только одно выражение? Что говорит об этом стиль программирования на R?\n\n\n\n2.8.2 Упражнения\n\nСоздайте вектор temp, в котором хранятся значения среднемесячных температур воздуха в городе Санкт-Петербурге (данные можно взять здесь). Напишите программный код, который вычисляет следующие вектора:\n\nколичественное изменение температуры от месяца к месяцу (в градусах)\nкачественное изменение температуры от месяца к месяцу ('потепление' или 'похолодание');\nномера зимних месяцев (со среднемесячной температурой ниже нуля);\nописательные статистики среднемесячных температур (summary);\n\nВыведите исходные и вычисленные данные в консоль (с пояснением что они означают).\n\nПодсказка: для вычисления разностей между элементами вектора используйте функцию diff().\n\nНа местности задан прямоугольник с координатами левого нижнего (x1, y1) и правого верхнего (x2, y2) угла. Напишите программу, которая размещает внутри этого прямоугольника случайным образом N точек и представляет результат в виде матрицы координат coords с двумя столбцами и N строками. Вызовите в конце программы plot(coords), чтобы посмотреть на результат. Координаты можно не вводить, а задать прямо в программе в виде переменных.\n\nПодсказка: координаты случайно размещенных точек имеют равномерное распределение. Вам необходимо сначала сформировать случайные векторы координат X и Y, и после этого объединить их в матрицу.\n\nВысотная поясность на северном склоне Западного Кавказа, согласно Большой Российской энциклопедии устроена следующим образом:\n\nдо 500 м — степь и лесостепь\nдо 800 м — низкогорные широколиственные леса (дуб, граб)\nдо 1300 м — среднегорные широколиственные леса (бук)\nдо 1600 м — смешанные леса (ель, пихта, бук)\nдо 2300 м — криволесия (береза, бук, клён)\nдо 2500 м — субальпийские и альпийские луга\nдо 3300 м — субнивальная зона (фрагментарная растительность)\nвыше (условно до 5000 м) — гляциально-нивальная зона\n\nСоздайте фрейм данных, включающий три столбца: минимальная высота пояса (Hmin), максимальная высота пояса (Hmax) и название высотного пояса (Zone). Минимальную высоту надо вычислить на основе максимальной, приняв, что для нижнего пояса она условно равна \\(400~м\\).\nНапишите программу, которая просит пользователя ввести высоту и возвращает высотный пояс, соответствующую введенной высоте (достаточно вывести строчку фрейма данных).\n\nПодсказка: Организуйте обход строчек фрейма данных с помощью цикла от \\(1\\) до \\(N\\), где \\(N\\) — количество строк. Искомый пояс будет найден, как только введенное значение станет меньше чем Hmax. После этого можно вывести результат на экран. Если введенное значение больше максимума в столбце Hmax или меньше \\(400\\), программа должна выдавать ошибку.\n\n[advanced] Решите задачу №3, используя только операции над векторами и поиск элементов, и не используя циклы.\n[advanced] Модифицируйте программу, написанную для решения задачи №2 таким образом, чтобы запретить точкам сближаться более чем на заданное расстояние k (это называется регулярным распределением с расстоянием ингибиции k). Сохраните результат в виде фрейма данных points со столбцами X, Y и D, где D – это расстояние до ближайшей точки. Выведите верхние строчки полученной таблицы в консоль, а также полученные точки с помощью команды plot(coords$X, coords$Y).\n\nПодсказка: вам придется генерировать в цикле по одной точке и проверять условие на каждой итерации до тех пор, пока вы не наберете требуемое количество точек. Задавайте значение k малым по отношению к размерам прямоугольника, чтобы избежать излишне долгого выполнения программы.\n\n\n\n\n\nСамсонов Т.Е. Визуализация и анализ географических данных на языке R. М.: Географический факультет МГУ, 2023. DOI: 10.5281/zenodo.901911",
    "crumbs": [
      "Основы",
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Структуры данных</span>"
    ]
  },
  {
    "objectID": "03-Tables.html#tables_prerequisites",
    "href": "03-Tables.html#tables_prerequisites",
    "title": "3  Таблицы",
    "section": "3.1 Предварительные требования",
    "text": "3.1 Предварительные требования\nДля работы по теме текущей лекции вам понадобятся пакеты из tidyverse, а также writexl. Установите их, используя следующую команду:\n\ninstall.packages('tidyverse')\ninstall.packages('writexl')\n\n\nВнимание: установка пакетов выполняется один раз из консоли. Вызов функции install.packages() не должен присутствовать в ваших скриптах\n\ntidyverse – это не самостоятельный пакет, а набор пакетов R, которые позволяют автоматизировать решение рутинных задач по обработке данных (то, что принято называть data science). В комплект tidyverse входят следующие пакеты:\n\n\n\n\n\n\n\nПакет\nНазначение\n\n\n\n\ntibble\nУсовершенствованный вариант фрейма данных\n\n\ndplyr\nГрамматика манипуляций над табличными данными\n\n\ntidyr\nПриведение таблиц в аккуратный вид, удобный для обработки\n\n\nreadr\nЧтение табличных данных из текстовых файлов\n\n\nreadxl\nЧтение табличных данных из файлов Microsoft Excel\n\n\nhaven\nЧтение табличных данных из файлов SPSS, Stata и SAS\n\n\npurrr\nФункциональное программирование\n\n\nstringr\nРабота со строками\n\n\nforcats\nАвтоматизация работы с факторами\n\n\nggplot2\nПостроение графиков на основе правил грамматики\n\n\n\nВы можете подключать эти пакеты по одному, или сделать их все доступными в текущей сессии R, используя команду library(tidyverse). В текущей лекции мы будем подключать их по мере необходмости, чтобы акцентировать внимание на принадлежности функций к соответствующим пакетам.\n\nВы можете вызвать функцию из любого пакета, не подключая его целиком в текущую сессию R. Это бывает особенно полезно, когда вы редко используете функции из пакета. В этом случае вызов функции будет выглядеть как package::function(), где package – название пакета, а function - название функции. Подобный синтаксис бывает особенно удобным, когда в разных пакетах имеются функции с одинаковым именем, и при вызове R использует не ту, которая нужна (по умолчанию будет использована функция из пакета, который был подключен позже).",
    "crumbs": [
      "Основы",
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Таблицы</span>"
    ]
  },
  {
    "objectID": "03-Tables.html#tables_datastructures",
    "href": "03-Tables.html#tables_datastructures",
    "title": "3  Таблицы",
    "section": "3.2 Структуры данных",
    "text": "3.2 Структуры данных\nСтандартным средством представления табличных данных в R являются фреймы данных (data.frame), кратко рассмотренные в предыдущей лекции. В современных пакетах типа tidyverse используется разновидность фрейма данных, которая называется тиббл (tibble).\nСоздать тиббл можно напрямую, либо путем конвертации фрейма данных:\n\nlibrary(readxl)\nlibrary(writexl)\nlibrary(tidyverse)\nlibrary(conflicted)\n\ntibble(\n  a = 1:3, \n  b = 1, \n  c = -1:1\n)\n\n# A tibble: 3 × 3\n      a     b     c\n  &lt;int&gt; &lt;dbl&gt; &lt;int&gt;\n1     1     1    -1\n2     2     1     0\n3     3     1     1\n\ndfr = data.frame(a = 1:3, b = 1,  c = -1:1)\nas_tibble(dfr)\n\n# A tibble: 3 × 3\n      a     b     c\n  &lt;int&gt; &lt;dbl&gt; &lt;int&gt;\n1     1     1    -1\n2     2     1     0\n3     3     1     1\n\n\nТиббл является расширением класса фрейма данных, то есть любая операция, применимая к фрейму, применима и к тибблу. Однако, тиббл поддерживает дополнительные возможности, которые оказываются очень удобны в анализе:\n\nПри выводе в консоль тиббл печатает только те столбцы, которые помещаются на экран, и только первые 10 строк (что позволяет избежать переполнения консоли при печати больших таблиц)\nТибблы поддерживают имена столбцов, которые недопустимы в фреймах данных (например, начинающиеся с цифры). Так называть столбцы, вообще говоря, неправильно, но это позволяет сохранить именно те названия, которые даны в исходных файлах. Например, географические таблицы часто содержат данные за разные года, и столбцы названы по этим годам.\nТибблы поддерживают внутренние группировки данных. Установив группировку по одной или нескольким переменным, можно эффективным и компактным путем считать агрегирующие статистики по группам измерений.\nТибблы можно создавать вручную не только по столбцам, но и по строкам.\n\nДля реализации последней возможности можно использовать функцию tribble() (переводится как transposed tibble — транспонированный тиббл), указав имена столбцов с помощью тильды (~):\n\ntribble(\n  ~a, ~b, ~c,\n   1,  1, -1,\n   2,  1,  0,\n   3,  1,  1\n)\n\n# A tibble: 3 × 3\n      a     b     c\n  &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt;\n1     1     1    -1\n2     2     1     0\n3     3     1     1\n\n\n\nВ данной и последующих лекциях понятия мы будем использовать понятия таблица, фрейм данных и тиббл как взаимозаменяемые.",
    "crumbs": [
      "Основы",
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Таблицы</span>"
    ]
  },
  {
    "objectID": "03-Tables.html#tables_reading",
    "href": "03-Tables.html#tables_reading",
    "title": "3  Таблицы",
    "section": "3.3 Чтение",
    "text": "3.3 Чтение\nСуществует множество способов получить набор табличных данных в текущей сессии R. Эти способы варьируются от загрузки данных из пакета до извлечения таблиц из текстовых документов и веб-страниц. В настоящей главе мы рассмотрим наиболее распространенные способы, нацеленные на работу с готовыми таблицами.\n\n3.3.1 Встроенные данные\nПакеты R часто содержат тестовые наборы данных. Эти данные, как правило, предназначены для ознакомления с возможностями пакета. Чтобы узнать, какие данные есть в пакете, вы можете вызвать функцию data(package = 'packagename'), где packagename — это имя интересующего вас пакета. Например, посмотрим, какие данные есть в пакете dplyr, который мы далее будем использовать для манипуляций с таблицами:\n\ndata(package = 'dplyr')\n\n\n\n\nДанные, доступные в пакете dplyr\n\n\nНа рисунке можно видеть перечень наборов данных и их краткие описания. Для загрузки набора данных передайте его название в качестве первого параметра функции data(). Ну-ка, что там с персонажами из Star Wars:\n\ndata(starwars, package = 'dplyr')\nstarwars\n\n# A tibble: 87 × 14\n   name     height  mass hair_color skin_color eye_color birth_year sex   gender\n   &lt;chr&gt;     &lt;int&gt; &lt;dbl&gt; &lt;chr&gt;      &lt;chr&gt;      &lt;chr&gt;          &lt;dbl&gt; &lt;chr&gt; &lt;chr&gt; \n 1 Luke Sk…    172    77 blond      fair       blue            19   male  mascu…\n 2 C-3PO       167    75 &lt;NA&gt;       gold       yellow         112   none  mascu…\n 3 R2-D2        96    32 &lt;NA&gt;       white, bl… red             33   none  mascu…\n 4 Darth V…    202   136 none       white      yellow          41.9 male  mascu…\n 5 Leia Or…    150    49 brown      light      brown           19   fema… femin…\n 6 Owen La…    178   120 brown, gr… light      blue            52   male  mascu…\n 7 Beru Wh…    165    75 brown      light      blue            47   fema… femin…\n 8 R5-D4        97    32 &lt;NA&gt;       white, red red             NA   none  mascu…\n 9 Biggs D…    183    84 black      light      brown           24   male  mascu…\n10 Obi-Wan…    182    77 auburn, w… fair       blue-gray       57   male  mascu…\n# ℹ 77 more rows\n# ℹ 5 more variables: homeworld &lt;chr&gt;, species &lt;chr&gt;, films &lt;list&gt;,\n#   vehicles &lt;list&gt;, starships &lt;list&gt;\n\n\n\nОбратите внимание, что после подключения набора данных он становится доступным в текущей сесси R именно с тем именем, с которым он сохранен в пакете\n\nЕсли вызвать функцию data() без параметров, будет выведен список данных со всех пакетов, которые подключены в текущей сессии R:\n\ndata()\n\n\n\n\nДанные, доступные в текущей сессии R\n\n\nПо умолчанию в RStudio всегда подключен пакет datasets, который устанавливается вместе с базовым дистрибутивом R. Если пакет подключен в текущую сессию, то можно получить набор данных по его имени, не указывая название пакета. Например, в пакете datasets есть набор данных quakes о землетрясениях на о. Фиджи:\n\ndata(quakes)\nhead(quakes) # просмотрим макушку таблицы\n\n     lat   long depth mag stations\n1 -20.42 181.62   562 4.8       41\n2 -20.62 181.03   650 4.2       15\n3 -26.00 184.10    42 5.4       43\n4 -17.97 181.66   626 4.1       19\n5 -20.42 181.96   649 4.0       11\n6 -19.68 184.31   195 4.0       12\n\n\nТаким образом, если вы используйете пакет dplyr в своей программе, данные о героях Звездных Войн можно загрузить не указывая пакет, т.к. он был ранее подключен через функцию library():\n\ndata(starwars)\n\n\n\n3.3.2 Текстовые таблицы\nТекстовые таблицы бывают, как правило, двух типов: с разделителем (CSV) и с фиксированной шириной столбца.\n\n3.3.2.1 Файлы с разделителем\nCSV (Comma-separated value) — общее название для формата представления таблиц в виде текстовых файлов, организованных по следующему принципу:\n\nКаждая строка в файле соответствует строке в таблице.\nЯчейки отделяются друг от друга символом-разделителем.\nЕсли ячейка пустая, то между соседними разделителями не должно быть никаких символов.\n\nСтандартным разделителем ячеек является запятая (,), а десятичным разделителем — точка (.). Однако это не является строгим правилом. Например, в ряде локалей (например, русской) запятая используется в качестве десятичного разделителя, поэтому колонки часто разделяют точкой с запятой (;).\nФормат CSV никак не оговаривает наличие заголовочной строки с названиями столбцов в начале файла — она может как отсутствовать, так и присутствовать. Поэтому при чтении таблиц из файлов необходимо информировать программу о наличии заголовка путем указания соответствующего параметра.\n\nЛюбая функция, используемая вами для чтения файлов, вне зависимости от пакета, который вы используете, как правило, содержит параметры, с помощью которых можно задать символы, отвечающие за десятичный разделитель и разделитель столбцов, а также наличие или отсутствие строки-заголовка и кодировку файла. Если таблица читается некорректно, ознакомьтесь со справкой к функции и при необходимости замените стандартные значения этих параметров на те, что соответствуют формату вашей таблицы.\n\nНапример, вот так выглядит текстовая таблица в формате CSV с данными по численности населения в Федеральных округах Российской Федерации за 2005 и 2010-2013 гг. (по данным Росстата):\nN,Region,Year05,Year10,Year11,Year12,Year13\n1,Центральный,4341,3761,3613,3651,3570\n2,Северо-Западный,3192,3088,2866,2877,2796\n3,Южный федеральный,1409,1446,1436,1394,1321\n4,Северо-Кавказский,496,390,397,395,374\n5,Приволжский,3162,2883,2857,2854,2849\n6,Уральский,1681,1860,1834,1665,1624\n7,Сибирский,2575,2218,2142,2077,1941\n8,Дальневосточный,871,870,821,765,713\nТаблицы в формате CSV можно прочесть как с помощью стандартных средств языка R, так и с помощью пакета readr, который входит в набор пакетов tidyverse. Мы будем использовать последние, а стандартные средства языка оставим на самостоятельное изучение.\nДля чтения таблиц с разделителем в readr имеется несколько функций:\n\nread_csv() читает файлы с разделителем запятой\nread_csv2() читайт файоы с разделителем точкой-с-запятой (может быть особенно актуально для русских файлов)\nread_tsv() читает файлы с разделителем табуляцией или пробелом\nread_delim() читает файлы с произвольным разделителем (указывается в качестве параметра)\n\nВышеуказанный файл сохранен с разделителем запятой, поэтому мы можем прочесть его посредством первой функции из списка:\n\n(okruga = read_csv('data/okruga.csv'))\n\n# A tibble: 8 × 7\n    `№` Регион            `2005` `2010` `2011` `2012` `2013`\n  &lt;dbl&gt; &lt;chr&gt;              &lt;dbl&gt;  &lt;dbl&gt;  &lt;dbl&gt;  &lt;dbl&gt;  &lt;dbl&gt;\n1     1 Центральный         4341   3761   3613   3651   3570\n2     2 Северо-Западный     3192   3088   2866   2877   2796\n3     3 Южный федеральный   1409   1446   1436   1394   1321\n4     4 Северо-Кавказский    496    390    397    395    374\n5     5 Приволжский         3162   2883   2857   2854   2849\n6     6 Уральский           1681   1860   1834   1665   1624\n7     7 Сибирский           2575   2218   2142   2077   1941\n8     8 Дальневосточный      871    870    821    765    713\n\n\nКак видно, функции пакета readr выдают диагностическую информацию о том, к какому типу были приведены столбцы таблицы при чтении. Помимо этого, первая строка была использована в качестве заголовочной.\n\n\n3.3.2.2 Файлы с фиксированной шириной столбца\nВ файлах с фиксированной шириной на каждый столбец резервируется определенное количество символов. При этом данные выравниваются по правому краю, а короткие строки отбиваются слева пробелами. Такой формат часто используется в численных моделях (например, метеорологических) для представления входных данных или результатов расчетов. Например, файл ниже содержит данные об энергии ветра (\\(Вт/м^2\\)) на высотах 50 и 110 м по точкам вдоль побережья Черного моря:\n           1   43.500000       28.000000       111.05298       178.41447    \n           2   43.500000       28.500000       187.38620       301.05331    \n           3   44.000000       28.500000       168.82031       271.22421    \n           4   44.500000       28.500000       157.22586       252.59746    \n           5   44.500000       29.000000       189.46452       304.39597    \n           6   45.000000       29.000000       170.40709       273.77536    \n           7   45.000000       29.500000       198.92389       319.58777    \n           8   45.500000       29.500000       188.64406       303.07242    \n           9   46.000000       30.000000       180.10541       289.35379    \n          10   46.000000       30.500000       207.91818       334.03564\nДля чтения таких файлов в readr есть функции:\n\nread_fwf() читает файлы с фиксированной шириной столбца, позволяя задавать ширины столбцов (через fwf_widths()) или начальные позиции каждого столбца (через fwf_positions())\nread_table() читает наиболее распространенный вариант файла с фиксированной шириной столбца, в котором колонки разделены пробелами. Позиции столбцов определяются автоматически, что очень удобно.\n\nПрочитаем вышеприведенный файл с данными о ветровой энергии:\n\n(wenergy = read_table('data/wind_energy.txt', col_names = c('id', 'lat', 'lon', 'energy50', 'energy110')))\n\n# A tibble: 92 × 5\n      id   lat   lon energy50 energy110\n   &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt;    &lt;dbl&gt;     &lt;dbl&gt;\n 1     1  43.5  28       111.      178.\n 2     2  43.5  28.5     187.      301.\n 3     3  44    28.5     169.      271.\n 4     4  44.5  28.5     157.      253.\n 5     5  44.5  29       189.      304.\n 6     6  45    29       170.      274.\n 7     7  45    29.5     199.      320.\n 8     8  45.5  29.5     189.      303.\n 9     9  46    30       180.      289.\n10    10  46    30.5     208.      334.\n# ℹ 82 more rows\n\n\n\n\n\n3.3.3 Таблицы Microsoft Excel\nДля чтения таблиц Microsoft Excel, так же как и для текcтовых файлов, существуют множество пакетов, таких как xlsx, openxlsx и readxl.\nD настоящем курсе мы будем пользоваться пакетом readxl, поскольку он не имеет внешних зависимостей, а его функции концептуально идентичны функциям пакета readr. Прочтем данные о лесовосстановлении (в тысяч га), полученные из регионального ежегодника Росстата за 2017 год. Эта таблица содержит колонку с названием субъекта и еще 8 колонок с данными по годам. Поскольку в таблице есть пропущенные значения, необходимо определить типы столбцов (в противном случае они могут быть определены как текстовые):\n\n(reforest = read_excel('data/reforest.xlsx', \n                       col_types = c('text', rep('numeric', 8))))\n\n# A tibble: 89 × 9\n   Region                `2005` `2010` `2011` `2012` `2013` `2014` `2015` `2016`\n   &lt;chr&gt;                  &lt;dbl&gt;  &lt;dbl&gt;  &lt;dbl&gt;  &lt;dbl&gt;  &lt;dbl&gt;  &lt;dbl&gt;  &lt;dbl&gt;  &lt;dbl&gt;\n 1 Российская Федерация   812.   812.   860    842.   872.   863    803.   840. \n 2 Центральный федераль…   52.6   62.7   60.9   60.3   70.9   71.2   72.6   77  \n 3 Белгородская область     0.4    0.1    0.3    0.3    0.4    0.4    0.2    0.2\n 4 Брянская область         2.9    2.8    3      3.2    3.5    3.3    3.1    3  \n 5 Владимирская область     4.4    5.3    5.7    6      7.1    5.9    6      4.9\n 6 Воронежская область      1.1    1.1    1.8    3      2.7    2.7    2.6    2.3\n 7 Ивановская область       2.1    1.6    2.2    3.1    4      4.8    4.6    4.2\n 8 Калужская область        2.2    2.3    2.3    2.5    2.4    3.1    3.2    3.2\n 9 Костромская область     10     25.2   11     11.8   15.3   13.6   15.1   16.4\n10 Курская область          0.5    0.3    0.4    0.6    0.6    0.6    0.5    0.4\n# ℹ 79 more rows\n\n\n\n\n3.3.4 Параметры\nФункции пакетов readr и readxl имеют идентичный набор параметров, позволяющих управлять процедурой чтения данных (многоточие используется вместо перечисления параметров):\n\nskip = n позволяет пропустить первые n строк таблицы (например, если в них содержатся какие-то комментарии)\ncol_names = FALSE позволяет не интерпретировать первую строку как заголовочную (вместо этого она будет читаться как строка с данными)\ncol_names = c(...) позволяет задать имена столбцов (удобно, если в файле они длинные)\ncol_types = cols(...) позволяет задать типы столбцов (необходимо, если функция неправильно определяет их сама)\nna = '-' позволяет указать символ, который используется для указания пропущенных значений (в данном случае указан прочерк-дефис)\nlocale = locale(...) управляет локалью (в том числе позволяет указать кодировку файла)\n\n\nСтандартной кодировкой для представления текста в UNIX-подобных системах (Ubuntu, macOS и т.д.) является UTF-8 (Unicode), в русскоязычных версиях Windows — CP1251 (Windows-1251). Текстовый файл CSV, созданный в разных операционных системах, будет по умолчанию сохраняться в соответствующей кодировке, если вы не указали ее явным образом. Если при загрузке таблицы в R вы видите вместо текста нечитаемые символы — кракозябры — то, скорее всего, вы читаете файл не в той кодировке, в которой он был сохранен. Если вы не знаете, что такое кодировка и Юникод, то вам сюда\n\nПо умолчанию файлы читаются в той кодировке, которая соответствует операционной системе, на которой запущен R. Если файл создан в другой кодировке, придется указать ее при чтении. Например, вы пользуетесь macOS (UTF-8), а ваш коллега — Windows (CP1251), то для чтения созданного им файла вам, скорее всего, понадобится указать что-то вроде locale = locale(encoding = 'CP1251')",
    "crumbs": [
      "Основы",
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Таблицы</span>"
    ]
  },
  {
    "objectID": "03-Tables.html#tables_view",
    "href": "03-Tables.html#tables_view",
    "title": "3  Таблицы",
    "section": "3.4 Просмотр",
    "text": "3.4 Просмотр\nДля просмотра фрейма данных в консоли RStudio вы можете использовать несколько опций. Пусть наш фрейм данных называется reforest. Тогда:\n\nprint(reforest) — выводит фрейм в консоль целиком (можно написать просто tab в консоли).\nhead(reforest, n) — отбирает первые \\(n\\) строк фрейма\ntail(reforest, n) — отбирает последние \\(n\\) строк фрейма\n\nПо умолчанию для функций head() и tail() \\(n=6\\). Обычно этот параметр опускают, поскольку нужно просмотреть только первые несколько строк и шести вполне достаточно. Если вы напечатаете в консоли head(reforest) или tail(reforest), то для выбранных строк будет вызвана функция print(), аналогично выводу всего фрейма:\n\n# ПРОСМОТР ТАБЛИЦЫ\nprint(reforest)\n## # A tibble: 89 × 9\n##    Region                `2005` `2010` `2011` `2012` `2013` `2014` `2015` `2016`\n##    &lt;chr&gt;                  &lt;dbl&gt;  &lt;dbl&gt;  &lt;dbl&gt;  &lt;dbl&gt;  &lt;dbl&gt;  &lt;dbl&gt;  &lt;dbl&gt;  &lt;dbl&gt;\n##  1 Российская Федерация   812.   812.   860    842.   872.   863    803.   840. \n##  2 Центральный федераль…   52.6   62.7   60.9   60.3   70.9   71.2   72.6   77  \n##  3 Белгородская область     0.4    0.1    0.3    0.3    0.4    0.4    0.2    0.2\n##  4 Брянская область         2.9    2.8    3      3.2    3.5    3.3    3.1    3  \n##  5 Владимирская область     4.4    5.3    5.7    6      7.1    5.9    6      4.9\n##  6 Воронежская область      1.1    1.1    1.8    3      2.7    2.7    2.6    2.3\n##  7 Ивановская область       2.1    1.6    2.2    3.1    4      4.8    4.6    4.2\n##  8 Калужская область        2.2    2.3    2.3    2.5    2.4    3.1    3.2    3.2\n##  9 Костромская область     10     25.2   11     11.8   15.3   13.6   15.1   16.4\n## 10 Курская область          0.5    0.3    0.4    0.6    0.6    0.6    0.5    0.4\n## # ℹ 79 more rows\nhead(reforest)\n## # A tibble: 6 × 9\n##   Region                 `2005` `2010` `2011` `2012` `2013` `2014` `2015` `2016`\n##   &lt;chr&gt;                   &lt;dbl&gt;  &lt;dbl&gt;  &lt;dbl&gt;  &lt;dbl&gt;  &lt;dbl&gt;  &lt;dbl&gt;  &lt;dbl&gt;  &lt;dbl&gt;\n## 1 Российская Федерация    812.   812.   860    842.   872.   863    803.   840. \n## 2 Центральный федеральн…   52.6   62.7   60.9   60.3   70.9   71.2   72.6   77  \n## 3 Белгородская область      0.4    0.1    0.3    0.3    0.4    0.4    0.2    0.2\n## 4 Брянская область          2.9    2.8    3      3.2    3.5    3.3    3.1    3  \n## 5 Владимирская область      4.4    5.3    5.7    6      7.1    5.9    6      4.9\n## 6 Воронежская область       1.1    1.1    1.8    3      2.7    2.7    2.6    2.3\ntail(reforest)\n## # A tibble: 6 × 9\n##   Region                 `2005` `2010` `2011` `2012` `2013` `2014` `2015` `2016`\n##   &lt;chr&gt;                   &lt;dbl&gt;  &lt;dbl&gt;  &lt;dbl&gt;  &lt;dbl&gt;  &lt;dbl&gt;  &lt;dbl&gt;  &lt;dbl&gt;  &lt;dbl&gt;\n## 1 Хабаровский край        107.    70.2   68.7   67.2   58.4   50.5   59.6   60.3\n## 2 Амурская область         33.3   29.8   32.2   33.6   35.5   37.7   28.5   27.7\n## 3 Магаданская область       2.7    2.6    2.6    2.8    3      2.5    0.4   NA  \n## 4 Сахалинская область      13.1   12.7   12.5    4.6    4.7    4.9    4.7    4.1\n## 5 Еврейская автономная …    2.9   NA      2.6    2.5    2.3   NA     NA      2.4\n## 6 Чукотский автономный …    0.3   NA     NA     NA     NA     NA     NA     NA\n\nRStudio предоставляет графический интерфейс для просмотра таблиц, в котором таблицу можно сортировать и фильтровать. Чтобы его активировать, надо вызвать функцию View():\n\nView(tab)\n\nПоскольку функции head() и tail() возвращают строки с хвоста или начала фрейма данных, их можно и подать на вход функции View():\n\nView(head(reforest, 3))\n\n\nКак правило, не следует оставлять вызовы функции View() в тексте законченной программы. Это приведет к тому, что при запуске будут открываться новые вкладки с просмотром таблиц, что может раздражать пользователя (в том числе и вас самих). Используйте View() для вывода окончательного результата в конце программы или при отладке программы. Все вызовы View() в программе можно легко закомментировать или раскомментировать, выполнив поиск с заменой 'View(' на '# View(' и наоборот.",
    "crumbs": [
      "Основы",
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Таблицы</span>"
    ]
  },
  {
    "objectID": "03-Tables.html#tables_elements",
    "href": "03-Tables.html#tables_elements",
    "title": "3  Таблицы",
    "section": "3.5 Столбцы, строки и ячейки",
    "text": "3.5 Столбцы, строки и ячейки\n\n3.5.1 Названия\nСтолбцы, строки и ячейк представляют собой основные структурные элементы фрейма данных или тиббла. Перед тем как мы поднимемся на уровень выше и рассмотрим обобщенные операции преобразования таблиц, необходимо посмотреть, как извлекать структурные элементы таблиц.\nСтолбцы и строки таблицы имеют названия, которые можно читать и записывать с помощью функций colnames() и rownames():\n\n# Чтение названий столбцов и строк\ncolnames(okruga)\n\n[1] \"№\"      \"Регион\" \"2005\"   \"2010\"   \"2011\"   \"2012\"   \"2013\"  \n\nrownames(okruga)\n\n[1] \"1\" \"2\" \"3\" \"4\" \"5\" \"6\" \"7\" \"8\"\n\n# Замена названий столбцов и строк\ncolnames(okruga) &lt;- c(\"N\", \"Region\", \"Year05\", \"Year10\", \"Year11\", \"Year12\", \"Year13\")\nprint(okruga)\n\n# A tibble: 8 × 7\n      N Region            Year05 Year10 Year11 Year12 Year13\n  &lt;dbl&gt; &lt;chr&gt;              &lt;dbl&gt;  &lt;dbl&gt;  &lt;dbl&gt;  &lt;dbl&gt;  &lt;dbl&gt;\n1     1 Центральный         4341   3761   3613   3651   3570\n2     2 Северо-Западный     3192   3088   2866   2877   2796\n3     3 Южный федеральный   1409   1446   1436   1394   1321\n4     4 Северо-Кавказский    496    390    397    395    374\n5     5 Приволжский         3162   2883   2857   2854   2849\n6     6 Уральский           1681   1860   1834   1665   1624\n7     7 Сибирский           2575   2218   2142   2077   1941\n8     8 Дальневосточный      871    870    821    765    713\n\n\nНазвания строк редко заменяются, поскольку с точки зрения реляционной алгебры большого смысла они не имеют.\n\n\n3.5.2 Обращение к столбцам\nК столбцу можно обращаться по номеру и названию (с помощью оператора $ или в кавычках внутри скобок). Если вы указываете в квадратных скобках номер без запятой, он трактуется именно как номер столбца, а не строки. Тип возвращаемого значения зависит от синтаксиса:\n\nобращение через $ возвращает вектор;\nобращение в скобках с запятой к одному столбцу возвращает вектор;\nобращение в скобках с запятой к нескольким столбцам возвращает фрейм данных;\nобращение в скобках без запятой возвращает фрейм данных.\n\nНесколько примеров:\n\n# Один столбец - результат зависит от запятой\nokruga$Year05      # столбец в виде вектора\nokruga[, \"Year05\"] # столбец в виде вектора\nokruga[, 2]        # столбец в виде вектора\n\nokruga[\"Year05\"] # столбец в виде фрейма данных/тиббла\nokruga[2]        # столбец в виде фрейма данных/тиббла\n\n# Несколько столбцов - всегда фрейм данных/тиббл\nokruga[, c(1, 4)]\nokruga[, c(\"Region\", \"Year11\")]\nokruga[c(\"Region\", \"Year11\")]\nokruga[c(1, 4)]\n\n\n\n3.5.3 Обращение к строкам\nОбращаться к строкам можно по их номерам. В этом случае в качестве индекса можно передать номер (номера) интересующих строк, либо вектор логических значений, в котором интересующие строки помечены как TRUE, а остальные — FALSE (в этом случае длина вектора должна равняться количеству строк в таблице):\n\nokruga[5, ] # Одна строка\nokruga[2:4, ] # Несколько строк\nokruga[okruga$Year10 &gt; 2000, ] # Несколько строк через TRUE/FALSE\n\n\nВ отличие от работы со столбцами, выбор строк всегда возвращает таблицу (фрейм или тиббл).\n\n\n\n3.5.4 Обращение к ячейкам\nЧтобы выбрать конкретные ячейки в таблице, необходимо задать оба измерения:\n\nokruga[2:3, c(\"Year11\", \"Year12\")]\n\n# A tibble: 2 × 2\n  Year11 Year12\n   &lt;dbl&gt;  &lt;dbl&gt;\n1   2866   2877\n2   1436   1394\n\n\nОбратите внимание на то, что при этом возвращаются все комбинации строк и столбцов. То есть, нельзя выбрать ячейки 2,\"Year11\" и 3,\"Year2\" — вместе с ними также будут выбраны ячейки 3,\"Year11\" и 2,\"Year2\". Впрочем, подобные задачи возникают довольно редко",
    "crumbs": [
      "Основы",
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Таблицы</span>"
    ]
  },
  {
    "objectID": "03-Tables.html#tables_manipuilations",
    "href": "03-Tables.html#tables_manipuilations",
    "title": "3  Таблицы",
    "section": "3.6 Преобразования",
    "text": "3.6 Преобразования\n\n3.6.1 Грамматика манипуляций\nЕсли проанализировать наиболее типичные манипуляции, которые осуществляются над таблицами, то их окажется совсем немного. К таким манипуляциям относятся выбор переменных, фильтрация строк, сортировка, вычисление новых столбцов, агрегирующие статистики и группировка.\nВсе эти задачи можно решать стандартными средствами R (и мы увидим, как это делается). Однако некоторые из них достаточно громоздки в реализации (например, группировка). К счастью, экосистема R предлагает готовые средства, позволяющие справляться с подобными задачами простым и элегантным путем. Эти средства предоставляет пакет dplyr (произносится как deep liar — ‘диплáйер’), входящий в набор инструментов tidyverse.\nВ основе конецепции dplyr лежит понятие о грамматике табличных манипуляций, которая включает в себя ограниченное число наиболее используемых операций, а также ряд вспомогательных функций.\nОсновные функции пакета dplyr представлены в таблице ниже:\n\n\n\nФункция\nНазначение\n\n\n\n\nselect()\nВыбор переменных по их названиям\n\n\ndplyr::filter()\nВыбор строк по заданному критерию (запросу)\n\n\narrange()\nУпорядочение по указанным переменным\n\n\nmutate()\nВычисление новых переменных (мутирование)\n\n\nsummarise()\nАгрегирование значений переменных\n\n\ngroup_by()\nГруппировка строк (для последующего агрегирования)\n\n\n\nКак можно видеть, этих функций совсем немного. Дополнительно к ним пакет dplyr содержит еще множество вспомогательных функций, которые применяются при выполнении основных манипуляций.\nРассмотрим применение этих функций на примере работы с таблицей по восстановлению лесного фонда в регионах России. Для начала переименуем столбцы с годами, чтобы их названия начинались с буквы y:\n\nold_names = colnames(reforest)\ncolnames(reforest) = c(old_names[1], paste('y', old_names[2:9], sep = ''))\n\nНачнем с выбора нужных переменных, используя select(). Оставим только название региона и данные за 2010 и 2015 гг:\n\n(rdf = select(reforest, Region, y2010, y2015))\n\n# A tibble: 89 × 3\n   Region                        y2010 y2015\n   &lt;chr&gt;                         &lt;dbl&gt; &lt;dbl&gt;\n 1 Российская Федерация          812.  803. \n 2 Центральный федеральный округ  62.7  72.6\n 3 Белгородская область            0.1   0.2\n 4 Брянская область                2.8   3.1\n 5 Владимирская область            5.3   6  \n 6 Воронежская область             1.1   2.6\n 7 Ивановская область              1.6   4.6\n 8 Калужская область               2.3   3.2\n 9 Костромская область            25.2  15.1\n10 Курская область                 0.3   0.5\n# ℹ 79 more rows\n\n\nТу же самую задачу можно решить от противного — указать со знаком - те столбцы, которые надо убрать:\n\n(rdf = select(reforest, -y2005, -y2011:-y2014, -y2016))\n\n# A tibble: 89 × 3\n   Region                        y2010 y2015\n   &lt;chr&gt;                         &lt;dbl&gt; &lt;dbl&gt;\n 1 Российская Федерация          812.  803. \n 2 Центральный федеральный округ  62.7  72.6\n 3 Белгородская область            0.1   0.2\n 4 Брянская область                2.8   3.1\n 5 Владимирская область            5.3   6  \n 6 Воронежская область             1.1   2.6\n 7 Ивановская область              1.6   4.6\n 8 Калужская область               2.3   3.2\n 9 Костромская область            25.2  15.1\n10 Курская область                 0.3   0.5\n# ℹ 79 more rows\n\n\nОбратите внимание на то, что можно указывать еще и диапазоны названий столбцов, если они идут друг за другом.\n\nНазвания столбцов в функциях dplyr указываются без кавычек, что позволяет сделат код проще и читаемее. Этот прием называется квотацией, с ним мы познакомимся подробнее в следующей лекции.\n\nЧтобы осуществить фильтрацию, необходимо задать условие, накладываемое на строки. Текущая таблица содержит данные по субъектам, федеральным округам и России в целом. Поскольку данные по округам и стране являются избыточными (их можно получить путем агрегирования данных по субъектам), выполним фильтрацию таблицы, убрав строки, в которых содержатся слова Федерация и федеральный округ. Для этого используем функцию str_detect() из пакета stringr, который также входит в tidyverse:\n\nflt = !stringr::str_detect(rdf$Region, 'Федерация|федеральный округ') # готовим фильтр для строк\n(regdf = dplyr::filter(rdf, flt)) # применяем фильтр\n\n# A tibble: 80 × 3\n   Region               y2010 y2015\n   &lt;chr&gt;                &lt;dbl&gt; &lt;dbl&gt;\n 1 Белгородская область   0.1   0.2\n 2 Брянская область       2.8   3.1\n 3 Владимирская область   5.3   6  \n 4 Воронежская область    1.1   2.6\n 5 Ивановская область     1.6   4.6\n 6 Калужская область      2.3   3.2\n 7 Костромская область   25.2  15.1\n 8 Курская область        0.3   0.5\n 9 Липецкая область       0.4   1.1\n10 Московская область     2.7   8.9\n# ℹ 70 more rows\n\n\nУсловие можно прописать непосредственно при вызове dplyr::filter(). Например, выберем регионы, в которых объем лесовосстановительных работ в 2015 году был более 50 тыс. га:\n\ndplyr::filter(regdf, y2015 &gt; 50)\n\n# A tibble: 4 × 3\n  Region                y2010 y2015\n  &lt;chr&gt;                 &lt;dbl&gt; &lt;dbl&gt;\n1 Архангельская область  39.4  57.6\n2 Красноярский край      49    50.4\n3 Иркутская область      80.4 117. \n4 Хабаровский край       70.2  59.6\n\n\nДля сортировки таблицы посредством arrange() необходимо указать столбцы, по которым будет осуществлено упорядочение строк. Чаще всего это один столбец, например y2015:\n\narrange(regdf, y2015) # по возрастанию\n\n# A tibble: 80 × 3\n   Region                              y2010 y2015\n   &lt;chr&gt;                               &lt;dbl&gt; &lt;dbl&gt;\n 1 Орловская область                     0     0.1\n 2 Астраханская область                  0.1   0.1\n 3 Кабардино-Балкарская Республика       0.1   0.1\n 4 Карачаево-Черкесская Республика       0.2   0.1\n 5 Республика Северная Осетия – Алания  NA     0.1\n 6 Ставропольский край                   0.4   0.1\n 7 Белгородская область                  0.1   0.2\n 8 Тульская область                      0.1   0.2\n 9 Магаданская область                   2.6   0.4\n10 Курская область                       0.3   0.5\n# ℹ 70 more rows\n\narrange(regdf, desc(y2015)) # по убыванию\n\n# A tibble: 80 × 3\n   Region                y2010 y2015\n   &lt;chr&gt;                 &lt;dbl&gt; &lt;dbl&gt;\n 1 Иркутская область      80.4 117. \n 2 Хабаровский край       70.2  59.6\n 3 Архангельская область  39.4  57.6\n 4 Красноярский край      49    50.4\n 5 Вологодская область    32.3  49  \n 6 Республика Коми        33.3  36.7\n 7 Пермский край          22.9  32.5\n 8 Кировская область      26    31.1\n 9 Амурская область       29.8  28.5\n10 Томская область         9.3  25.6\n# ℹ 70 more rows\n\n\nДобавление новых переменных (столбцов) осуществляется посредством mutate(). Например, определим, как изменился объем лесовосстановительных работ в 2015 году по сравнению с 2010 годом:\n\n(regdf = mutate(regdf, delta = y2015 - y2010))\n\n# A tibble: 80 × 4\n   Region               y2010 y2015   delta\n   &lt;chr&gt;                &lt;dbl&gt; &lt;dbl&gt;   &lt;dbl&gt;\n 1 Белгородская область   0.1   0.2   0.1  \n 2 Брянская область       2.8   3.1   0.300\n 3 Владимирская область   5.3   6     0.7  \n 4 Воронежская область    1.1   2.6   1.5  \n 5 Ивановская область     1.6   4.6   3    \n 6 Калужская область      2.3   3.2   0.9  \n 7 Костромская область   25.2  15.1 -10.1  \n 8 Курская область        0.3   0.5   0.2  \n 9 Липецкая область       0.4   1.1   0.7  \n10 Московская область     2.7   8.9   6.2  \n# ℹ 70 more rows\n\n\nСуществует редко используемая разновидность мутирования, при которой сохраняются только столбцы, указанные в параметрах. Она называется transmute() — по сути это комбинация mutate() и select(). Если вы хотите просто сохранить какой-то из столбцов, то укажите его через оператор равенства:\n\ntransmute(regdf, Region = Region, delta = y2015 - y2010) # сохраняем только Region и delta\n\n# A tibble: 80 × 2\n   Region                 delta\n   &lt;chr&gt;                  &lt;dbl&gt;\n 1 Белгородская область   0.1  \n 2 Брянская область       0.300\n 3 Владимирская область   0.7  \n 4 Воронежская область    1.5  \n 5 Ивановская область     3    \n 6 Калужская область      0.9  \n 7 Костромская область  -10.1  \n 8 Курская область        0.2  \n 9 Липецкая область       0.7  \n10 Московская область     6.2  \n# ℹ 70 more rows\n\n\nВы можете выполнять агрегирование данных и вычислять суммы, средние значения и т.д. используя summarise(). После того как мы избавились от избыточных данных в таблице, мы всегда можем получить их через агрегирование. Например, посчитаем суммарный, минимальный и максимальный объем лесовосстановительных работ по всей стране:\n\nsummarise(regdf, \n          sumforest = sum(y2015, na.rm = TRUE),\n          minforest = min(y2015, na.rm = TRUE),\n          maxforest = max(y2015, na.rm = TRUE))\n\n# A tibble: 1 × 3\n  sumforest minforest maxforest\n      &lt;dbl&gt;     &lt;dbl&gt;     &lt;dbl&gt;\n1      801.       0.1      117.\n\n\nКак правило, summarise() используется в паре с агрегирующими функциями, которые берут вектор значений и возвращают одно значение. К таким функциям относятся стандартные операции типа min(), max(), mean(), sum() и т.д. В пакете dplyr также имеются полезные агрегирующие функции:\n\nn() вычисляет количество элементов.\nn_distinct() вычисляет количество уникальных элементов.\nfirst(x), last(x) и nth(x, n) извлекают, соответственно, первый, последний и n-ный элемент (они бывают особенно удобны, если вы сортируете строки по какому-то критерию).\n\nДостаточно часто данные надо агрегировать не по всей таблице, а по группам измерений. В этом случае сначала делается группировка, затем агрегирование данных в каждой группе. Предположим, что нам нужно найти регион с наибольшим объемом лесовосставновительных работ в каждом Федеральном округе. Для этого нам потребуется:\n\nДополнить каждую строку региона информацией о принадлежности к федеральному округу\nСгруппировать субъекты по федеральным округам — Отсортировать каждую группу по убыванию значения поля\nВзять первую строку в каждой группе\nОбъединить строки в одну таблицу\n\nДля начала вернемся на этап, когда мы избавлялись от федеральных округов в таблице. Поскольку в исходной таблице данные были упорядочены по округам, эту информацию можно использовать для создания нового столбца с названием округа каждого субъекта. В этом нам поможет функция fill() из пакета tidyr:\n\nflt2 = stringr::str_detect(rdf$Region, 'федеральный округ') # ищем округа\n(rdf2 = mutate(rdf, okrug = if_else(flt2, Region, NA))) # перенесем названия округов в новый столбец\n\n# A tibble: 89 × 4\n   Region                        y2010 y2015 okrug                        \n   &lt;chr&gt;                         &lt;dbl&gt; &lt;dbl&gt; &lt;chr&gt;                        \n 1 Российская Федерация          812.  803.  &lt;NA&gt;                         \n 2 Центральный федеральный округ  62.7  72.6 Центральный федеральный округ\n 3 Белгородская область            0.1   0.2 &lt;NA&gt;                         \n 4 Брянская область                2.8   3.1 &lt;NA&gt;                         \n 5 Владимирская область            5.3   6   &lt;NA&gt;                         \n 6 Воронежская область             1.1   2.6 &lt;NA&gt;                         \n 7 Ивановская область              1.6   4.6 &lt;NA&gt;                         \n 8 Калужская область               2.3   3.2 &lt;NA&gt;                         \n 9 Костромская область            25.2  15.1 &lt;NA&gt;                         \n10 Курская область                 0.3   0.5 &lt;NA&gt;                         \n# ℹ 79 more rows\n\n(rdf2 = tidyr::fill(rdf2, okrug)) # заполним все пустые строчки предыдущим значением\n\n# A tibble: 89 × 4\n   Region                        y2010 y2015 okrug                        \n   &lt;chr&gt;                         &lt;dbl&gt; &lt;dbl&gt; &lt;chr&gt;                        \n 1 Российская Федерация          812.  803.  &lt;NA&gt;                         \n 2 Центральный федеральный округ  62.7  72.6 Центральный федеральный округ\n 3 Белгородская область            0.1   0.2 Центральный федеральный округ\n 4 Брянская область                2.8   3.1 Центральный федеральный округ\n 5 Владимирская область            5.3   6   Центральный федеральный округ\n 6 Воронежская область             1.1   2.6 Центральный федеральный округ\n 7 Ивановская область              1.6   4.6 Центральный федеральный округ\n 8 Калужская область               2.3   3.2 Центральный федеральный округ\n 9 Костромская область            25.2  15.1 Центральный федеральный округ\n10 Курская область                 0.3   0.5 Центральный федеральный округ\n# ℹ 79 more rows\n\n(regdf = dplyr::filter(rdf2, flt)) # оставим только регионы\n\n# A tibble: 80 × 4\n   Region               y2010 y2015 okrug                        \n   &lt;chr&gt;                &lt;dbl&gt; &lt;dbl&gt; &lt;chr&gt;                        \n 1 Белгородская область   0.1   0.2 Центральный федеральный округ\n 2 Брянская область       2.8   3.1 Центральный федеральный округ\n 3 Владимирская область   5.3   6   Центральный федеральный округ\n 4 Воронежская область    1.1   2.6 Центральный федеральный округ\n 5 Ивановская область     1.6   4.6 Центральный федеральный округ\n 6 Калужская область      2.3   3.2 Центральный федеральный округ\n 7 Костромская область   25.2  15.1 Центральный федеральный округ\n 8 Курская область        0.3   0.5 Центральный федеральный округ\n 9 Липецкая область       0.4   1.1 Центральный федеральный округ\n10 Московская область     2.7   8.9 Центральный федеральный округ\n# ℹ 70 more rows\n\n\nТеперь мы можем определить регион с максимальным объемом лесовосстановительных работ в каждом Федеральном округе, используя вспомогательную функцию row_number() которая возвращает номер для каждой строки таблицы:\n\nregdf_gr = group_by(regdf, okrug)\nregdf_arr = arrange(regdf_gr, desc(y2015))\n(regdf_res = dplyr::filter(regdf_arr, row_number() == 1))\n\n# A tibble: 8 × 4\n# Groups:   okrug [8]\n  Region                y2010 y2015 okrug                              \n  &lt;chr&gt;                 &lt;dbl&gt; &lt;dbl&gt; &lt;chr&gt;                              \n1 Иркутская область      80.4 117.  Сибирский федеральный округ        \n2 Хабаровский край       70.2  59.6 Дальневосточный федеральный округ  \n3 Архангельская область  39.4  57.6 Северо-Западный федеральный округ  \n4 Пермский край          22.9  32.5 Приволжский федеральный округ      \n5 Свердловская область   25.6  24.4 Уральский федеральный округ        \n6 Костромская область    25.2  15.1 Центральный федеральный округ      \n7 Волгоградская область   1.8   0.9 Южный федеральный округ            \n8 Чеченская Республика    0.9   0.7 Северо-Кавказский федеральный округ\n\n\ngroup_by() часто используется в паре с summarise(). Например мы можем получить суммарный объем лесовосстановительных работ по каждому федеральному округу:\n\nregdf_gr = group_by(regdf, okrug)\nsummarise(regdf_gr, total = sum(y2015, na.rm = TRUE))\n\n# A tibble: 8 × 2\n  okrug                               total\n  &lt;chr&gt;                               &lt;dbl&gt;\n1 Дальневосточный федеральный округ   108. \n2 Приволжский федеральный округ       110. \n3 Северо-Западный федеральный округ   194. \n4 Северо-Кавказский федеральный округ   1.1\n5 Сибирский федеральный округ         259. \n6 Уральский федеральный округ          52.9\n7 Центральный федеральный округ        72.7\n8 Южный федеральный округ               3.3\n\n\nИспользование dplyr целым обладает рядом преимуществ по сравнению с применением стандартных средств R:\n\nвызов функций с говорящими названиями операции более понятными;\nкод выглядит более чистым и легко читаемым за счет отсутствия обращений к фреймам данных через квадратные скобки, доллары и «закавыченные» названия переменных;\nкод с использованием функций dplyr часто оказывается короче, чем его традиционные аналоги;\nоперации dplyr можно выстраивать в конвейеры с помощью пайп-оператора |&gt;.\n\nПоследнюю возможность мы рассмотрим в следующем параграфе.\n\n\n3.6.2 Конвейер манипуляций\nВ предыдущем параграфе было показано как найти регион-лидер в каждой группе по выбранному показателю. При этом, несмотря на то что интерес представляет только конечный результат, нам пришлось шесть раз осуществить запись промежуточного результата в соответствующую переменную. Чтобы избежать подобного многословия в программах, в R реализована возможность организации конвейера манипуляций (pipeline) посредством использования пайп-оператора |&gt;.\nПайп-оператор |&gt; предназначен для компактной и наглядной записи последовательностей обработки данных. Работает он следующим образом:\n\nx |&gt; f эквивалентно f(x)\nx |&gt; f(y) эквивалентно f(x, y)\nx |&gt; f |&gt; g |&gt; h эквивалентно h(g(f(x)))\n\nКоротко говоря, пайп оператор берет результат вычисления выражения слева и подставляет его в качестве первого аргумента в выражение справа. С помощью этого оператора вышеприведенный код по нахождению региона-лидера можно записать так:\n\nregdf = rdf |&gt; \n  mutate(okrug = if_else(flt2, Region, NA)) |&gt; \n  tidyr::fill(okrug) |&gt; \n  dplyr::filter(flt)\n\nleaders = regdf |&gt; \n  group_by(okrug) |&gt; \n  arrange(desc(y2015)) |&gt; \n  dplyr::filter(row_number() == 1)\n\nprint(leaders)\n## # A tibble: 8 × 4\n## # Groups:   okrug [8]\n##   Region                y2010 y2015 okrug                              \n##   &lt;chr&gt;                 &lt;dbl&gt; &lt;dbl&gt; &lt;chr&gt;                              \n## 1 Иркутская область      80.4 117.  Сибирский федеральный округ        \n## 2 Хабаровский край       70.2  59.6 Дальневосточный федеральный округ  \n## 3 Архангельская область  39.4  57.6 Северо-Западный федеральный округ  \n## 4 Пермский край          22.9  32.5 Приволжский федеральный округ      \n## 5 Свердловская область   25.6  24.4 Уральский федеральный округ        \n## 6 Костромская область    25.2  15.1 Центральный федеральный округ      \n## 7 Волгоградская область   1.8   0.9 Южный федеральный округ            \n## 8 Чеченская Республика    0.9   0.7 Северо-Кавказский федеральный округ\n\nЕсли бы мы попытались написать те же последовательности операций одним выражением в традиционной «матрешечной» парадигме, это выглядело так:\n\nregdf = dplyr::filter(\n           tidyr::fill(\n             mutate(\n               rdf,\n               okrug = if_else(flt2, Region, NA)\n             ),\n             okrug\n           ),\n           flt\n         )\n\nresult = dplyr::filter(\n           arrange(\n             group_by(\n               regdf, \n               okrug\n             ),\n             desc(y2015)\n           ),\n           row_number() == 1\n         )\n\nВыглядит несколько устрашающе. К тому же, читать такой код приходится задом наперед (изнутри наружу), чтобы понять последовательность действий. Таким образом, организация конвейера манипуляций с использованием пайп-оператора позволяет:\n\nупорядочить операции по обработке данных слева направо (в противоположность направлению изнутри наружу);\nизбежать вложенных вызовов функций (матрёшки);\nминимизировать количество переменных для храненния промежуточных результатов;\nупростить добавление новых операций по обработке данных в любое место последовательности.\n\n\nПайп-оператор |&gt; можно быстро набрать в RStudio, нажав клавиатурное сочетание Ctrl + Shift + M (Cmd + Shift + M на помпьютерах Mac)\n\n\n\n3.6.3 Преобразование структуры\nОдни и те же данные можно предствить в табличной форме по-разному. Одна форма будет удобной для ручного заполнения таблицы. Другая форма будет удобной для программной обработки и анализа. Большинство же остальных форм не будут оптимальными ни для того, ни для другого. Наш курс посвящен автоматизированной обработке данных на языке R, поэтомы мы должны определить, какая форма таблицы удобна для этих целей.\nВ экосистеме R такие данные принято называть «аккуратными», или по-английски tidy data. Аккуратные таблицы отвечают следующим требованиям:\n\nКаждый столбец представляет переменную\nКаждая строка представляет измерение\nКаждая ячейка представляет значение\n\nС некоторой долей условности можно говорить, что это третья нормальная форма реляционного отношения.\nТаблицы, с которыми мы работали до настоящего момента в этой главе, не отвечают данным требованиям. В частности, данные по лесовосстановлению содержат столбцы, в которых приведены данные за соответствующие года. Это одна переменная, разбитая на несколько столбцов. При этом год измерения является второй переменной. Такая форма удобна для заполнения и визуального анализа, но неудобна для программной обработки. Предположим, что нам надо найти все регионы, у которых в промежутке между 2012 и 2015 годами лесовосстановительные работы хотя бы в один год не производились (их объем был равен нулю). В текущей форме таблицы нам придется сделать 4 условия — по одному на каждый год-столбец. Это при том, что мы должны быть уверены, что все промежуточные года в таблице присутствуют. Приведя таблицу к аккуратному виду, мы можем решить задачу более компактно, отправив всего 2 запроса: один на год измерения и второй на величину показателя.\nПриведение таблицы к аккуратному виду можно сделать, используя функции из пакета tidyr. Основных функций в этом пакете всего две1:\n\npivot_longer() берет несколько колонок и преобразует их к виду «ключ—значение»: широкие таблицы становятся длинными.\npivot_wider() берет две колонки, соответствующие ключу и значению, и распределяет их на множество колонок: длинные таблицы становятся широкими.\n\nПомимо этого, есть еще 2 полезных функции, которые позволяют «распиливать» или «склеивать» колонки:\n\nseparate() разделяет колонку на несколько колонок, используя заданный символ-разделитель или позицию.\nunite() скливает несколько колонок, используя заданный символ-разделитель.\n\nФункция pivot_longer() имеет четыре основных параметра:\n\ndata — входная таблица (фрейм данных или тиббл)\ncols — перечисление столбцов, которые необходимо подвергнуть преобразованию\nnames_to — имя нового столбца, который будет хранить ключи (бывшие названия столбцов)\nvalues_to — имя нового столбца, который будет хранить значения\n\nРассмотрим на примере таблицы reforest приведение к аккуратному виду:\n\n(reforest_tidy = reforest |&gt; \n    pivot_longer(cols = y2005:y2016, \n                 names_to = 'year', \n                 values_to = 'value'))\n\n# A tibble: 712 × 3\n   Region                        year  value\n   &lt;chr&gt;                         &lt;chr&gt; &lt;dbl&gt;\n 1 Российская Федерация          y2005 812. \n 2 Российская Федерация          y2010 812. \n 3 Российская Федерация          y2011 860  \n 4 Российская Федерация          y2012 842. \n 5 Российская Федерация          y2013 872. \n 6 Российская Федерация          y2014 863  \n 7 Российская Федерация          y2015 803. \n 8 Российская Федерация          y2016 840. \n 9 Центральный федеральный округ y2005  52.6\n10 Центральный федеральный округ y2010  62.7\n# ℹ 702 more rows\n\n\n\nОбратите внимание на то, что параметры names_to и values_to надо передавать как строки, поскольку они содержат еще не существующие объекты.\n\nПолученный результат еще не вполне пригоден для анализа, поскольку в переменной year мы имеем строковые значения, начинающиеся с y. Чтобы избавиться от этого префикса, можно при вызове pivot_longer() указать параметр names_prefix. Поскольку по умолчанию ключи конвертируются в строковый столбец, а год — это целочисленное значение, следует дополнительно указать параметр names_ptypes. Помимо этого, конвертации подвергаются все столбцы, кроме Region — это означает, что можно пойти от обратного в параметре cols. Резюмируя перечисленные соображения, вышеприведенный вызов можно оптимизировать следующим образом:\n\n(reforest_tidy2 = reforest |&gt; \n    pivot_longer(cols = -Region, \n                 names_to = 'year',\n                 names_prefix = 'y',\n                 names_transform = list(year = as.integer),\n                 values_to = 'value'))\n\n# A tibble: 712 × 3\n   Region                         year value\n   &lt;chr&gt;                         &lt;int&gt; &lt;dbl&gt;\n 1 Российская Федерация           2005 812. \n 2 Российская Федерация           2010 812. \n 3 Российская Федерация           2011 860  \n 4 Российская Федерация           2012 842. \n 5 Российская Федерация           2013 872. \n 6 Российская Федерация           2014 863  \n 7 Российская Федерация           2015 803. \n 8 Российская Федерация           2016 840. \n 9 Центральный федеральный округ  2005  52.6\n10 Центральный федеральный округ  2010  62.7\n# ℹ 702 more rows\n\n\nЕсли по какой-то причине вам уже досталась таблица, в которой в ячейках сцеплены несколько сущностей, разделить их можно с помощью функции separate(). Вышеприведенный тиббл reforest_tidy можно “довести до ума” последовательным вызовом separate(), select() и mutate():\n\n(reforest_tidy = reforest_tidy |&gt; \n  separate(year, c('y', 'year'), 1) |&gt; \n  select(-y) |&gt; \n  mutate(year = as.integer(year)))\n\n# A tibble: 712 × 3\n   Region                         year value\n   &lt;chr&gt;                         &lt;int&gt; &lt;dbl&gt;\n 1 Российская Федерация           2005 812. \n 2 Российская Федерация           2010 812. \n 3 Российская Федерация           2011 860  \n 4 Российская Федерация           2012 842. \n 5 Российская Федерация           2013 872. \n 6 Российская Федерация           2014 863  \n 7 Российская Федерация           2015 803. \n 8 Российская Федерация           2016 840. \n 9 Центральный федеральный округ  2005  52.6\n10 Центральный федеральный округ  2010  62.7\n# ℹ 702 more rows\n\n\nТеперь можно выполнять любые запросы, комбинирующие год измерения и величину показателя. Найдем субъекты, в которых с 2012 по 2015 год не производились лесовосстановительные работы:\n\nreforest_tidy |&gt; dplyr::filter(year &gt; 2011 & year &lt; 2016 & value == 0)\n\n# A tibble: 2 × 3\n  Region             year value\n  &lt;chr&gt;             &lt;int&gt; &lt;dbl&gt;\n1 Орловская область  2013     0\n2 Республика Адыгея  2014     0\n\n\n“Длинная” форма данных удобна для программного анализа, но может быть неудобна для ручного редактирования, визуальной оценки или передачи в другие программы, ожидающие на входе данные в “широком” формате. В этих случаях будет полезна функция pivot_wider(), которая по своему действию противоположна pivot_longer(). Данная функция имеет три основных параметра:\n\ndata — входная таблица (фрейм данных или тиббл)\nnames_from — имя переменной, из которой будут браться названия столбцов\nvalues_from — имя переменной, из которой будут браться значения в ячейках\n\nПреобразуем ранее удлиненную таблицу к “широкому” виду:\n\n(reforest = reforest_tidy |&gt; \n   pivot_wider(names_from = year, values_from = value))\n\n# A tibble: 89 × 9\n   Region                `2005` `2010` `2011` `2012` `2013` `2014` `2015` `2016`\n   &lt;chr&gt;                  &lt;dbl&gt;  &lt;dbl&gt;  &lt;dbl&gt;  &lt;dbl&gt;  &lt;dbl&gt;  &lt;dbl&gt;  &lt;dbl&gt;  &lt;dbl&gt;\n 1 Российская Федерация   812.   812.   860    842.   872.   863    803.   840. \n 2 Центральный федераль…   52.6   62.7   60.9   60.3   70.9   71.2   72.6   77  \n 3 Белгородская область     0.4    0.1    0.3    0.3    0.4    0.4    0.2    0.2\n 4 Брянская область         2.9    2.8    3      3.2    3.5    3.3    3.1    3  \n 5 Владимирская область     4.4    5.3    5.7    6      7.1    5.9    6      4.9\n 6 Воронежская область      1.1    1.1    1.8    3      2.7    2.7    2.6    2.3\n 7 Ивановская область       2.1    1.6    2.2    3.1    4      4.8    4.6    4.2\n 8 Калужская область        2.2    2.3    2.3    2.5    2.4    3.1    3.2    3.2\n 9 Костромская область     10     25.2   11     11.8   15.3   13.6   15.1   16.4\n10 Курская область          0.5    0.3    0.4    0.6    0.6    0.6    0.5    0.4\n# ℹ 79 more rows\n\n\n\nОбратите внимание на то, что параметры names_from и values_from можно задавать как имена переменных, а не как строки.\n\nВ качестве примера операции с широкой таблицей вычислим разности по сравнению с предыдущим годом:\n\ndiffs = reforest |&gt; select(`2011`:`2016`) -\n        reforest |&gt; select(`2010`:`2015`)\n\ndiffs |&gt; \n  mutate(Region = reforest$Region) |&gt; \n  select(Region, `2011`:`2016`) |&gt; \n  head() # Посмотрим шапку таблицы\n\n                         Region 2011  2012 2013 2014  2015 2016\n1          Российская Федерация 48.5 -18.3 30.6 -9.3 -60.1 37.0\n2 Центральный федеральный округ -1.8  -0.6 10.6  0.3   1.4  4.4\n3          Белгородская область  0.2   0.0  0.1  0.0  -0.2  0.0\n4              Брянская область  0.2   0.2  0.3 -0.2  -0.2 -0.1\n5          Владимирская область  0.4   0.3  1.1 -1.2   0.1 -1.1\n6           Воронежская область  0.7   1.2 -0.3  0.0  -0.1 -0.3",
    "crumbs": [
      "Основы",
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Таблицы</span>"
    ]
  },
  {
    "objectID": "03-Tables.html#tables_join",
    "href": "03-Tables.html#tables_join",
    "title": "3  Таблицы",
    "section": "3.7 Соединение",
    "text": "3.7 Соединение\nДанные, с которыми мы работаем, часто распределены по нескольким таблицам. Если возникает задача их совместного использования (сравнения, вычисления производных показателей), таблицы необходимо соединить.\nВ процессе соединения в обеих таблицах находятся строки, соответствующие одному и тому же измерению (например, региону). После этого столбцы второй таблицы пристыковываются к столбцам первой таблицы, а строки — к соответствующим строкам (мутирующее соединение), либо же происходит фильтрация строк первой таблицы на основе нахождения соответствующих строк во второй таблице (фильтрующее соединение).\nЧтобы найти соответствие, в обеих таблицах должен быть по крайней мере один столбец, идентифицирующий каждую строку. В первой таблице он называется первичным ключом (primary key), во второй таблице — внешним ключом (foreign key).\nДля выполнения соедининия в пакете dplyr имеется несколько функций.\nМутирующее соединение:\n\ninner_join(x, y, by = ) возвращает все строки из x, для которых имеются соответствующие строки в y, а также все столбцы из x и y.\nleft_join(x, y, by = ) возвращает все строки из x, а также все столбцы из x и y. Строки в x, для которых не найдены соответствия в y, будут иметь значения NA в присоединенных столбцах\nright_join(x, y, by = ) возвращает все строки из y, а также все столбцы из x и y. Строки в y, для которых не найдены соответствия в x, будут иметь значения NA в присоединенных столбцах\nfull_join(x, y, by = ) возвращает все строки и колонки из x и y. В строках, для которых не найдено соответствие ячейки присоединяемых стольков будут заполнены значениями NA\n\nФильтрующее соединение:\n\nsemi_join(x, y, by = ) возвращает все строки из x, для которых имеются соответствующие строки в y, а также все столбцы из x\nanti_join(x, y, by = ) возвращает все строки из x, для которыхне найдены соответствующие строки в y, а также все столбцы из x\n\nРассмотрим соединение таблиц на примере данных по лесовосстановлению и заготовкам древесины. Наша задача — оценить количество гектаров восстанавливаемой лесной площади (в га) на тысячу кубометров лесозаготовок (и таким образом оценить эффективность лесовосстановительных мероприятий).\nПодгрузим таблицу по лесозаготовкам:\n\n(timber = read_excel('data/timber.xlsx', \n                    col_types = c('text', rep('numeric', 8))) |&gt; \n  dplyr::filter(!stringr::str_detect(Регион, 'Федерация|федеральный округ')))\n\n# A tibble: 75 × 9\n   Регион               `2010` `2011` `2012` `2013` `2014` `2015` `2016` Место\n   &lt;chr&gt;                 &lt;dbl&gt;  &lt;dbl&gt;  &lt;dbl&gt;  &lt;dbl&gt;  &lt;dbl&gt;  &lt;dbl&gt;  &lt;dbl&gt; &lt;dbl&gt;\n 1 Белгородская область   30.4   39.6   27.7   37.4   34.1   45.6   30.4    60\n 2 Брянская область      614.   616.   824.   850.   793.   739.   750.     27\n 3 Владимирская область 1078   1335   1236   1142   1165   1272   1252      20\n 4 Воронежская область    73.6   69.5   68.6   47.9   81.1   86.6   53.5    58\n 5 Ивановская область    130.   140.   200.   199.   231.   326.   421.     38\n 6 Калужская область     274.   244.   192.   198.   183    145.   204      44\n 7 Костромская область  3000   3332   2797   2692   2564   2186   2515      14\n 8 Курская область        22.8   55.4   49.7   50.1   65.9   74.6   80.7    55\n 9 Липецкая область      163.   139     49.7   42.6   50.1   73.1   87.8    53\n10 Московская область    126.   265.   299.   108.    15.6   NA     NA      74\n# ℹ 65 more rows\n\n\nПриведем ее к аккуратному виду, который соответствует виду таблицы по лесовосстановлению:\n\n(timber_tidy = timber |&gt; \n  gather(year, harvest, `2010`:`2016`) |&gt; \n  transmute(Region = Регион,\n            year = as.numeric(year),\n            harvest = harvest))\n\n# A tibble: 525 × 3\n   Region                year harvest\n   &lt;chr&gt;                &lt;dbl&gt;   &lt;dbl&gt;\n 1 Белгородская область  2010    30.4\n 2 Брянская область      2010   614. \n 3 Владимирская область  2010  1078  \n 4 Воронежская область   2010    73.6\n 5 Ивановская область    2010   130. \n 6 Калужская область     2010   274. \n 7 Костромская область   2010  3000  \n 8 Курская область       2010    22.8\n 9 Липецкая область      2010   163. \n10 Московская область    2010   126. \n# ℹ 515 more rows\n\n\nТеперь нам осталось присоединить данные по лесозаготовкам к таблице по лесовосстановлению, используя имя региона (Region) и год (year) в качестве ключевых полей.\nДля этого мы используем функцию inner_join(), поскольку нас интересует сравнение по тем годам, для которых имеются данные в обеих таблицах:\n\n(compare = reforest_tidy |&gt; \n  inner_join(timber_tidy, by = c(\"Region\" = \"Region\", \"year\" = \"year\")))\n\n# A tibble: 511 × 4\n   Region                year value harvest\n   &lt;chr&gt;                &lt;dbl&gt; &lt;dbl&gt;   &lt;dbl&gt;\n 1 Белгородская область  2010   0.1    30.4\n 2 Белгородская область  2011   0.3    39.6\n 3 Белгородская область  2012   0.3    27.7\n 4 Белгородская область  2013   0.4    37.4\n 5 Белгородская область  2014   0.4    34.1\n 6 Белгородская область  2015   0.2    45.6\n 7 Белгородская область  2016   0.2    30.4\n 8 Брянская область      2010   2.8   614. \n 9 Брянская область      2011   3     616. \n10 Брянская область      2012   3.2   824. \n# ℹ 501 more rows\n\n\nНаконец, вычислим искомое отношние и упорядочим регионы по году (возрастание) и отношению (убывание):\n\n(compare = compare |&gt; \n   mutate(ratio = 1000 * value / harvest) |&gt; \n   select(Region, year, ratio, value, harvest) |&gt; \n   arrange(year, desc(ratio)))\n\n# A tibble: 511 × 5\n   Region                    year ratio value harvest\n   &lt;chr&gt;                    &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt;   &lt;dbl&gt;\n 1 Ставропольский край       2010 182.    0.4     2.2\n 2 Ростовская область        2010 149.    1.5    10.1\n 3 Магаданская область       2010 118.    2.6    22  \n 4 Сахалинская область       2010  63.8  12.7   199. \n 5 Республика Саха (Якутия)  2010  63.3  58     917. \n 6 Республика Тыва           2010  61.8   4.4    71.2\n 7 Мурманская область        2010  52.2   3      57.5\n 8 Волгоградская область     2010  48.4   1.8    37.2\n 9 Камчатский  край          2010  38.9   5.2   134. \n10 Амурская область          2010  38.5  29.8   773. \n# ℹ 501 more rows\n\n\nИз этой таблицы видно, что площадь восстанавливаемых лесов далеко не всегда пропорциональна объему заготовок необработанной древесины.",
    "crumbs": [
      "Основы",
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Таблицы</span>"
    ]
  },
  {
    "objectID": "03-Tables.html#tables_write",
    "href": "03-Tables.html#tables_write",
    "title": "3  Таблицы",
    "section": "3.8 Запись",
    "text": "3.8 Запись\nЗапись файлов в текстовом формате можно осуществить посредством функций из пакета readr, таких как write_delim(), write_csv() и write_tsv(). Базовый синтаксис их предельно прост:\n\nwrite_csv(compare, \"data/output/timber_compare.csv\")\n\nДля записи таблиц Microsoft Excel можно использовать возможности пакета writexl:\n\nwrite_xlsx(compare, \"data/output/timber_compare.xlsx\")\n\nКаждая из этих функций содержит ряд дополнительных параметров, позволяющих управлять внешним видом выгружаемых таблиц. Более подробно с ними вы можете ознакомиться, вызвав справку для соответствующей функции.",
    "crumbs": [
      "Основы",
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Таблицы</span>"
    ]
  },
  {
    "objectID": "03-Tables.html#tables_rules",
    "href": "03-Tables.html#tables_rules",
    "title": "3  Таблицы",
    "section": "3.9 Рекомендации по подготовке таблиц для чтения в R",
    "text": "3.9 Рекомендации по подготовке таблиц для чтения в R\nНесмотря на то, что каких-то четких правил подготовки таблиц для программной обработки не существует, можно дать несколько полезных рекомендаций по данному поводу:\n\nВ первой строке таблицы должны располагаться названия столбцов.\nВо второй строке таблицы должны начинаться данные. Не допускайте многострочных заголовков.\nВ названиях столбцов недопустимы объединенные ячейки, покрывающие несколько столбцов. Это может привести к неверному подсчету количества столбцов и, как следствие, некорректному чтению таблицы в целом.\nНазвания столбцов должны состоять из латинских букв и цифр, начинаться с буквы и не содержать пробелов. Сложносочиненные названия выделяйте прописными буквами. Плохое название столбца: Валовый внутренний продукт за 2015 г.. Хорошее название столбца: GDP2015.\nНекоторые ошибки данных в таблицах (такие как неверные десятичные разделители), проще найти и исправить в табличном/текстовом редакторе, нежели после загрузки в R.\n\nСледование этим правилам значительно облегчит работу с табличными данными в среде R.",
    "crumbs": [
      "Основы",
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Таблицы</span>"
    ]
  },
  {
    "objectID": "03-Tables.html#tables_review",
    "href": "03-Tables.html#tables_review",
    "title": "3  Таблицы",
    "section": "3.10 Краткий обзор",
    "text": "3.10 Краткий обзор\nДля просмотра презентации щелкните на ней один раз левой кнопкой мыши и листайте, используя кнопки на клавиатуре:\n\n\n\n\n\nПрезентацию можно открыть в отдельном окне или вкладке браузере. Для этого щелкните по ней правой кнопкой мыши и выберите соответствующую команду.",
    "crumbs": [
      "Основы",
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Таблицы</span>"
    ]
  },
  {
    "objectID": "03-Tables.html#tables_questions",
    "href": "03-Tables.html#tables_questions",
    "title": "3  Таблицы",
    "section": "3.11 Контрольные вопросы и упражнения",
    "text": "3.11 Контрольные вопросы и упражнения\n\n3.11.1 Вопросы\n\nКакая функция позволяет установить новый пакет в R?\nКак подключить пакет в текущую сессию R?\nКак вызвать функцию из пакета, не подключая его в текущей сессии R?\nКакие структуры данных используются для представления таблиц в среде R? Чем они отличаются друг от друга?\nКакая функция позволяет создавать тибблы по строкам, а не столбцам?\nКак загрузить в текущую сессию R набор данных из конкретного пакета? Под каким именем он будет доступен?\nКаковы основные принципы создания текстовых файлов с разделителем для хранения таблиц? Какой аббревиатурой они обозначаются?\nЧем отличаются файлы с фиксированной шириной столбца от файлов с разделителем? Какими спопообами можно указать границы колонок при чтении этих файлов?\nПеречислите функции из пакета readr, которые можно использовать для чтения текстовых файлов с табличными данными?\nКакой пакет позволяет читать данные в формате Microsoft Excel?\nЕсли прочитанный вами файл содержит нечитаемые символы, что это означает? Как решить проблему?\nКакие дополнительные параметры позволяют задавать функции чтения данных из пакетов readr и readxl, помимо имени файла?\nПеречислите основные возможности для отображения табличных данных в среде R?\nМожно ли заменять названия строк и столбцов таблицы? Если да, то какие функции для этого используются?\nНазовите возможные способы извлечения столбца (столбцов) из фрейма данных/тиббла. Какие из них приводят к получения вектора, а какие возвращают фрейм данных/тиббл?\nКак извлечь строки, удовлетворяющие некоторому критерию, используя стандартные средства R?\nПеречислите основные типы манипуляций над таблицами.\nКакой тип манипуляции всегда используется в сочетании с другими типами?\nНужно ли заключать названия переменных в кавычки при использовании функций пакета dplyr?\nКакая функция dplyr позволяет выбирать нужные переменные? Как с помощью нее отобрать диапазон переменных? Можно ли пойти от обратного и исключить, а не выбрать переменные?\nКакая функция dplyr позволяет осуществлять фильтрацию строк? Как реализовать фильтрацию строк по нескольким условиям одновременно?\nКак найти строки, в которых встречаются заданные фрагменты текста? Какая функция позволяет это сделать?\nНазовите функцию dplyr, отвечающую за выполнение сортировки таблицы. Как с помощью нее упорядочить данные по нескольким столбцам? Сделать порядок сортировки по убыванию?\nЧто такое мутирование и трансмутирование таблицы?\nКакая функция dplyr отвечает за добавление новых переменных? Можно ли с помощью нее добавить несколько переменных сразу? Как оставить только вновь создаваемые переменные?\nС помощью какой функции можно вычислить обобщающие статистики по всем строкам или группам строк?\nКак с помощью dplyr получить количество элементов и количество уникальных элементов в каждой группе?\nКак с помощью dplyr получить первый, последний и n-ный элемент в каждой группе?\nЧто такое конвейер манипуляций и для чего он используется в R?\nОпишите приципы действия пайп-оператора. С помощью какого клавиатурного сочетания его можно быстро ввести в RStudio?\nОпишите требования, которым должны отвечать аккуратные табличные данные. Какой пакет R позволяет преборазовывать данные в такую форму?\nКакие две основных операции над таблицами позволяют добиться длинного и широкого вида таблицы? Можно ли говорить о том, что для всех задач удобна какая-то одна из этих двух форм?\nКак работают функции pivot_longer() и pivot_wider()?\nЧто такое соединение таблиц? В каких случаях оно бывает необходимо? Какие разновидности соединения реализованы в dplyr?\nКаким требованиям должны отвечать таблицы для того чтобы их соединение было возможным?\nЧто такое первичный и внешний ключ в операции соединения таблиц?\nКакие возможности существуют для записи табличных данных в текстовые файлы? Перечислите пакеты и функции, такие возможности реализующие.\nОпишите общие рекомендации для подготовки таблиц к чтению средствами R.\n\n\n\n3.11.2 Упражнения\n\nТаблица quakes из пакета datasets содержит магнитуду землетрясений в поле mag. Используя функции dplyr и пайп-оператор, создайте на ее основе таблицу с частотой (количеством штук) землетрясений каждой магнитуды.\n\nПодсказка: при выполнении агрегирования используйте функцию n(), которая возвращает количество строк в группе.\n\nТаблица storms из пакета dplyr содержит увлекательные данные трекинга тропических циклонов c 1975 по 2015 год. Используя функции dplyr и пайп-оператор, создайте таблицу в которой зафиксировано: название циклона, дата начала, дата окончания, продолжительность в днях, максимальная скорость ветра, минимальное давление. Отсортируйте циклоны сначала по максимальной скорости ветра (по убыванию), затем по давлению (по возрастанию). Оформите результат в виде одного конвейера манипуляций.\n\nПодсказка: перед выполнением агрегирования на основе существующих полей создайте новое поле, в котором хранится дата события, имеющая тип Date. Это позволит вам правильно вычислить продолжительность в днях. Чтобы создать строку для преобразования в дату, используйте функцию paste(), подставив в нее поля, составляющие даты, и укажите необходимый разделитель в параметре sep(). После агрегирования данных и перед сортировкой вызовите ungroup(), иначе вы будете сортировать внутри каждой группы, а вам нужно сортировать результаты группировки.\n\nЗагрузите файл с данными по энергии ветра вдоль Черноморского побережья на высотах 50 и 100 метров, который был использован в этой лекции. Данный файл имеет формат фиксированной ширины столбца (см. параграф @ref(tables-reading-text-fwf)). Произведите чтение данного файла и приведите его с помощью tidyr к аккуратному виду, разделив высоту и величину энергии на отдельные столбцы. Используя возможности dplyr, рассчитайте фрейм данных со средними значениями энергии на каждой высоте.\nЗагрузите файл CSV с данными по населению федеральных округов России, который был использован в этой лекции. Прочтите данную таблицу, приведите ее с помощью tidyr к аккуратному виду (федеральный округ — год — население), а также вычислите в виде дополнительного столбца долю (в %), которую каждый округ занимает в общем населении России на каждый год (получится федеральный округ — год — население — доля). Оформите результат в виде одного конвейера манипуляций.\n\nПодсказка: используйте группировку таблицы по году и вычислите поле с долей путем деления поля населения на сумму по полю населения.\n\n\n\n\n\nСамсонов Т.Е. Визуализация и анализ географических данных на языке R. М.: Географический факультет МГУ, 2023. DOI: 10.5281/zenodo.901911",
    "crumbs": [
      "Основы",
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Таблицы</span>"
    ]
  },
  {
    "objectID": "04-Functions.html#tech-fun-functions",
    "href": "04-Functions.html#tech-fun-functions",
    "title": "4  Функции",
    "section": "4.1 Функции",
    "text": "4.1 Функции\nФункции в R можно использовать для структурирования кода на логически завершенные, автономные фрагменты кода, каждый из которых выполняет конкретную задачу. Синтаксис функции выглядит следующим образом:\n\nfunctionName = function(parameter1, parameter2, ...){\n  ...\n  return(result)\n  ...\n  last_value = ...\n}\n\nФункция создается c помощью ключевого слова function, за которым в круглых скобках заключается произвольное количество параметров (столько, сколько вам нужно: от нуля и более). С помощью этих параметров вы сможете передавать внутрь функции значения переменных. Созданной функции необходимо дать имя, используя оператор присвоения &lt;- или =.\nВозврат значения функции осуществляется двумя способами:\n\nЕсли не указано иное, то будет возвращен результат вычисления последнего выражения, выполненного внутри функции (last_value в примере выше)\nРезультат можно вернуть принудительно в любом месте функции, передав его в выражение return().\n\n\nВыражение return() работает аналогично ключевому слову break в циклах: оно прерывает выполнение функции и осуществляет выход из нее. Как правило, return() используется, если возврат значения надо сделать где-то посередине или в начале функции. Однако я реккомендую использовать его всегда, поскольку это помогает читателю вашей функции быстро определить, что же именно возвращается из функции\n\nКак правило, функции оказываются полезны, если:\n\nВы дублируете один и тот же код в разных частях программы\nВаш код становится слишком длинным, при этом присутствует очевидная этапность решения задачи, позволяющая разбить программу на автономные блоки\nУ вас есть фрагмент кода, который выполняет вспомогательную (второстепенную функцию), и не относится непосредственно к основной логике программы.\n\nПредположим, у нас есть линия, заданная координатами четырех точек, и нам надо вычислить длины каждого из трех отрезков. Без использования функции мы запишем это так:\n\nx = rnorm(4)\ny = rnorm(4)\nd12 = sqrt((x[1] - x[2]) ^ 2 + (y[1] - y[2]) ^ 2)\nd23 = sqrt((x[2] - x[3]) ^ 2 + (y[2] - y[3]) ^ 2)\nd31 = sqrt((x[3] - x[4]) ^ 2 + (y[3] - y[4]) ^ 2)\ncat(d12, d23, d31)\n\n1.78599 1.780432 2.739223\n\n\nВ правой части этих выражений стоит один и тот же код, который я скопировал и вставил, а далее заменил названия переменных. Это плохо сразу по двум причинам: дублирование фрагментов программы и возрастание вероятности опечаток в скопированой копии. Улучшить код можно, введя функцию вычисления расстояний:\n\ndistance = function(x1, y1, x2, y2) {\n  sqrt((x1 - x2) ^ 2 + (y1 - y2) ^ 2)\n}\n\nd12 = distance(x[1], y[1], x[2], y[2])\nd23 = distance(x[2], y[2], x[3], y[3])\nd31 = distance(x[3], y[3], x[4], y[4])\ncat(d12, d23, d31)\n\n1.78599 1.780432 2.739223\n\n\nФункция всегда возвращает один объект: значение, вектор, список и т.д. Например, мы можем сделать функцию следующего уровня, рассчитывающая сразу все расстояния для множества точек:\n\ndistances = function(x, y) {\n  n = length(x)\n  distance(x[1:(n-1)], y[1:(n-1)], x[2:n], y[2:n])\n}\n\ndistances(x, y)\n\n[1] 1.785990 1.780432 2.739223\n\n\nМожно пойти еще дальше, и сделать функцию, выполняющую вычисление длины линии, заданной координатами:\n\nline_length = function(x, y) {\n  sum(distances(x, y))\n}\n\nline_length(x, y)\n\n[1] 6.305645\n\n\nОбратите внимание на то, как мы используем одну ранее написанную функцию при создании другой функции! Это весьма распространенная практика: одна и та же функция может быть как самостоятельно полезной (вызываться непосредственно в программе полтьзователя), так и применяться для решения задач внутри других функций. При этом иногда даже относительно простые фрагменты кода имеет смысл оформлять в виде функций, так как это может улучшить читаемость программы и пояснить смысл выполняемых операций. Так, например, line_length(x, y) в более явном виде обозначает операцию вычисления длины по координатам, нежели sum(distances(x, y)). В то же время, здесь важно не переусердствовать и оформлять короткие фрагменты кода в виде функций только если они будут применяться вами неоднократно.\nЕсли вам нужно вернуть из функции несколько объектов, имеющих разный тип или смысл, заключите их в список и дайте каждому элементу списка “говорящее” имя. Например, помимо периметра, мы можем вернуть также извилистость линии (отношение длины линии к длине отрезка, соединяющего ее первую и последнюю точку):\n\nline_params = function(x, y) {\n  n = length(x)\n  \n  l = line_length(x, y)\n  s = l / distance(x[1], y[1], x[n], y[n]) \n  \n  list(length = l, sinuosity = s)\n}\n\nresult = line_params(x, y)\nresult$length\n\n[1] 6.305645\n\nresult$sinuosity\n\n[1] 4.907202",
    "crumbs": [
      "Основы",
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Функции</span>"
    ]
  },
  {
    "objectID": "04-Functions.html#tech-fun-functionals",
    "href": "04-Functions.html#tech-fun-functionals",
    "title": "4  Функции",
    "section": "4.2 Функционалы",
    "text": "4.2 Функционалы\n\n4.2.1 Базовые функционалы\nДанные (в том числе географические) практически всегда носят множественный характер и организованы в определенные структуры (см. главу 2). Эта особенность данных выдвигает логичное желание иметь процедуры, которые можно применять к полному набору данных, а не к его отдельным компонентам. Это и есть процедуры векторизованных вычислений.\nПредположим, вам необходимо что-то вычислить для каждой строки таблицы, при этом порядок вычисления зависит от содержимого ячеек данной строки. Вы можете организовать подобные вычисления с помощью циклов, однако в R существуют специальные функции семейста apply, которые позволяют решать подобные задачи более элегантно и с высокой скоростью:\n\n\n\n\n\n\n\nФункция\nНазначение\n\n\n\n\napply()\nприменить функцию ко всем строкам или столбцам матрицы\n\n\nlapply()\nприменить функцию к каждому компоненту вектора или списка и получить результат также в виде списка (l — list)\n\n\nsapply()\nприменить функцию к каждому компоненту вектора или списка и получить результат в виде вектора (s — simplify)\n\n\nvapply()\nаналогична sapply(), но требует явного задания типа данных возвращаемого вектора, за счет чего работает быстрее (v — velocity)\n\n\nmapply()\nприменить функцию к каждому компоненту нескольких векторов или списков и вернуть результат в виде списка (m — multivariate)\n\n\nrapply()\nприменить функцию рекурсивно ко всем элементам переданного списка и вернуть результат в аналогичной структур (r — recursive)\n\n\ntapply()\nприменить функцию ко всем компонентам вектора или списка, сгруппировав их по значению переданного фактора\n\n\n\n\nФункции семейства apply, принимающие на вход списки, могут работать и с фреймами данных. В этом случае фрейм внутри функции будет преобразован с помощью функции as.list() в список, элементами которого являются столбцы (переменные) входного фрейма данных. Данные при этом не потеряются, их типы тоже не изменятся.\n\nБазовая функция apply() имеет следующие аргументы:\n\nX — массив любой размерности (включая вектор)\nMARGIN — измерения по которым необходимо вести вычисления. Для матрицы 1 означает строку, 2 означает столбец, c(1, 2) будет означать, что вычисления производятся по всем комбинациям строк и столбцов\nFUN — функция, которая будет применяться к каждому элементу указанных измерений\n... — список аргументов, которые надо передать в функцию FUN (в этом случае массив должен передаваться обязательно в первый аргумент)\n\nДругие функции семейства apply в приложении к фреймам данных будут работать со столбцами (переменными), интерпретируя их как элементы списка. Наиболее часто из них используются lapply(), sapply() и vapply(). В отличие от apply(), они уже не принимаеют номера измерений и работают только с элементами переданного списка.\nРассмотрим применение функций данного семейства на примере анализа основных социально-экономических характеристик столиц субъектов Северо-Западного округа за 2015 год:\n\nlibrary(readxl)\n\n(df = read_excel(\"data/sevzap.xlsx\", col_types = c('text', rep('numeric', 17))))\n## # A tibble: 10 × 18\n##    city     pop birth death  labor salary livspace doctors  hosp assets business\n##    &lt;chr&gt;  &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt;  &lt;dbl&gt;  &lt;dbl&gt;    &lt;dbl&gt;   &lt;dbl&gt; &lt;dbl&gt;  &lt;dbl&gt;    &lt;dbl&gt;\n##  1 Петр…  277.   13    12.3   72.3 36268.     24.4    75      17 2.47e5    15856\n##  2 Сыкт…  259.   14.5  10.4   84.1 39790      22.8    79.5    17 2.17e5    10068\n##  3 Арха…  358.   11.8  11.6   97.9 40303.     22.7    82.3    19 2.79e5    13016\n##  4 Нарь…   24.5  18.1   7.6   12.7 69884.     23.6    65.2     2 1.05e5      704\n##  5 Воло…  313.   16.2  11.4   91   31483      24.7    60.9    18 8.27e5    21931\n##  6 Кали…  460.   13.3  13.4  126.  34142      27.7    69.8    25 3.27e5    38013\n##  7 Мурм…  302.   12.4  11.9   96.9 53240.     23.8    68.8    15 7.24e5    16041\n##  8 Вели…  222.   13.8  13.8   74.1 32377.     24.1    78.9    14 1.59e5     9583\n##  9 Псков  208.   13.2  13.7   59.6 27405.     25      59      13 1.31e5     8752\n## 10 Санк… 5226.   13.6  11.9 2055.  44187      23.6    73.8   112 4.10e6   374999\n## # ℹ 7 more variables: minerals &lt;dbl&gt;, manufact &lt;dbl&gt;, engaswat &lt;dbl&gt;,\n## #   construct &lt;dbl&gt;, apart &lt;dbl&gt;, retail &lt;dbl&gt;, invest &lt;dbl&gt;\n\nВ данной таблице каждый столбец представляет независимую переменную со своими единицами измерения, поэтому ее необходимо оставить в “широкой” форме, не преобразуя в длинную. Используя apply, можно быстро получить максимальные значения каждой переменной:\n\napply(df[-1], 2, max)\n\n      pop     birth     death     labor    salary  livspace   doctors      hosp \n   5225.7      18.1      13.8    2055.3   69883.5      27.7      82.3     112.0 \n   assets  business  minerals  manufact  engaswat construct     apart    retail \n4102243.8  374999.0        NA 1978634.0  173292.0  397229.0    3031.0 1144607.0 \n   invest \n 521293.0 \n\n\nЧто равносильно вызову sapply:\n\nsapply(df[-1], max)\n\n      pop     birth     death     labor    salary  livspace   doctors      hosp \n   5225.7      18.1      13.8    2055.3   69883.5      27.7      82.3     112.0 \n   assets  business  minerals  manufact  engaswat construct     apart    retail \n4102243.8  374999.0        NA 1978634.0  173292.0  397229.0    3031.0 1144607.0 \n   invest \n 521293.0 \n\n\nВ качестве функции можно использовать не только стандартные, но и пользовательские функции. Например, нам может быть интересно не максимальное значение показателя, а его отношение к среднему значению среди всех городов. Здесь уже одной функцией не обойдешься, так как нужно каждый столбец поделить на среднее значение по нему. Для этого определим небольшую пользовательскую функцию непосредственно при вызове sapply():\n\n(normalized = sapply(df[-1], function(X) { round(X / mean(X, na.rm = TRUE), 2) }))\n\n       pop birth death labor salary livspace doctors hosp assets business\n [1,] 0.36  0.93  1.04  0.26   0.89     1.01    1.05 0.67   0.35     0.31\n [2,] 0.34  1.04  0.88  0.30   0.97     0.94    1.11 0.67   0.30     0.20\n [3,] 0.47  0.84  0.98  0.35   0.99     0.94    1.15 0.75   0.39     0.26\n [4,] 0.03  1.29  0.64  0.05   1.71     0.97    0.91 0.08   0.15     0.01\n [5,] 0.41  1.16  0.97  0.33   0.77     1.02    0.85 0.71   1.16     0.43\n [6,] 0.60  0.95  1.14  0.46   0.83     1.14    0.98 0.99   0.46     0.75\n [7,] 0.39  0.89  1.01  0.35   1.30     0.98    0.96 0.60   1.02     0.32\n [8,] 0.29  0.99  1.17  0.27   0.79     0.99    1.11 0.56   0.22     0.19\n [9,] 0.27  0.94  1.16  0.22   0.67     1.03    0.83 0.52   0.18     0.17\n[10,] 6.83  0.97  1.01  7.42   1.08     0.97    1.03 4.44   5.76     7.37\n      minerals manufact engaswat construct apart retail invest\n [1,]     0.06     0.05     0.52      0.13  0.45   0.23   0.11\n [2,]     0.00     0.28     0.43      0.09  0.31   0.21   0.14\n [3,]     0.00     0.06     0.49      0.09  0.17   0.17   0.15\n [4,]     4.12     0.05     0.03      0.08  0.05   0.02   0.52\n [5,]       NA     0.15     0.63      0.09  0.52   0.23   0.13\n [6,]     0.82     0.83     0.68      0.28  1.24   0.38   0.53\n [7,]       NA     0.23     0.42      0.07  0.02   0.29   0.75\n [8,]       NA     0.42     0.45      0.08  0.32   0.17   0.30\n [9,]       NA     0.08     0.22      0.04  0.27   0.17   0.10\n[10,]     1.00     7.87     6.13      9.05  6.65   8.13   7.28\n\n\nПолученный объект является матрицей. Таким образом, можно видеть, что функционалы бывают полезны не только для агрегирования таблиц, но и для преобразования данных, когда структура таблицы остается прежней.\nВ приведенном выше коде мы сознательно исключили первый столбец, поскольку он является текстовым. Можно сделать более мощную и универсальную функцию, которая будет нормировать все числовые столбцы таблицы, а текстовые оставлять в оригинале. Для этого проверку типа данных надо внести внутрь функции. Поскольку код функции при этом вырастает, целесообразно определить ее заранее. Поскольку в этом случае часть векторов будет символьной, а не числовой, необходимо применять функцию lapply(), которая вернет список из векторов, а не матрицу и таким образом сохранит типы каждого столбца:\n\nlibrary(dplyr)\nnormalize = function(X) {\n  if (is.numeric(X)) \n    round(X / mean(X, na.rm = TRUE), 2) \n  else X\n}\n\n(normalized_df = df |&gt; lapply(normalize) |&gt; as_tibble())\n\n# A tibble: 10 × 18\n   city      pop birth death labor salary livspace doctors  hosp assets business\n   &lt;chr&gt;   &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt;  &lt;dbl&gt;    &lt;dbl&gt;   &lt;dbl&gt; &lt;dbl&gt;  &lt;dbl&gt;    &lt;dbl&gt;\n 1 Петроз…  0.36  0.93  1.04  0.26   0.89     1.01    1.05  0.67   0.35     0.31\n 2 Сыктыв…  0.34  1.04  0.88  0.3    0.97     0.94    1.11  0.67   0.3      0.2 \n 3 Арханг…  0.47  0.84  0.98  0.35   0.99     0.94    1.15  0.75   0.39     0.26\n 4 Нарьян…  0.03  1.29  0.64  0.05   1.71     0.97    0.91  0.08   0.15     0.01\n 5 Вологда  0.41  1.16  0.97  0.33   0.77     1.02    0.85  0.71   1.16     0.43\n 6 Калини…  0.6   0.95  1.14  0.46   0.83     1.14    0.98  0.99   0.46     0.75\n 7 Мурман…  0.39  0.89  1.01  0.35   1.3      0.98    0.96  0.6    1.02     0.32\n 8 Велики…  0.29  0.99  1.17  0.27   0.79     0.99    1.11  0.56   0.22     0.19\n 9 Псков    0.27  0.94  1.16  0.22   0.67     1.03    0.83  0.52   0.18     0.17\n10 Санкт-…  6.83  0.97  1.01  7.42   1.08     0.97    1.03  4.44   5.76     7.37\n# ℹ 7 more variables: minerals &lt;dbl&gt;, manufact &lt;dbl&gt;, engaswat &lt;dbl&gt;,\n#   construct &lt;dbl&gt;, apart &lt;dbl&gt;, retail &lt;dbl&gt;, invest &lt;dbl&gt;\n\n\n\n\n4.2.2 Функционалы purrr\nВ качестве альтернативы функциям apply можно также воспользоваться вычислениями посредством функций семейства map из пакета purrr (еще один пакет из tidyverse). Эти функции работают аналогично, но их разнообразие довольно велико. Например, часто используюбся следующие:\n\n\n\nФункция\nТип возвращаемого значения\n\n\n\n\nmap()\nсписок\n\n\nmap_lgl()\nвектор logical\n\n\nmap_int()\nвектор integer\n\n\nmap_dbl()\nвектор double\n\n\nmap_chr()\nвектор character\n\n\n\nОсновные отличия от базовых функций следующие:\n\nявное указание типа возвращаемого значения (apply могут быть непредсказуемы);\nданные всегда идут первым аргументом (это условие не выполняется для mapply).\nподдерживается большое разнообразие сочетаний входных и выходных параметров, в том числе итерации по нескольким векторам одновременно.\n\nВышеприведенные операции можно осуществить средствами purrr вот так:\n\nlibrary(purrr)\nmap_dbl(df[-1], max)\n\n      pop     birth     death     labor    salary  livspace   doctors      hosp \n   5225.7      18.1      13.8    2055.3   69883.5      27.7      82.3     112.0 \n   assets  business  minerals  manufact  engaswat construct     apart    retail \n4102243.8  374999.0        NA 1978634.0  173292.0  397229.0    3031.0 1144607.0 \n   invest \n 521293.0 \n\ndf |&gt; map(normalize) |&gt; as_tibble()\n\n# A tibble: 10 × 18\n   city      pop birth death labor salary livspace doctors  hosp assets business\n   &lt;chr&gt;   &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt;  &lt;dbl&gt;    &lt;dbl&gt;   &lt;dbl&gt; &lt;dbl&gt;  &lt;dbl&gt;    &lt;dbl&gt;\n 1 Петроз…  0.36  0.93  1.04  0.26   0.89     1.01    1.05  0.67   0.35     0.31\n 2 Сыктыв…  0.34  1.04  0.88  0.3    0.97     0.94    1.11  0.67   0.3      0.2 \n 3 Арханг…  0.47  0.84  0.98  0.35   0.99     0.94    1.15  0.75   0.39     0.26\n 4 Нарьян…  0.03  1.29  0.64  0.05   1.71     0.97    0.91  0.08   0.15     0.01\n 5 Вологда  0.41  1.16  0.97  0.33   0.77     1.02    0.85  0.71   1.16     0.43\n 6 Калини…  0.6   0.95  1.14  0.46   0.83     1.14    0.98  0.99   0.46     0.75\n 7 Мурман…  0.39  0.89  1.01  0.35   1.3      0.98    0.96  0.6    1.02     0.32\n 8 Велики…  0.29  0.99  1.17  0.27   0.79     0.99    1.11  0.56   0.22     0.19\n 9 Псков    0.27  0.94  1.16  0.22   0.67     1.03    0.83  0.52   0.18     0.17\n10 Санкт-…  6.83  0.97  1.01  7.42   1.08     0.97    1.03  4.44   5.76     7.37\n# ℹ 7 more variables: minerals &lt;dbl&gt;, manufact &lt;dbl&gt;, engaswat &lt;dbl&gt;,\n#   construct &lt;dbl&gt;, apart &lt;dbl&gt;, retail &lt;dbl&gt;, invest &lt;dbl&gt;\n\n\nОднако purrr позволяет выполнять функции не ко всем элементам, а только к тем, которые удовлетворяют заданным условиям. Если задачу нормировки необходимо решить один раз, то можно не создавать новую функцию, а выполнить нормировку по условию непосредственно при вызове функционала:\n\ndf |&gt; map_if(is.numeric, \\(X) round(X / mean(X, na.rm = TRUE), 2)) |&gt; as_tibble()\n\n# A tibble: 10 × 18\n   city      pop birth death labor salary livspace doctors  hosp assets business\n   &lt;chr&gt;   &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt;  &lt;dbl&gt;    &lt;dbl&gt;   &lt;dbl&gt; &lt;dbl&gt;  &lt;dbl&gt;    &lt;dbl&gt;\n 1 Петроз…  0.36  0.93  1.04  0.26   0.89     1.01    1.05  0.67   0.35     0.31\n 2 Сыктыв…  0.34  1.04  0.88  0.3    0.97     0.94    1.11  0.67   0.3      0.2 \n 3 Арханг…  0.47  0.84  0.98  0.35   0.99     0.94    1.15  0.75   0.39     0.26\n 4 Нарьян…  0.03  1.29  0.64  0.05   1.71     0.97    0.91  0.08   0.15     0.01\n 5 Вологда  0.41  1.16  0.97  0.33   0.77     1.02    0.85  0.71   1.16     0.43\n 6 Калини…  0.6   0.95  1.14  0.46   0.83     1.14    0.98  0.99   0.46     0.75\n 7 Мурман…  0.39  0.89  1.01  0.35   1.3      0.98    0.96  0.6    1.02     0.32\n 8 Велики…  0.29  0.99  1.17  0.27   0.79     0.99    1.11  0.56   0.22     0.19\n 9 Псков    0.27  0.94  1.16  0.22   0.67     1.03    0.83  0.52   0.18     0.17\n10 Санкт-…  6.83  0.97  1.01  7.42   1.08     0.97    1.03  4.44   5.76     7.37\n# ℹ 7 more variables: minerals &lt;dbl&gt;, manufact &lt;dbl&gt;, engaswat &lt;dbl&gt;,\n#   construct &lt;dbl&gt;, apart &lt;dbl&gt;, retail &lt;dbl&gt;, invest &lt;dbl&gt;\n\n\nРаспространенный сценарий, который более удобно реализуется в purrr по сравнению с базовым R — это итерации по множеству аргументов. Например, неоходимо сгенерировать несколько популяций из \\(7\\) случайных глубин, имеющих равномерное распределение в заданных интервалах от \\([-10, -6]\\) до \\([-5, -1]\\). В базовом R для этого мы использовали бы mapply()\n\nset.seed(2020)\nzmin = -10:-6\nzmax = -5:-1\ndepths &lt;- mapply(\n  runif, min = zmin, max = zmax, \n  MoreArgs = list(n = 7), SIMPLIFY = FALSE\n)\nstr(depths)\n\nList of 5\n $ : num [1:7] -6.77 -8.03 -6.91 -7.62 -9.32 ...\n $ : num [1:7] -7.03 -8.99 -5.9 -5.18 -5.28 ...\n $ : num [1:7] -5.95 -5.3 -3.2 -4.73 -5.27 ...\n $ : num [1:7] -6.61 -2.91 -2.29 -2.58 -6.17 ...\n $ : num [1:7] -3.75 -3.22 -1.18 -5.64 -1.22 ...\n\n\nПри этом обратим внимание на то, что аргументы, по которым не делаются итерации, выносятся в MoreArgs, а чтобы получить на выходе список, а не матрицу, мы применяем SIMPLIFY = FALSE.\nПри использовании map2 задача решается одним простым выражением:\n\ndepths &lt;- map2(zmin, zmax, runif, n = 7)\nstr(depths)\n\nList of 5\n $ : num [1:7] -8.16 -9.94 -5.33 -7.38 -8.89 ...\n $ : num [1:7] -4.68 -4.58 -5.88 -6.14 -6.65 ...\n $ : num [1:7] -7.17 -5.11 -6.56 -3.49 -5.39 ...\n $ : num [1:7] -4.79 -5.88 -4.28 -4.57 -5.96 ...\n $ : num [1:7] -3.88 -1.68 -2.93 -1.04 -3.12 ...\n\n\nЕсли же и количество глубин в каждой популяции должно быть случайным, то нам понадобится функционал, который может принять более двух аргументов — это pmap :\n\nnelem = sample(1:10, 5)\ndepths &lt;- pmap(list(min = zmin, max = zmax, n = nelem), runif)\nstr(depths)\n\nList of 5\n $ : num [1:5] -9.71 -6.64 -6.41 -5.91 -9.51\n $ : num [1:6] -7.47 -7.03 -7.09 -8.14 -7.83 ...\n $ : num [1:2] -7.41 -6.88\n $ : num -4\n $ : num [1:3] -2.14 -4.22 -2.01\n\n\nЕще один полезный сценарий, который проддерживается purrr — это одновременная итерация по индексам аргументов и их значениям. Такая возможность реализуется в функционалах с префиксом i: imap(), iwalk() и их модификациях.\n\nФункционалы семейства walk() в отличие от map не возвращают значения, а только посещают каждый элемент. Их используют, например, чтобы сохранить каждый элемент структуры данных в файл, построить график на его основе или просто вывести инфомацию о нем в консоль.\n\nНапример, можем вывести данные по случайным глубинам посредством iwalk() в аннотированном виде:\n\niwalk(depths, \\(z, i) cat('Sample ', i, ': ', z, '\\n', sep = ''))\n\nSample 1: -9.714993-6.636848-6.413566-5.909034-9.511208\nSample 2: -7.466208-7.030675-7.091471-8.139645-7.830458-7.188147\nSample 3: -7.405076-6.881571\nSample 4: -4.000526\nSample 5: -2.143847-4.222869-2.013891",
    "crumbs": [
      "Основы",
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Функции</span>"
    ]
  },
  {
    "objectID": "04-Functions.html#tech-meta",
    "href": "04-Functions.html#tech-meta",
    "title": "4  Функции",
    "section": "4.3 Квотация аргументов",
    "text": "4.3 Квотация аргументов\nВы уже сталкивались с квотацией, когда работали с функциями dplyr. Например, сравните следующие два способа извлечь столбец из фрейма данных:\n\ndf[\"salary\"]\n\n# A tibble: 10 × 1\n   salary\n    &lt;dbl&gt;\n 1 36268.\n 2 39790 \n 3 40303.\n 4 69884.\n 5 31483 \n 6 34142 \n 7 53240.\n 8 32377.\n 9 27405.\n10 44187 \n\nselect(df, salary)\n\n# A tibble: 10 × 1\n   salary\n    &lt;dbl&gt;\n 1 36268.\n 2 39790 \n 3 40303.\n 4 69884.\n 5 31483 \n 6 34142 \n 7 53240.\n 8 32377.\n 9 27405.\n10 44187 \n\n\nВ обоих случаях мы получили один и тот же результат. В первом случае было указано название столбца в кавычках. Во втором мы передали название столбца без кавычек, точно так же как было передано название фрейма данных. Как R догадался, что параметр salary — это не имя переменной, которая живет на одном уровне с\nДля начала разберемся с тем, что происходит в программном коде:\n\nselect() представляет собой вызов (call) функции\ndf и salary представляют собой символы, обозначающие объекты в программе.\n\"salary\" представляет собой константу\n\nR — это функциональный язык программирования. Любая программа на R состоит из вызовов функций, которые применяются к символам и константам. Привычные нам арифметические операции на самом деле тоже являются вызовами функций. Это выглядит довольно неожиданно:\n\na = 78     # стандартная запись\n`=`(a, 78) # функциональная запись\n\na + 4     # стандартная запись\n\n[1] 82\n\n`+`(a, 4) # функциональная запись\n\n[1] 82\n\ndf['salary']      # стандартная запись\n\n# A tibble: 10 × 1\n   salary\n    &lt;dbl&gt;\n 1 36268.\n 2 39790 \n 3 40303.\n 4 69884.\n 5 31483 \n 6 34142 \n 7 53240.\n 8 32377.\n 9 27405.\n10 44187 \n\n`[`(df, 'salary') # функциональная запись\n\n# A tibble: 10 × 1\n   salary\n    &lt;dbl&gt;\n 1 36268.\n 2 39790 \n 3 40303.\n 4 69884.\n 5 31483 \n 6 34142 \n 7 53240.\n 8 32377.\n 9 27405.\n10 44187 \n\n\nТаким образом, бинарный оператор в R представляет собой вызов функции с двумя аргументами.\nПрограммный код a + 4 с точки зрения R является выражением (expression). Выражение может состоять вообще из одного символа, то есть a — это тоже выражение. Когда интерпретатор доходит до выражения a + 4, он выполняет следующее:\n\nОценка (evaluation) выражения a. Результатом оценки является константа 78\nВызов (call) функции +, которая складывает константы 78 и 4\n\nНе все символы и выражения в программе необходимо оценивать. Некоторые из них необходимо квотировать, то есть использовать в качестве имени объекта. Квотацию можно условно рассматривать как простановку кавычек вокруг выражения. Для обозначения квотации в явном виде используются обратные кавычки: ` Мы уже сталкивались с квотацией при вызове функции сложения: `+`(a, 4). В данном случае квотация была нужна чтобы + интерпретировался как имя функции.\nЯвная квотация бывает необходима, когда объекты R имеют недопустимые имена, например начинаются с цифры или содержат пробелы. Для начала рассмотрим искусственный пример:\n\n`f + 17` = 87 # создаем объект с именем f + 17\nf + 17 # ошибка: переменной f не существует\n\nError in eval(expr, envir, enclos): object 'f' not found\n\n`f + 17` # обращаемся к объекту путем явной квотации\n\n[1] 87\n\n\nТеперь более жизнеспособный пример: данные о населении федеральных округов:\n\nlibrary(readr)\n(okruga = read_csv('data/okruga.csv'))\n\n# A tibble: 8 × 7\n    `№` Регион            `2005` `2010` `2011` `2012` `2013`\n  &lt;dbl&gt; &lt;chr&gt;              &lt;dbl&gt;  &lt;dbl&gt;  &lt;dbl&gt;  &lt;dbl&gt;  &lt;dbl&gt;\n1     1 Центральный         4341   3761   3613   3651   3570\n2     2 Северо-Западный     3192   3088   2866   2877   2796\n3     3 Южный федеральный   1409   1446   1436   1394   1321\n4     4 Северо-Кавказский    496    390    397    395    374\n5     5 Приволжский         3162   2883   2857   2854   2849\n6     6 Уральский           1681   1860   1834   1665   1624\n7     7 Сибирский           2575   2218   2142   2077   1941\n8     8 Дальневосточный      871    870    821    765    713\n\n\nОбратите внимание на обратные кавычки вокруг названий столбцов. Они проставлены потому что числа в среде R по умолчанию оцениваются, и не могут использоваться в качестве символов для объектов. Чтобы разрешить это, используется принудительная квотация. Как мы уже знаем, чтобы обратиться к такому объекту, надо использовать обратные кавычки:\n\nokruga$2010   # ошибка: 2010 - константа, которая оценивается\n\nError: &lt;text&gt;:1:8: unexpected numeric constant\n1: okruga$2010\n           ^\n\n\n\nokruga$`2010` # правильно: `2010` -- символ, полученный путем квотации\n\n[1] 3761 3088 1446  390 2883 1860 2218  870\n\n\nТеперь вернемся к примеру с использованием функции select(). Данная функция оценивает первый аргумент (фрейм данных) и квотирует все оставшиеся аргументы, которые отвечают за названия столбцов. Это позволяет избежать использования кавычек и использовать символы для наименования объектов. Чтобы понять, использует ли функция оценку или квотацию ее аргументов, необходимо ознакомиться с ее справкой.\n\nКогда функция применяет квотацию аргументов, говорят что осуществляется нестандартная оценка (NSE – non-standard evaluation). Если аргументы функции оцениваются, то происходит стандартная оценка (SE – standard evaluation)\n\nИногда бывает необходимо использовать строковые названия столбцов (например, если они записаны у вас в переменные). Функция select достаточно умна и в случае если квотация дала несуществующие значения столбцов, произведет оценку аргументов и попытается извлечь из них имена:\n\nf1 = 'salary'\nf2 = 'birth'\nselect(df, f1, f2)        # ОК\n\n# A tibble: 10 × 2\n   salary birth\n    &lt;dbl&gt; &lt;dbl&gt;\n 1 36268.  13  \n 2 39790   14.5\n 3 40303.  11.8\n 4 69884.  18.1\n 5 31483   16.2\n 6 34142   13.3\n 7 53240.  12.4\n 8 32377.  13.8\n 9 27405.  13.2\n10 44187   13.6\n\n\nЕсли же передавать в качестве аргумента константы, то они всегда используются по значению, т.к. имени у них нет:\n\nselect(df, 'salary', 'birth') # то же самое\n\n# A tibble: 10 × 2\n   salary birth\n    &lt;dbl&gt; &lt;dbl&gt;\n 1 36268.  13  \n 2 39790   14.5\n 3 40303.  11.8\n 4 69884.  18.1\n 5 31483   16.2\n 6 34142   13.3\n 7 53240.  12.4\n 8 32377.  13.8\n 9 27405.  13.2\n10 44187   13.6\n\n\nИногда выражения бывает необходимо создать, а оценивать уже потом. Такой подход иногда используется в статистическом анализе. Для этого существуеют объекты выражений, которые создаются с помощью функции expression():\n\n(d = expression(b^2 - 4*a)) # создаем выражение\n\nexpression(b^2 - 4 * a)\n\na = 2\nb = 7\neval(d) # оцениваем значение выражения\n\n[1] 41\n\n\nВсе символы в объекте выражения по умолчанию квотируются и выражение хранится в статичном виде до тех пор пока не будет произведена его оценка (подстановка значений переменных вместо их символов).\n\nВыражения и квотация существуют в R благодаря возможностям метапрограммирования. Это техника программирования, при которой программный код может генерировать другой код. Широкая поддержка и интенсивное использование метапрограммирования – одна из удивительных черт R, которая ставит его особняком на фоне многих других языков, включая Python. Метапрограммирование позволяет во многих случаях сделать код более компактным и подойти к решению задачи элегантным путем.",
    "crumbs": [
      "Основы",
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Функции</span>"
    ]
  },
  {
    "objectID": "04-Functions.html#tech_review",
    "href": "04-Functions.html#tech_review",
    "title": "4  Функции",
    "section": "4.4 Краткий обзор",
    "text": "4.4 Краткий обзор\nДля просмотра презентации щелкните на ней один раз левой кнопкой мыши и листайте, используя кнопки на клавиатуре:\n\n\n\n\n\nПрезентацию можно открыть в отдельном окне или вкладке браузере. Для этого щелкните по ней правой кнопкой мыши и выберите соответствующую команду.",
    "crumbs": [
      "Основы",
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Функции</span>"
    ]
  },
  {
    "objectID": "04-Functions.html#tech_questions",
    "href": "04-Functions.html#tech_questions",
    "title": "4  Функции",
    "section": "4.5 Контрольные вопросы и упражнения",
    "text": "4.5 Контрольные вопросы и упражнения\n\n4.5.1 Вопросы\n\nЧто такое функция?\nКакое ключевое слово ипользуется для создания функции?\nВ каких случаях целесообразно применение функций?\nСколько аргументов может принимать функция?\nМожно ли из одной функции вызывать другую функцию?\nКак осуществить принудительный выход из функции с возвратом результата?\nЧто необходимо сделать, если надо передать несколько объектов из функции?\nДля чего нужны функционалы семейства apply? В каких задачах они бывают полезны?\nПеречислите функции семейства apply, назовите их отличия и сферы применения.\nКакая функция семейства apply позволяет обабатывать заданные измерения?\nКакой объект первым передается в функцию, подставляемую в параметр FUN, если применяется lapply к фрейму данных?\nНазовите аналоги функций apply из пакета purrr\nЧто такое метапрограммирование?\nИз каких объектов состоят выражения в R?\nЧто из себя по на самом деле представляют бинарные операторы в R?\nКак обратиться к объекту, символ которого не является допустимым именем переменной?\nЧто такое оценка и квотация выражения? Для чего они используются?\nКак понять, будет ли используемая вами функция квотрировать или оценивать ее аргументы?\nКак называются функции dplyr, осуществляющие оценку, а не квотацию аргументов?\nКак создать и оценить объект выражения в R?\n\n\n\n4.5.2 Упражнения\n\nНапишите функцию is_leap(year), которая определяет, является ли указанный год високосным. Протестируйте ее в вашем скрипте, используя чтение года из консолии\n\nПодсказка: високосным считается год, кратный 400, либо кратный 4, но не кратный 100.\n\nФункция Тоблера показывает зависимость скорости пешего маршрута (в км/ч) от угла наклона на местности. Предположим, в вашем распоряжении имеется матрица профиля рельефа, в которой в одном столбце указано расстояние от начала маршрута, а во втором — абсолютная отметка точки. Напишите функцию hiking_time(profile), которая вычисляет время прохождения маршрута на основе переданной ей матрицы. Используйте для тестирования функции маршрут из 10 точек с шагом в 1 км и случайным разбросом высот в диапазоне от 500 до 1000 метров (равномерное распределение).\n\nПодсказка: угол наклона на каждом участке считается постоянным. Для вычисления экспоненты используйте встроенную функцию exp().\n\nСоздайте на основе данных по Москве с сайта pogodaiklimat таблицу Excel с повторяемостью различных направлений ветра. Не преобразовывая структуру данных, вычислите на ее основе с помощью lapply() преобладающее направление для каждого месяца. Представьте результат как фрейм данных.\nВ текущей лекции мы работали с данными по характеристикам центров субъектов СЗФО. Напишите функцию get_extremes(df), которая определяет названия переменных, по которым каждая строчка фрейма данных (в нашем случае — город) занимает максимальное и минимальное положение относительно среднего значения по всем городам. Например, Петрозаводск имеет максимальный рейтинг по показателю doctors (1.05) — количество врачей на 10000 чел и минимальный по показателю manufact (0.05) — продукции обрабатывающей промышленность (в млн руб). Результирующая таблица должна содержать первое по счету поле, а также поля minvar и maxvar:\nRegion        minvar    maxvar\nПетрозаводск doctors  manufact\n...\n...\n\nПодсказка: для начала вам надо нормировать значения всех переменных с помощью lapply(). Затем нужно определить номер столбца, имеющего максимальное и минимальное значений для каждой строки таблицы. Используйте для этого функции which.min() и which.max() возвращающие индекс максимального и минимального элемента вектора, в комбинации с функцией colnames(), возвращающей названия переменных. Применяйте функцию apply(), которая умеет ходить по строкам.\n\n\n\n\n\nСамсонов Т.Е. Визуализация и анализ географических данных на языке R. М.: Географический факультет МГУ, lubridate::year(Sys.Date()). DOI: 10.5281/zenodo.901911",
    "crumbs": [
      "Основы",
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Функции</span>"
    ]
  },
  {
    "objectID": "05-BaseGraphics.html#yfxcharts",
    "href": "05-BaseGraphics.html#yfxcharts",
    "title": "5  Базовая графика",
    "section": "5.1 Стандартные графики",
    "text": "5.1 Стандартные графики\nГрафики (точечные и линейные) – базовый и наиболее часто используемый способ визуализации. Универсальная функция plot() позволяет строить графики по координатам \\(X\\) и \\(Y\\), которые передаются, соответственно, в первый и второй аргумент. Если переменные \\(X\\) и \\(Y\\) не связаны друг с другом явным образом, то такой график называется диаграммой рассеяния.\n\n5.1.1 Диаграммы рассеяния\nДиаграмма рассеяния позволяет установить, есть ли зависимость между переменными, а также понять, как объекты дифференцируются по значениям переменных.\n\npar(mar=c(4,4,3,2))\n# Диаграмма рассеяния по экспорту и импорту:\nplot(sub$МетЭкспорт, \n     sub$МетИмпорт,\n     col=\"red\", \n     xlab=\"Экспорт, млн. долл. США\", \n     ylab = \"Импорт, млн. долл. США\", \n     main = \"Экспорт/импорт металлов и изделий из них по субъектам РФ\")\n\n\n\n\n\n\n\n\nВ данном случае четко выделяется группа субъектов вблизи начала координат, не отличающихся интенсивным экспортом и импортом продукции металлургии, а также очевидно преобладание экспорта над импортом при больших объемах товарооборота.\nПри построении диаграмм рассеяния важно сохранить одинаковый масштаб по осям \\(X\\) и \\(Y\\). Чтобы обеспечить это условие, необходимо использовать параметр asp = 1:\n\nplot(sub$МетЭкспорт, \n     sub$МетИмпорт, \n     col=\"red\", \n     xlab=\"Экспорт, млн. долл. США\", \n     ylab = \"Импорт, млн. долл. США\", \n     main = \"Экспорт/импорт металлов и изделий из них по субъектам РФ\", \n     asp = 1)\n\n\n\n\n\n\n\n\nПопробуйте изменить размер окна на вкладке Plots. Вы увидите, что масштаб по осям сохраняется пропорциональным.\nРазмер и тип значка можно изменить, используя параметры pch = и cex =. Размеры масштабируются параметром cex относительно условной единицы — стандартного размер значка. Сам значок можно выбрать, используя его код в соответствии с нижеприведенным рисунком (на самом деле, вы можете выбирать произвольные символы для визуализации точек):\n\n\n\nТипы символов R\n\n\n\nplot(sub$МетЭкспорт, \n     sub$МетИмпорт, \n     col=\"red\", \n     xlab=\"Экспорт, млн. долл. США\", \n     ylab = \"Импорт, млн. долл. США\", \n     main = \"Экспорт/импорт металлов и изделий из них по субъектам РФ\", \n     asp = 1,\n     pch = 2, \n     cex = 0.5)\n\n\n\n\n\n\n\nplot(sub$МетЭкспорт, \n     sub$МетИмпорт, \n     col=\"red\", \n     xlab=\"Экспорт, млн. долл. США\", \n     ylab = \"Импорт, млн. долл. США\", \n     main = \"Экспорт/импорт металлов и изделий из них по субъектам РФ\", \n     asp = 1,\n     pch = 20, \n     cex = 1.2)\n\n\n\n\n\n\n\n\n\n\n5.1.2 Линейные графики\nЛинейные графики отражают связь между зависимой и независимой переменной. Существует два способа нанесения линий на график: явное рисование линий поверх уже построенного графика с помощью функции lines(), или создание нового линейного графика с помощью функции plot() с дополнительным параметром type =.\nДля иллюстрации принципов работы первого способа откроем еще раз данные по объему сброса загрязненных сточных вод по морям России (млрд куб. м):\n\ntab = read.csv2(\"data/oxr_vod.csv\", encoding = 'UTF-8')\nplot(tab$Год, tab$Каспийское, pch=20) # для начала нанесем точки\nlines(tab$Год, tab$Каспийское) # теперь нанесем линии\n\n\n\n\n\n\n\n\nПо умолчанию функция plot() рисует именно точки. Однако если точки не нужны, а достаточно только линий, или требуется иной подход к построению графиков, можно задать параметр type =, который принимает следующие значения:\n\n\"p\" for points,\n\"l\" for lines,\n\"b\" for both,\n\"c\" for the lines part alone of “b”,\n\"o\" for both ‘overplotted’,\n\"h\" for ‘histogram’ like (or ‘high-density’) vertical lines,\n\"s\" for stair steps,\n\"S\" for other steps, see ‘Details’ below,\n\"n\" for no plotting.\n\nПопробуем разные методы визуализации:\n\nplot(tab$Год, tab$Карское,pch=20)\n\n\n\n\n\n\n\nplot(tab$Год, tab$Каспийское, type=\"p\")\n\n\n\n\n\n\n\nplot(tab$Год, tab$Каспийское, type=\"l\")\n\n\n\n\n\n\n\nplot(tab$Год, tab$Каспийское, type=\"b\")\n\n\n\n\n\n\n\nplot(tab$Год, tab$Каспийское, type=\"c\")\n\n\n\n\n\n\n\nplot(tab$Год, tab$Каспийское, type=\"o\")\n\n\n\n\n\n\n\nplot(tab$Год, tab$Каспийское, type=\"h\")\n\n\n\n\n\n\n\nplot(tab$Год, tab$Каспийское, type=\"s\")\n\n\n\n\n\n\n\n\nТолщину и тип линии можно изменить, используя параметры lwd = и lty = соответственно. Работают они аналогично параметрам pch и cex для точечных символов. Типов линий по умолчанию в стандартной библиотеке R не так много, но в сочетании с цветовым кодированием и толщиной их оказывается вполне достаточно: \nПопробуем разные варианты представления линий:\n\nplot(tab$Год, tab$Каспийское, type=\"l\", lwd = 2, lty = 1)\n\n\n\n\n\n\n\nplot(tab$Год, tab$Каспийское, type=\"l\", lwd = 3, lty = 2)\n\n\n\n\n\n\n\nplot(tab$Год, tab$Каспийское, type=\"l\", lwd = 1, lty = 3)\n\n\n\n\n\n\n\n\n\n\n5.1.3 Совмещение графиков\nЧасто бывает необходимо совместить на одном графике несколько рядов данных. Для этого можно поступить двумя путями:\n\nНарисовать один ряд данных c помощью функции plot(), а затем добавить к нему другие ряды с помощью функций points() и lines().\nНарисовать пустой график, а затем добавить к нему все ряды данных с помощью функций points() и lines().\n\n\nПри совмещении нескольких рядов данных на одном графике в первом же вызове функции plot() необходимо заложить диапазон значений по осям \\(X\\) и \\(Y\\), охватывающий все ряды данных. В противном случае будет учтен только разброс значений первого ряда данных, и остальные ряды могут не поместиться в поле графика.\n\nВариант №1 реализуется следующим образом:\n\nplot(tab$Год, \n     tab$Каспийское, \n     pch=20, \n     type=\"o\", \n     ylim = c(0,12), \n     col=\"red3\")\n\n# Добавим теперь на существующий график новый ряд данных, используя функции points() и lines():\npoints(tab$Год, tab$Карское, pch=20, col=\"forestgreen\")\nlines(tab$Год, tab$Карское, pch=20, col=\"forestgreen\")\n\n\n\n\n\n\n\n\n\nОбратите внимание на то, что если бы мы вызвали еще одну инструкцию plot() с новым рядом данных, это привело бы к построению нового графика, а не к добавлению его на существующий.\n\nТеперь рассмотрим второй вариант. Заодно устраним недостаток предыдущего кода, в котором диапазон значений по оси \\(Y\\) указывался вручную.\n\nxrange = range(tab$Год) # вычислим диапазон по оси X\nyrange = range(tab$Каспийское, tab$Карское, tab$Азовское) # вычислим диапазон по оси Y\n\n# Построим пустой график, охватывающий полный диапазон данных, и имеющий все необходимые сопроводительные элементы\nplot(xrange,\n     yrange,\n     main=\"Объем сброса загрязненных сточных вод\", \n     xlab=\"Год\", \n     ylab=\"млрд.куб.м\",\n     type = \"n\") # n означает, что ряд данных рисоваться не будет\n\n# Теперь добавим на график ряды данных\npoints(tab$Год, tab$Каспийское, pch=20, col=\"red3\")\nlines(tab$Год, tab$Каспийское, pch=20, col=\"red3\")\n\npoints(tab$Год, tab$Карское, pch=20, col=\"forestgreen\")\nlines(tab$Год, tab$Карское, pch=20, col=\"forestgreen\")\n\npoints(tab$Год, tab$Азовское, pch=20, col=\"steelblue\")\nlines(tab$Год, tab$Азовское, pch=20, col=\"steelblue\")\n\n\n\n\n\n\n\n\n\n\n5.1.4 Функциональные параметры\nГрафические параметры при построении графиков на самом деле могут быть не константами, а функцией данных. Например, вы можете сказать, что размер точки при построении диаграммы рассеяния должен быть функцией отношения экспорта к импорту, что усилит наглядность отображения:\n\nplot(okr$МетЭкспорт, \n     okr$МетИмпорт, \n     col=rgb(1,0,0,0.5), \n     xlab=\"Экспорт, млн. долл. США\", \n     ylab = \"Импорт, млн. долл. США\", \n     main = \"Экспорт/импорт металлов и изделий из них по ФО РФ (2013 г.)\", \n     asp = 1,\n     pch = 20, \n     cex = 2+log(sub$МетИмпорт/sub$МетЭкспорт)) # размер кружка зависит от соотношения импорта и экспорта",
    "crumbs": [
      "Графика и статистика",
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>Базовая графика</span>"
    ]
  },
  {
    "objectID": "05-BaseGraphics.html#histograms",
    "href": "05-BaseGraphics.html#histograms",
    "title": "5  Базовая графика",
    "section": "5.2 Гистограммы",
    "text": "5.2 Гистограммы\nГистограммы распределения строятся с помощью функции hist(). Чтобы изменить ширину кармана (столбца) гистограммы, необходимо задать параметр breaks =, а цвет задается в параметре col:\n\nhist(sub$ПродЭкспорт)\n\n\n\n\n\n\n\n# Карманы будут от 0 до 3000 через 100. Заодно добавим цвет:\nhist(sub$ПродЭкспорт, breaks = seq(0,3000,100), col=\"olivedrab3\")\n\n\n\n\n\n\n\n\nПри построении гистограммы (как и любого другого типа графика) вы можете использовать не весь массив данных, а только его подмножество Например, можно посмотреть гистограмму только для субъектов с объемом экспорта менее 300:\n\nhist(sub$ПродЭкспорт[sub$ПродЭкспорт &lt; 300], col = \"olivedrab3\", breaks = seq(0, 300, 20))\n\n\n\n\n\n\n\n\nНаконец, вы можете осуществить преобразование ряда данных перед построением гистограммы. Например, взять логарифм, чтобы проверить,похоже ли распределение на логнормальное:\n\nhist(log(sub$ПродЭкспорт), col = \"olivedrab3\")",
    "crumbs": [
      "Графика и статистика",
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>Базовая графика</span>"
    ]
  },
  {
    "objectID": "05-BaseGraphics.html#barplots",
    "href": "05-BaseGraphics.html#barplots",
    "title": "5  Базовая графика",
    "section": "5.3 Столбчатые графики",
    "text": "5.3 Столбчатые графики\nСтолбчатые графики — barplot — отображают вектор числовых данных в виде столбиков. Это простейший вид графика (наряду с dotchart), который используется для сравнения абсолютных величин. Для построения необходимо вызвать функцию barplot() и передать ей столбец таблицы:\n\nbarplot(okr$ХимЭкспорт)\n\n\n\n\n\n\n\n\n# Или даже просто вектор натуральных чисел от -5 до 5:\nbarplot(-5:5)\n\n\n\n\n\n\n\n\n# Если у каждого столбика есть название, \n# нужно передать вектор названий в аргумент names.arg = \nbarplot(okr$ХимЭкспорт, names.arg = okr$Регион)\n\n\n\n\n\n\n\n\n# при наличии длинных подписей удобнее столбчатую диаграмму разместить горизонтально, используя параметр horiz = TRUE.\nbarplot(okr$ХимЭкспорт, names.arg = okr$Регион, horiz=TRUE)\n\n\n\n\n\n\n\n\nЧтобы развернуть подписи перпендикулярно столбцам, следует использовать параметр las =. Справка__R__говорит нам о том, что этот параметр дает следующее поведение подписей:\n\n0: всегда параллельно осям (по умолчанию),\n1: всегда горизонтально,\n2: всегда перпендикулярно осям,\n3: всегда вертикально.\n\nВыберем вариант, при котором подписи всегда горизонтальны:\n\nbarplot(okr$ХимЭкспорт, names.arg = okr$Регион, horiz=TRUE, las = 1)\n\n\n\n\n\n\n\n\nВ данном случае очень массивные названия федеральных не умещаются в пространство графика. Можно было бы вполне убрать словосочетание “федеральный округ”. Для этого используем уже знакомую нам sub().\n\nnames = sub(\"федеральный округ\", \"\", okr$Регион) # \"\" - означает пустая строка\nbarplot(okr$ХимЭкспорт, names.arg = names, horiz = TRUE, las = 1)\n\n\n\n\n\n\n\n\nИ снова содержимое не поместилось в поле графика. Проблема в том, что вокруг любого графика резервируются поля ограниченного размера для размещения подписей координат и т.д. Автоматически эти поля не пересчитываются, зарезервировать их — ваша задача.\nНаберите в консоли ?par. Откроется список всевозможных графических параметров, которые управляют компоновкой и порядком построения графиков. Эти параметры можно установить, вызвав функцию par(). Все дальнейшие вызовы инструкций построения графиков будут учитывать установленные параметры Пролистайте страницу справки вниз и найдите параметр mar = — он отвечает за установку полей в условных единицах. Есть также параметр mai =, который позволяет установить поля графика в дюймах. Обратите внимание на то, что означают параметры этой функции:\n\n# mar=c(bottom, left, top, right)\n# The default is c(5, 4, 4, 2) + 0.1.\n\nПоскольку в нашем примере проблемы возникают в левым полем, необходимо увеличить второй параметр.\n\nmargins.default = par(\"mar\") # запишем текущее значение, чтобы восстановить его потом\npar(mar = c(5, 10, 4, 2)) # увеличим поле left до 10 условных единиц\nbarplot(okr$ХимЭкспорт, names.arg = names, horiz=TRUE, las = 1)\n\n\n\n\n\n\n\n\nДобавим заголовок с помощью параметра main =, а подпись единиц измерения по оси \\(X\\) — с помощью параметра xlab =. Поскольку количество параметров функции уже достаточно велико, введем каждый из них с новой строчки, чтобы улучшить читаемость кода:\n\nbarplot(okr$ХимЭкспорт, \n        names.arg = names, \n        main = \"Экспорт продукции химической промышленности\", \n        xlab = \"млн долл. США\", \n        horiz = TRUE, \n        las = 1)\n\n\n\n\n\n\n\n\n# Чтобы увеличить диапазон оси X, можно использовать параметр xlim = c(min, max):\nbarplot(okr$ХимЭкспорт, \n        names.arg = names, \n        main = \"Экспорт продукции химической промышленности\", \n        xlab = \"млн долл. США\", \n        horiz = TRUE, \n        las = 1, \n        xlim = c(0,12000))\n\n\n\n\n\n\n\n\nРабота с цветом на столбчатых диаграммах рассмотрена ниже в отдельном разделе.",
    "crumbs": [
      "Графика и статистика",
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>Базовая графика</span>"
    ]
  },
  {
    "objectID": "05-BaseGraphics.html#piecharts",
    "href": "05-BaseGraphics.html#piecharts",
    "title": "5  Базовая графика",
    "section": "5.4 Круговые (секторные) диаграммы",
    "text": "5.4 Круговые (секторные) диаграммы\nКруговые диаграммы (англ. piechart) строятся с помощью функции pie():\n\npar(mar = c(5, 5, 5, 5)) # установим поля\n\npie(okr$ХимЭкспорт)\n\n\n\n\n\n\n\n\n# вместо номеров можно использовать подписи секторов, добавив второй параметр:\npie(okr$ХимЭкспорт, names)\n\n\n\n\n\n\n\n\n# в каждую метку можно добавить процент данного округа в общей массе. Для этого его нужно сначала посчитать:\npercentage = 100 * okr$ХимЭкспорт / sum(okr$ХимЭкспорт)\n\n# и округлить до 1 знака после запятой:\npercentage = round(percentage, digits = 1)\n\nМожно присоединить проценты к названиям округов, добавив обрамляющие скобки. Чтобы функция paste не добавляя пробелы между присоединяемыми строками, необходимо задать параметр sep = , передав ему пустую строку — ““:\n\n\nnames2=paste(names, \" (\", percentage, \"%)\", sep = \"\")\n\n# Используем для аннотирования круговых секторов:\npie(okr$ХимЭкспорт, names2)\n\n\n\n\n\n\n\n\n# Добавить заголовок можно также с помощью параметра main =\npie(okr$ХимЭкспорт, names2, main = \"Доля федеральных округов в экспорте продукции химической промышленности\")\n\n\n\n\n\n\n\n\nЧтобы перенести часть заголовка на вторую строку, вы можете использовать управляющий символ перевода строки \\n, вставив его в требуемое место:\n\npie(okr$ХимЭкспорт, names2, main = \"Доля федеральных округов в экспорте \\n продукции химической промышленности\")\n\n\n\n\n\n\n\n\n\nУправляющие символы играют большое значение в программировании и используются для управления поведением текстового вывода. Нотация \\n называется escape-последовательностью. Помимо перевода строки, есть и другие полезные управляющие символы. Кстати, именно из-за того, что escape-последовательности начинаются с обратной косой черты (\\), при указании системных путей в функции setwd() всегда следует использовать прямую косую черту (/). Например, следующий путь не будет найдет, поскольку он содержит управляющие последовательности \\n и \\t: C:\\data\\tables\\new.\n\nНаконец, при использовании секторных диаграмм важно уметь менять порядок секторов. По умолчанию сектора откладываются против часовой стрелки начиная с восточного направления. Чтобы сектора откладывались по часовой стрелке с северного направления, следует задать параметр clockwise = TRUE.\n\npie(okr$ХимЭкспорт, \n    names2, \n    main = \"Доля федеральных округов в экспорте \\n продукции химической промышленности\", \n    clockwise = TRUE)\n\n\n\n\n\n\n\n\nРабота с цветом на круговых диаграммах рассмотрена ниже в отдельном разделе.",
    "crumbs": [
      "Графика и статистика",
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>Базовая графика</span>"
    ]
  },
  {
    "objectID": "05-BaseGraphics.html#colors",
    "href": "05-BaseGraphics.html#colors",
    "title": "5  Базовая графика",
    "section": "5.5 Цвет и прозрачность",
    "text": "5.5 Цвет и прозрачность\nЦвет — одно из основных графических средств, используемых на графиках и диаграммах, поэтому данная тема рассмотрена более подробно в отдельном разделе. Определить цвет можно различными способами. Во-первых, в R есть палитра предопределенных цветов, которые можно выбирать по их названию).\nСписок названий цветов можно посмотреть, вызвав функцию colors():\n\nhead(colors())\n## [1] \"white\"         \"aliceblue\"     \"antiquewhite\"  \"antiquewhite1\"\n## [5] \"antiquewhite2\" \"antiquewhite3\"\n\nОсновной цвет любого графика или диаграмма задается параметром col =. Это цвет (или цвета) с помощью которых будут отображаться данные. Попробуем изменить цвет графика с серого на пастельно-синий:\n\npar(mar = c(5, 10, 4, 2)) # увеличим поле left до 10 условных единиц\nbarplot(okr$ХимЭкспорт, \n        names.arg = names, \n        main = \"Экспорт продукции химической промышленности\", \n        xlab = \"млн долл. США\", \n        horiz = TRUE, \n        las = 1, \n        xlim = c(0,12000), \n        col = \"steelblue\")\n\n\n\n\n\n\n\n\nПомимо этого вы можете задать цвет с помощью цветовых компонент в различных пространствах. Для этого вы должны быть знакомы с основами теории цвета (посмотрите презентацию UsingColorInR.pdf. Например, фиолетовый цвет в пространстве RGB можно задать с помощью функции rgb(), смешав синюю и красную компоненты:\n\nviolet = rgb(0.4, 0, 0.6)\nbarplot(okr$ХимЭкспорт, \n        names.arg = names, \n        main = \"Экспорт продукции химической промышленности\", \n        xlab = \"млн долл. США\", \n        horiz = TRUE, \n        las = 1, \n        xlim = c(0,12000), \n        col = violet)\n\n\n\n\n\n\n\n\nЧтобы сделать цвет полупрозрачным, есть две возможности:\n\nПри создании нового цвета — передать в функцию rgb() дополнительный параметр alpha =, который задает долю прозрачности в диапазоне от 0 до 1.\nПри модификации существующего цвета — вызвать функцию adjustcolor() с параметром alpha =\n\nНапример:\n\nviolet.transp = adjustcolor(violet, alpha = 0.5)\nbarplot(okr$ХимЭкспорт, \n        names.arg = names, \n        main = \"Экспорт продукции химической промышленности\", \n        xlab = \"млн долл. США\", \n        horiz = TRUE, \n        las = 1, \n        xlim = c(0,12000), \n        col = violet.transp)\n\n\n\n\n\n\n\n\ngreen.transp = rgb(0, 1, 0, 0.5) # появился четвертый параметр\nbarplot(okr$ХимЭкспорт, \n        names.arg = names, \n        main = \"Экспорт продукции химической промышленности\", \n        xlab = \"млн долл. США\", \n        horiz = TRUE, \n        las = 1, \n        xlim = c(0,12000), \n        col = green.transp)\n\n\n\n\n\n\n\n\n\nФункция adjustcolor() позволяет модифицировать все компоненты цвета, не только прозрачность.\n\nНа графике типа barplot вы имеете фактически несколько переменных, которые представлены столбиками. А это означает что для них можно использовать различные цвета. Вы можете передать в параметр col = вектор из цветов, соответствующих столбикам:\n\ncolors = c(\"red\", \"green\", \"blue\", \"orange\", \"yellow\", \"pink\", \"white\",\"black\")\n\nbarplot(okr$ХимЭкспорт, \n        names.arg = names, \n        main = \"Экспорт продукции химической промышленности\", \n        xlab = \"млн долл. США\", \n        horiz = TRUE, \n        las = 1, \n        xlim = c(0,12000), \n        col = colors)\n\n\n\n\n\n\n\n\nНа самом деле, такой винегрет из цветов на столбчатых диаграммах использовать не принято. Но вы должны понимать, что при необходимости можно поменять цвет отдельно выбранных столбиков. Например, мы можем показать красным цветом Центральный и Приволжский округа, которые являются лидерами по экспорту продукции химической промышленности:\n\ncolors = rep(\"gray\", 8) # сделаем 8 серых цветов\ncolors[2] = \"red\"\ncolors[7] = \"red\"\nbarplot(okr$ХимЭкспорт, \n        names.arg = names, \n        main = \"Экспорт продукции химической промышленности\", \n        xlab = \"млн долл. США\", \n        horiz = TRUE, \n        las = 1, \n        xlim = c(0,12000), \n        col = colors)\n\n\n\n\n\n\n\n\nЕще одна интересная особенность использования цвета заключается в том, что количество указанных цветом может не совпадать с количеством рядов данных. Вы можете указать 2 или 3 цвета, и они будут циклически повторяться при визуализации данных:\n\ncolors=c(\"gray\",\"steelblue\")\nbarplot(okr$ХимЭкспорт, \n        names.arg = names, \n        main = \"Экспорт продукции химической промышленности\", \n        xlab = \"млн долл. США\", \n        horiz =TRUE, \n        las = 1, \n        xlim = c(0, 12000), \n        col = colors)\n\n\n\n\n\n\n\n\nНаконец, вещь, которой совершенно необходимо уметь пользоваться при работе с цветом в R — это цветовые палитры. Палитры чрезвычайно удобны, когда необходимо сгенерировать множество цветов, зная лишь основные оттенки. Для этого нужно создать палитру, используя функцию colorRampPalette():\n\n# задаем 2 опорных цвета: черный  белый\npalet=colorRampPalette(c(\"black\",\"white\")) \n\n# и автоматически генерируем 8 цветов между ними:\ncolors=palet(8)\n\n# используем их для отображения:\nbarplot(okr$ХимЭкспорт, \n        names.arg = names, \n        main = \"Экспорт продукции химической промышленности\", \n        xlab = \"млн долл. США\", \n        horiz = TRUE, \n        las = 1, \n        xlim = c(0, 12000), \n        col= colors)\n\n\n\n\n\n\n\n\n# вы можете включить в палитру произвольное количество цветов:\npalet=colorRampPalette(c(\"steelblue\",\"white\",\"purple4\")) \ncolors=palet(8)\nbarplot(okr$ХимЭкспорт, \n        names.arg = names, \n        main = \"Экспорт продукции химической промышленности\", \n        xlab = \"млн долл. США\", \n        horiz=TRUE, \n        las = 1, \n        xlim = c(0, 12000), \n        col= colors)\n\n\n\n\n\n\n\n\nВ R существует множество стандартных палитр, их список можно найти в справке и документации. Наиболее полезные из них:\n\ncolors()\ngray()\nrainbow()\nheat.colors()\ntopo.colors()\nterrain.colors()\n\nНапример, вы можете изменить цвета диаграммы, взяв их из одной из палитр или выбрав случайным образом из полной палитры цветов, используя функцию sample():\n\npie(okr$ХимЭкспорт, names2, main = \"Доля федеральных округов в экспорте \\n продукции химической промышленности\", col=rainbow(length(names2)))\n\n\n\n\n\n\n\npie(okr$ХимЭкспорт, names2, main = \"Доля федеральных округов в экспорте \\n продукции химической промышленности\", col=sample(colors(),5))\n\n\n\n\n\n\n\n\nБолее богатый набор палитр можно найти в библиотеке RColorBrewer, которая представляет собой интерпретацию палитр, доступных на сайте colorbrewer2.org\n\nlibrary(RColorBrewer) # Откроем библиотеку RColorBrewer:\ndisplay.brewer.all() # Посмотрим, какие в ней имеются палитры\n\n\n\n\n\n\n\n\nК каждой из этих палитр можно обратиться по названию с помощью функции brewer.pal(). Поскольку нам необходимы цвета для категориальных данных, следует использовать палитры из средней части (Set3 - Accent)\n\n# выберем цвета из палитры Set2 по количеству секторов в круге:\ncolors = brewer.pal(length(names2),\"Set1\")\n\n# И используем их при визуализации\npar(mar = c(5, 5, 5, 5)) # установим поля\npie(okr$ХимЭкспорт, names2, main = \"Доля федеральных округов в экспорте \\n продукции химической промышленности\", col=colors)\n\n\n\n\n\n\n\n\n# Попробуем палитру Accent:\npie(okr$ХимЭкспорт, names2, main = \"Доля федеральных округов в экспорте \\n продукции химической промышленности\", col=brewer.pal(length(names2),\"Accent\"))",
    "crumbs": [
      "Графика и статистика",
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>Базовая графика</span>"
    ]
  },
  {
    "objectID": "05-BaseGraphics.html#disp_settings",
    "href": "05-BaseGraphics.html#disp_settings",
    "title": "5  Базовая графика",
    "section": "5.6 Настройки отображения",
    "text": "5.6 Настройки отображения\n\n5.6.1 Графические параметры\nИзменять размеры элементов графика можно независимо друг от друга, используя следующие параметры:\n\ncex — общий масштаб элементов на графике\ncex.axis — масштаб подписей координат на оси\ncex.lab — масштаб подписей названий осей\ncex.main — масштаб заголовка графика\ncex.sub — масштаб подзаголовка графика\ncex.names — масштаб подписей факторов (для некоторых типов диаграмм)\n\nНапример:\n\nplot(tab$Год, \n     tab$Каспийское, \n     pch=20, \n     type=\"o\", \n     ylim = c(0,12), \n     col=\"red3\", \n     main=\"Объем сброса загрязненных сточных вод\", \n     xlab=\"Год\", \n     ylab=\"млрд.куб.м\",\n     cex.axis=0.8, \n     cex.lab=0.7, \n     cex.main=0.9, \n     cex = 0.8)\n\npoints(tab$Год, tab$Карское, pch=20, col=\"forestgreen\",cex = 0.8)\nlines(tab$Год, tab$Карское, pch=20, col=\"forestgreen\")\n\npoints(tab$Год, tab$Азовское, pch=20, col=\"steelblue\",cex = 0.8)\nlines(tab$Год, tab$Азовское, pch=20, col=\"steelblue\")\n\n\n\n\n\n\n\n\nАналогично происходит тонкая настройка цвета:\n\ncol цвет графика\ncol.axis цвет подписей координат\ncol.lab цвет названий осей\ncol.main цвет заголовка\ncol.sub цвет подзаголовка\nfg цвет элементов переднего плана (оси, рамка и т.д.)\nbg цвет фона графика (background)\n\n\nplot(tab$Год, \n     tab$Каспийское, \n     pch=20, \n     type=\"o\", \n     ylim = c(0,12), \n     col=\"red3\", \n     main=\"Объем сброса загрязненных сточных вод\", \n     xlab=\"Год\", \n     ylab=\"млрд.куб.м\",\n     cex.axis=0.8, \n     cex.lab=0.7, \n     cex.main=0.9, \n     col.lab = \"grey50\", \n     fg = \"grey40\")\npoints(tab$Год, tab$Карское, pch=20, col=\"forestgreen\")\nlines(tab$Год, tab$Карское, pch=20, col=\"forestgreen\")\npoints(tab$Год, tab$Азовское, pch=20, col=\"steelblue\")\nlines(tab$Год, tab$Азовское, pch=20, col=\"steelblue\")\n\n\n\n\n\n\n\n\n\n\n5.6.2 Разметка осей, рамка, сетка координат и произвольные линии\nПо умолчанию R подбирает оптимальный с точки зрения него шаг разметки осей, в зависимости от разброса значений по осям \\(X\\) и \\(Y\\), а также размеров графического устройства, на котором производится рисование. Изменяя размер окна прорисовки, вы получите различную разметку осей.\nВ то же время, часто возникает желание (или необходимость) самостоятельно управлять шагом разметки сетки. Для этого необходимо:\n\nВызвать функцию plot(), передав ей дополнительно параметр axes = FALSE (убирает при рисовании обе оси) или один из параметров xaxt=\"n\" / yaxt=\"n\" (убирают оси \\(X\\) и \\(Y\\) соответственно)\nВызвать столько раз функцию axis(), сколько вы хотите нарисовать осей, передав ей параметры для рисования каждой оси.\n\nФункция axis() принимает следующие параметры:\n\nside — сторона графика, на которой будет нарисована ось (1=bottom, 2=left, 3=top, 4=right)\nat — вектор значений, в которых должны быть нарисованы метки оси\nlabels — вектор подписей, которые будут нарисованы в местоположениях, указанных в параметре at. Этот параметр можно пропустить, если подписи совпадают с местоположениями меток\npos — координата, вдоль которой будет нарисована ось\nlty — тип линии\ncol — цвет линии и меток\nlas — расположение подписей параллельно (\\(0\\)) или перпендикулярно (\\(2\\)) оси\ntck — длина метки относительно размера графика. Отрицательные значения дают метки, выходящие за пределы графика. положительные — внутрь графика. \\(0\\) убирает метки, \\(1\\) рисует линии сетки.\n\nПри ручном построении осей полезно сразу же нарисовать рамку вокруг графика, используя функцию box().\nНапример:\n\nplot(tab$Год, \n     tab$Каспийское,\n     type = \"l\",\n     axes = FALSE)\n\naxis(side = 1, \n     at = seq(min(tab$Год), max(tab$Год), 1),\n     tck = -0.02,\n     labels = FALSE) # разметим ось X через 1 год, но рисовать подписи не будем\n\naxis(side = 1, \n     at = seq(min(tab$Год), max(tab$Год), 3), # а подписи расставим через 3 года\n     tck = 0) # но рисовать метки не будем\n\n# разметим ось Y через 1 млрд куб. м., округлив предварительно минимальное и максимальное значение до ближайшего целого снизу и сверху соответственно\naxis(side = 2, \n     at = seq(floor(min(tab$Каспийское)), ceiling(max(tab$Каспийское)), 1),\n     tck = -0.02) \n\nbox() # добавим рамку для красоты\n\n\n\n\n\n\n\n\nДля размещения сетки координат существует функция grid(nx = NULL, ny = nx, col = \"lightgray\", lty = \"dotted\", lwd = par(\"lwd\"), equilogs = TRUE). Как видно из набора ее параметров, сетка определяется количеством линий в горизонтальном и вертикальном направлении. Это не всегда бывает удобно, поскольку как правило мы хотим задать шаг сетки конкретной величины. По умолчанию, однако, линии сетки выбираются автоматически, как и метки:\n\nplot(tab$Год, \n     tab$Каспийское,\n     type = \"l\",\n     col = \"red\")\ngrid()\n\n\n\n\n\n\n\n\nВы, разумеется, можете поменять их количество, однако R не будет за вас согласовывать шаг сетки и шаг меток осей, поскольку метки генерируются на стадии рисования plot() или axis() и не запоминаются.\n\nplot(tab$Год, \n     tab$Каспийское,\n     type = \"l\",\n     col = \"red\")\ngrid(10, 5)\n\n\n\n\n\n\n\n\nФункция grid() на самом деле является оберткой функции abline(), которая позволяет рисовать произвольные линии на графике. Дана функция предоставляет следующие возможности построения линий и серий линий:\n\na, b — коэффициенты уравнения \\(y = ax + b\\). Таким образом можно определить только одну линию.\ncoef — принимает вектор из двух значений, которые интерпретируются как a и b. То есть, это альтернативная форма записи предыдущего случая.\nh — значение (значения) координат \\(y\\) для горизонтальной линии (серии горизонтальных линий). То есть, вы можете передать в этот параметр как одиночное значение, так и вектор значений. В зависимости это этого нарисуется одна горизонтальная линия или серия горизонтальных линий.\nv — значение (значения) координат \\(x\\) для вертикальной линии (серии вертикальных линий). Работает аналогично параметру h.\nreg — сюда можно передать объект, обладающий методом coef(). Этот способ можно использовать для рисования линий регрессии.\n\nПредположим теперь, что вы хотите нарисовать сетку с шагом в 1 год по горизонтальной оси и шагом 1 млрд. куб. м по оси вертикальной. При этом вы также хотите, чтобы линии сетки располагались под графиком, а не поверх его. Также необходимо выделить особым цветом значение в 10 млрд м\\(^3\\) по оси \\(Y\\). Для этого выполним следующую последовательность действий:\n\nplot(tab$Год, \n     tab$Каспийское, \n     type=\"n\") # режим 'n' позволяет ничего не рисовать, но заложить поле графика в соответствии с данными, указанными в параметрах x и y\n\n# Вычисляем линии сетки\nxlines = seq(min(tab$Год), max(tab$Год), 1)\nylines = seq(ceiling(min(tab$Каспийское)),\n              floor(max(tab$Каспийское)), 1)\n\n# Рисуем линии сетки\nabline(h = ylines, v = xlines, col = \"lightgray\")\n\n# Рисуем график\nlines(tab$Год, \n     tab$Каспийское, \n     col=\"red3\")\npoints(tab$Год, \n     tab$Каспийское,\n     pch = 20,\n     col=\"red3\")\n\n# Выделяем значение 10 по оси Y:\nabline(h = 10, col = \"blue\", lwd = 2)\n\n# Рисуем дополнительно рамку, т.к. сетку координат мы рисовали после графика\nbox()\n\n\n\n\n\n\n\n\n\n\n5.6.3 Аннотации данных (текст на графике)\nАннотации данных добавляются на график с помощью функции text(). В качестве трех обязательных аргументов ей необходимо передать координаты точек размещения текста, и вектор подписей. Также полезным будет указать параметр pos=, отвечающий за размещение аннотации относительно точки. Значения pos, равные 1, 2, 3 и 4, соответствуют размещению снизу, слева, сверху и справа от точки:\n\ntext(tab$Год, \n     tab$Каспийское,\n     labels = tab$Каспийское,\n     cex = 0.75,\n     pos = 3)\n\n\n\n\n\n\n\n\n\n\n\nК сожалению, стандартный механизм размещения аннотаций пакета graphics не обладает возможностью устранения конфликтов подписей. Однако это возможно для графиков, построенных с помощью библиотек lattice и ggplot2. Для этого можно воспользоваться пакетом directlabels или ggrepel.",
    "crumbs": [
      "Графика и статистика",
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>Базовая графика</span>"
    ]
  },
  {
    "objectID": "05-BaseGraphics.html#legend",
    "href": "05-BaseGraphics.html#legend",
    "title": "5  Базовая графика",
    "section": "5.7 Легенда",
    "text": "5.7 Легенда\nЛегенда к графику размещается с помощью функции legend(). Эта функция принимает несколько аргументов, включая: местоположение, заголовок, названия элементов, графические параметры. Местоположение может быть задано координатами \\((x,y)\\) в системе координат графика, но удобнее пользоваться следующими предопределенными константами: \"bottomright\", \"bottom\", \"bottomleft\", \"left\", \"topleft\", \"top\", \"topright\", \"right\", \"center\".\nЧтобы в легенде появились точки, необходимо задать параметр pch=. Для линейной легенды, следует задать, соответственно, параметр lty = и/или lwd =. Каждый из этих параметров должен быть вектором по количеству элементов легенды:\n\npar(mar = margins.default)\n\n# Найдем ограничивающий прямоугольник вокруг всех рядов данных\nxrange = range(tab$Год)\nyrange = range(tab$Каспийское, tab$Карское, tab$Азовское)\n\n# Построим пустой график с разметкой осей и всеми заголовками\nplot(xrange, \n     yrange, \n     type=\"n\", \n     main=\"Объем сброса загрязненных сточных вод\", \n     xlab=\"Год\", \n     ylab=\"млрд.куб.м\",\n     cex.axis=0.8, \n     cex.lab=0.7, \n     cex.main=0.9, \n     col.lab = \"grey50\", \n     fg = \"grey40\")\n\n# Добавим на график сетку координат\ngrid()\n\n# Добавим на график данные\npoints(tab$Год, tab$Каспийское, pch=20, col=\"red3\")\nlines(tab$Год, tab$Каспийское, pch=20, col=\"red3\")\n\npoints(tab$Год, tab$Карское, pch=20, col=\"forestgreen\")\nlines(tab$Год, tab$Карское, pch=20, col=\"forestgreen\")\n\npoints(tab$Год, tab$Азовское, pch=20, col=\"steelblue\")\nlines(tab$Год, tab$Азовское, pch=20, col=\"steelblue\")\n\n# Определим положение, названия и цвета:\nmain = \"Море\"\nlocation = \"topright\"\nlabels = c(\"Каспийское\", \"Карское\", \"Азовское\")\ncolors = c(\"red3\", \"forestgreen\", \"steelblue\")\n\n# Если цвет передать в параметр fill, то по умолчанию\n# нарисуются цветовые плашки:\nlegend(location, labels, title = main, fill=colors)\n\n\n\n\n\n\n\n\n\npts = c(20, 20, 20) # каждый элемент показывается точкой типа 20\nlns = c(1, 1, 1) # каждый элемент показывается линией толщиной 1\n\n# теперь посмотрим на легенду (она нарисуется поверх старой)\nlegend(location, labels, title = main, col = colors, pch = pts, lwd = lns)\n\n\n\n\n\n\n\n\n\n\nБолее подробно с разнообразными опциями размещения легенды на графике вы можете познакомиться, набрав в консоли команду ?legend.",
    "crumbs": [
      "Графика и статистика",
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>Базовая графика</span>"
    ]
  },
  {
    "objectID": "05-BaseGraphics.html#graphics_review",
    "href": "05-BaseGraphics.html#graphics_review",
    "title": "5  Базовая графика",
    "section": "5.8 Краткий обзор",
    "text": "5.8 Краткий обзор\nДля просмотра презентации щелкните на ней один раз левой кнопкой мыши и листайте, используя кнопки на клавиатуре:\n\n\n\n\n\nПрезентацию можно открыть в отдельном окне или вкладке браузере. Для этого щелкните по ней правой кнопкой мыши и выберите соответствующую команду.",
    "crumbs": [
      "Графика и статистика",
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>Базовая графика</span>"
    ]
  },
  {
    "objectID": "05-BaseGraphics.html#questions_tasks_graphics",
    "href": "05-BaseGraphics.html#questions_tasks_graphics",
    "title": "5  Базовая графика",
    "section": "5.9 Контрольные вопросы и упражнения",
    "text": "5.9 Контрольные вопросы и упражнения\n\n5.9.1 Вопросы\n\nКакая функция базового пакета R отвечает за построение стандартных графиков (диаграмм рассеяния, линейных)?\nКакие функции стандартной библиотеки R позволяют построить: столбчатые диаграммы, круговые секторные диаграммы, гистограммы?\nКак задать интервал или количество интервалов гистограммы?\nМожно ли разместить столбчатую диаграмму горизыонтально? Если да, то как?\nКакая функция отвечает за установку параметров графической подсистемы?\nКак установить поля вокруг графиков?\nКак развернуть подписи на столбчатой диаграмме перпендикулярно оси?\nКак установить запрет на экспоненциальное представление больших чисел при рисовании графиков?\nКакой параметр отвечает за установку цвета в функциях построения графиков стандартной библиотеки R?\nКакие параметры отвечают за установку толщины и типа линии на графиках?\nКакие параметры отвечают за установку размера и типа значка на диаграммах рассеяния?\nКак совместить несколько графиков на одной сетке координат?\nКакая функция рисует рамку вокруг графика?\nКакая функция отвечает за рисование сетки координат?\nКак установить равный масштаб по осям графика?\nКакие параметры позволяют масштабировать текст элементов графика, таких как подписи координат, осей, заголовков и подзаголовков?\nНазовите способы задания цвета в R.\nКак сделать цвет в R полупрозрачным?\nНазовите стандартные цветовые палитры R.\nКак сгенерировать последовательность из нужного количества цветов между заданными опорными цветами?\nКакая функция позволяет разместить легенду на графике?\nКак сделать так, чтобы в легенде показывались точки? Линии? Цветовые плашки?\n\n\n\n5.9.2 Упражнения\n\nПостройте для набора данных quakes пакета datasets гистограммы распределения глубин и магнитуд, а также диаграмму рассеяния для двух этих характеристик.\nНа портале открытых данных Тульской области есть данные о распределении площади лесов и запасов древесины по преобладающим породам и группам возраста. Скачайте эти данные в виде таблицы CSV и постройте по ним круговую и столбчатую диаграмму для категории Площадь земель, занятых лесными насаждениями (покрытых лесной растительностью), всего. Подберите цвета, попробуйте изменить ориентировку столбцов на горизонтальную, а для круговой диаграммы поменять угол поворота.\nИспользуя данные1 по балансу масс ледника Гарабаши, постройте график с тремя кривыми (аккумуляции, абляции и кумулятивного баланса) за период 1981 по 2017 г. Добавьте на график легенду. Обратите внимание на то, что таблица содержит агрегирующие строки (1982-1997, 1998-2017, 1982-2017), которые вам необходимо предварительно исключить.\n\nПодсказка: Чтобы построить кривую кумулятивного баланса, используйте функцию cumsum.\n\nТаблица storms из пакета dplyr содержит данные трекинга тропических циклонов c 1975 по 2015 год. Извлеките из нее данные по одному выбранному циклону и постройте на их основе график, показывающий трек прохождения циклона в системе координат давление (X) — скорость (Y). Каждое наблюдение циклона визуализируйте в виде кружка, цвет которого зависит от класса циклона (переменная status), а размер — от диаметра территории, на которой наблюдаются скорости ветра класса тропического шторма и сильнее. Нанесите поверх кружков значение диаметра текстовой подписью. Соедините кружки линиями со стрелкой посередине, чтобы была понятна история жизни циклона.\n\nВ качестве образца используйте рисунок ниже, построенный для урагана Катрина:\n\n\n\n\n\nПример выполнения задания №5\n\n\n\n\n\nПодсказка: Скорость ветра и диаметр в таблице приведены в узлах и милях соответственно. Их необходимо перевести в м/с и км. Для отрисовки стрелок используйте функцию arrows(). Прочтите справку к ней, чтобы разобраться как она работает. Чтобы стрелка рисовалась посередине отрезка, а не в конце, используйте diff() для получения разностей в давлении и скорости между соседними наблюдениями циклона.\n\n\n\n\nСамсонов Т.Е. Визуализация и анализ географических данных на языке R. М.: Географический факультет МГУ, 2023. DOI: 10.5281/zenodo.901911",
    "crumbs": [
      "Графика и статистика",
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>Базовая графика</span>"
    ]
  },
  {
    "objectID": "06-AdvGraphics.html#advgraphics_prerequisites",
    "href": "06-AdvGraphics.html#advgraphics_prerequisites",
    "title": "6  Продвинутая графика",
    "section": "6.1 Предварительные требования",
    "text": "6.1 Предварительные требования\nДля работы по теме текущей лекции вам понадобятся пакеты ggplot2, dplyr и tidyr из tidyverse. Помимо этого, мы будем работать напрямую с данными Евростата, NASA POWER и USDA NRCS Soil Data Access к которым можно обращаться напрямую с использованием пакетов eurostat, nasapower и soildb:\n\nlibrary(tidyverse)\nlibrary(eurostat)\nlibrary(nasapower)\nlibrary(soilDB)\n\n\nПакет soilDB лучше устанавливать из консоли командой install.packages('soilDB', dependencies = TRUE). Указание параметра dependencies = TRUE обеспечит установку других пакетов, от которых он зависит.\n\nВ настоящей главе мы кратко познакомимся с системой ggplot2. gg расшифровывается как grammar of graphics. Под этим понимается определенная (какая — мы узнаем далее) система правил, позволяющих описывать и строить графики. ggplot довольно сильно отличается от стандартной графической подсистемы R. Прежде всего — модульным подходом к построению изображений. В ggplot вы собираете графики «по кирпичикам», отдельно определяя источник данных, способы изображения, параметры системы координат и т.д. – путем вызова и сложения результатов соответствующих функций.\nПри построении элементарных графиков ggplot может показаться (и по факту так и есть) сложнее, чем стандартная графическая подсистема. Однако при усложнении требований к внешнему виду и информационному насыщению графика сложность ggplot оказывается преимуществом, и с ее помощью относительно просто можно получать элегантные и информативные визуализации, на создание которых с помощью стандартной подсистемы пришлось бы затратить невероятные усилия! В этой главе мы кратко познакомимся с ggplot, а далее на протяжении курса будем регулярно ее использовать, осваивая новые возможности.",
    "crumbs": [
      "Графика и статистика",
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>Продвинутая графика</span>"
    ]
  },
  {
    "objectID": "06-AdvGraphics.html#advgraphics_eurostat",
    "href": "06-AdvGraphics.html#advgraphics_eurostat",
    "title": "6  Продвинутая графика",
    "section": "6.2 Загрузка данных Евростата",
    "text": "6.2 Загрузка данных Евростата\nТаблицы данных Евростата имеют уникальные коды, по которым их можно загружать, используя API (Application programming interface). В этой лекции мы будем работать с данными о крупнейших международных партнерах Евросоюза по импорту и экспорту основных видов товаров. Например, таблица данных по продуктам питания, напиткам и табаку имеет код EXT_LT_MAINAGRI:\n\n\n\n\n\n\n\n\n\nДля чтения таблиц по кодам в пакете eurostat имеется функция get_eurostat(). Чтобы год измерения получить в виде числа, а не объекта типа Date, используем второй параметр time_format = num. Для перехода от кодов продукции и стран к их полным наименованиям, дополнительно вызовем функцию label_eurostat() из того же пакета:\n\ntables = c('ext_lt_mainagri', 'ext_lt_mainrawm', 'ext_lt_mainmine',\n           'ext_lt_mainchem','ext_lt_mainmanu', 'ext_lt_mainmach')\n\ncountries = ISOcodes::ISO_3166_1$Alpha_2\n\ntrades = lapply(tables, function(X) { # прочтем несколько таблиц в список\n  get_eurostat(X) |&gt; filter(partner %in% countries) |&gt; label_eurostat()\n}) |&gt; \n  bind_rows() |&gt; # объединим прочитанные таблицы в одну\n  select(-geo) |&gt; # убираем столбец с территорией торговли, т.к. там только Евросоюз\n  filter(str_detect(indic_et, 'Exports in|Imports in')) |&gt; # оставим только экспорт и импорт\n  pivot_wider(names_from = indic_et, values_from = values) |&gt;  # вынесем данные по экспорту и импорту в отдельные переменные\n  rename(export = `Exports in million of ECU/EURO`, # дадим им краткие названия\n         import = `Imports in million of ECU/EURO`) |&gt; \n  mutate(partner = as.factor(partner))\n\ntrades # посмотрим, что получилось\n\n# A tibble: 25,710 × 5\n   sitc06                   partner              time       export import\n   &lt;chr&gt;                    &lt;fct&gt;                &lt;date&gt;      &lt;dbl&gt;  &lt;dbl&gt;\n 1 Food, drinks and tobacco Andorra              2022-01-01  340.     0.8\n 2 Food, drinks and tobacco United Arab Emirates 2022-01-01 3112.    64.3\n 3 Food, drinks and tobacco Afghanistan          2022-01-01   67.2   15.2\n 4 Food, drinks and tobacco Antigua and Barbuda  2022-01-01   17.2    0.7\n 5 Food, drinks and tobacco Anguilla (UK)        2022-01-01    1.3    0  \n 6 Food, drinks and tobacco Albania              2022-01-01  734.   234. \n 7 Food, drinks and tobacco Armenia              2022-01-01  171.    18.6\n 8 Food, drinks and tobacco Angola               2022-01-01  642.    50.4\n 9 Food, drinks and tobacco Antarctica           2022-01-01    0.3    0  \n10 Food, drinks and tobacco Argentina            2022-01-01  191.  6230. \n# ℹ 25,700 more rows",
    "crumbs": [
      "Графика и статистика",
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>Продвинутая графика</span>"
    ]
  },
  {
    "objectID": "06-AdvGraphics.html#advgraphics_nasapower",
    "href": "06-AdvGraphics.html#advgraphics_nasapower",
    "title": "6  Продвинутая графика",
    "section": "6.3 Загрузка данных NASA POWER",
    "text": "6.3 Загрузка данных NASA POWER\nNASA POWER — это проект NASA, предоставляющий метеорологические, климатические и энергетические данные для целей исследования возобновляемых источников энергии, энергетической эффективности зданий и сельскохозяйственных приложений. Доступ к этим данным, как и Евростату, можно получить через программный интерфейса (API), используя пакет nasapower.\nВ основе выгрузки данных лежат реанализы с разрешением \\(0.5^\\circ\\) Выгрузим данные по температуре, относительной влажности и осадкам в Екатеринбурге (\\(60.59~в.д.\\), \\(56.84~с.ш.\\)) за период с 1 по 30 апреля 1995 года:\n\ndaily_single_ag &lt;- get_power(\n  community = \"ag\",\n  lonlat = c(60.59, 56.84),\n  pars = c(\"RH2M\", \"T2M\"),\n  dates = c(\"1995-04-01\", \"1995-04-30\"),\n  temporal_api = \"daily\"\n)\n\ndaily_single_ag # посмотрим, что получилось\n\nАналогичным путем можно выгрузить данные, осредненные по годам. Например, можно получить данные по суммарной и прямой солнечной радиации (\\(кВт/ч/м^2/день\\)) для той же точки с 1995 по 2015 год:\n\ninterannual_sse &lt;- get_power(\n  community = \"ag\",\n  lonlat = c(60.59, 56.84),\n  dates = 1995:2015,\n  temporal_api = \"climatology\",\n  pars = c(\"CLRSKY_SFC_SW_DWN\",\n           \"ALLSKY_SFC_SW_DWN\")\n)\ninterannual_sse # посмотрим, что получилось",
    "crumbs": [
      "Графика и статистика",
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>Продвинутая графика</span>"
    ]
  },
  {
    "objectID": "06-AdvGraphics.html#advgraphics_soildb",
    "href": "06-AdvGraphics.html#advgraphics_soildb",
    "title": "6  Продвинутая графика",
    "section": "6.4 Загрузка данных Soil Data Access",
    "text": "6.4 Загрузка данных Soil Data Access\nSoil Data Access — это онлайн-сервис департамента сельского хозяйства США, который позволяет получать подробные данные о почвенных ресурсах этой страны. Наиболее часто запрашиваются данные по так называемым почвенным сериям — группам почвенных профилей, обладающих схожими характеристиками и, таким образом, идентичными с точки зрения сельскохозяйственного использования. Как правило, серии именуются по названию населенного пункта, рядом с которым впервые были найдены подобные почвы.\nНапример, серия Cecil имеет следующее покрытие и обеспеченность разрезами в базе данных SDA при запросе на сайте Series Extent Explorer:\n\n\n\n\n\n\n\n\n\nДля запросов данных по почвенным сериям достаточно вызвать функцию fetchOSD и передать ей имя одной или более серий:\n\nsoils = c('wilkes',  'chewacla', 'congaree')\nseries = fetchOSD(soils, extended = TRUE)\n\nРезультирющий объект представляет собой список со множеством таблиц, которые характеризуют как почвенную серию в целом, так и отдельные ее разрезы:\n\nstr(series)\n\nList of 17\n $ SPC             :Formal class 'SoilProfileCollection' [package \"aqp\"] with 9 slots\n  .. ..@ idcol       : chr \"id\"\n  .. ..@ hzidcol     : chr \"hzID\"\n  .. ..@ depthcols   : chr [1:2] \"top\" \"bottom\"\n  .. ..@ metadata    :List of 8\n  .. .. ..$ aqp_df_class    : chr \"data.frame\"\n  .. .. ..$ aqp_group_by    : chr \"\"\n  .. .. ..$ aqp_hzdesgn     : chr \"hzname\"\n  .. .. ..$ aqp_hztexcl     : chr \"texture_class\"\n  .. .. ..$ depth_units     : chr \"cm\"\n  .. .. ..$ stringsAsFactors: logi FALSE\n  .. .. ..$ original.order  : int [1:22] 1 2 3 4 5 6 7 8 9 10 ...\n  .. .. ..$ origin          : chr \"OSD via Soilweb / fetchOSD\"\n  .. ..@ horizons    :'data.frame': 22 obs. of  22 variables:\n  .. .. ..$ id                   : chr [1:22] \"CHEWACLA\" \"CHEWACLA\" \"CHEWACLA\" \"CHEWACLA\" ...\n  .. .. ..$ top                  : int [1:22] 0 10 36 66 97 119 152 0 20 46 ...\n  .. .. ..$ bottom               : int [1:22] 10 36 66 97 119 152 203 20 46 56 ...\n  .. .. ..$ hzname               : chr [1:22] \"Ap\" \"Bw1\" \"Bw2\" \"Bw3\" ...\n  .. .. ..$ soil_color           : chr [1:22] \"#7D593AFF\" \"#795B36FF\" \"#795B36FF\" \"#7D593AFF\" ...\n  .. .. ..$ hue                  : chr [1:22] \"7.5YR\" \"10YR\" \"10YR\" \"7.5YR\" ...\n  .. .. ..$ value                : int [1:22] 4 4 4 4 5 5 4 4 4 3 ...\n  .. .. ..$ chroma               : int [1:22] 4 4 4 4 8 1 4 4 3 3 ...\n  .. .. ..$ dry_hue              : chr [1:22] \"7.5YR\" \"10YR\" \"10YR\" \"7.5YR\" ...\n  .. .. ..$ dry_value            : int [1:22] 6 6 6 6 6 6 6 6 6 5 ...\n  .. .. ..$ dry_chroma           : int [1:22] 4 4 4 4 7 1 4 4 3 3 ...\n  .. .. ..$ texture_class        : Ord.factor w/ 21 levels \"coarse sand\"&lt;..: 13 18 17 13 17 17 13 13 13 NA ...\n  .. .. ..$ cf_class             : logi [1:22] NA NA NA NA NA NA ...\n  .. .. ..$ pH                   : logi [1:22] NA NA NA NA NA NA ...\n  .. .. ..$ pH_class             : Ord.factor w/ 12 levels \"ultra acid\"&lt;\"extremely acid\"&lt;..: 3 3 3 3 3 3 3 4 NA NA ...\n  .. .. ..$ distinctness         : chr [1:22] \"clear\" \"gradual\" \"gradual\" \"gradual\" ...\n  .. .. ..$ topography           : chr [1:22] \"smooth\" \"wavy\" \"wavy\" \"wavy\" ...\n  .. .. ..$ dry_color_estimated  : logi [1:22] TRUE TRUE TRUE TRUE TRUE TRUE ...\n  .. .. ..$ moist_color_estimated: logi [1:22] FALSE FALSE FALSE FALSE FALSE FALSE ...\n  .. .. ..$ narrative            : chr [1:22] \"Ap--0 to 4 inches; brown (7.5YR 4/4) loam; weak medium granular structure; friable; common very fine, fine, and\"| __truncated__ \"Bw1--4 to 14 inches; dark yellowish brown (10YR 4/4) silty clay loam; weak medium subangular blocky structure; \"| __truncated__ \"Bw2--14 to 26 inches; dark yellowish brown (10YR 4/4) clay loam; weak medium subangular blocky structure; friab\"| __truncated__ \"Bw3--26 to 38 inches; brown (7.5YR 4/4) loam; weak medium subangular blocky structure; friable; common fine roo\"| __truncated__ ...\n  .. .. ..$ hzID                 : chr [1:22] \"1\" \"2\" \"3\" \"4\" ...\n  .. .. ..$ hzd                  : num [1:22] 2.5 7.5 7.5 7.5 7.5 7.5 0 2.5 7.5 2.5 ...\n  .. ..@ site        :'data.frame': 3 obs. of  31 variables:\n  .. .. ..$ id                     : chr [1:3] \"CHEWACLA\" \"CONGAREE\" \"WILKES\"\n  .. .. ..$ soilseriesiid          : int [1:3] 24628 1057 23800\n  .. .. ..$ series_status          : chr [1:3] \"established\" \"established\" \"established\"\n  .. .. ..$ benchmarksoilflag      : chr [1:3] \"TRUE\" \"FALSE\" \"FALSE\"\n  .. .. ..$ soiltaxclasslastupdated: chr [1:3] \"2010-02-11 00:00:00\" \"2002-07-18 00:00:00\" \"1997-06-06 00:00:00\"\n  .. .. ..$ mlraoffice             : chr [1:3] \"raleigh, nc\" \"raleigh, nc\" \"raleigh, nc\"\n  .. .. ..$ family                 : chr [1:3] \"fine-loamy, mixed, active, thermic fluvaquentic dystrudepts\" \"fine-loamy, mixed, active, nonacid, thermic oxyaquic udifluvents\" \"loamy, mixed, active, thermic, shallow typic hapludalfs\"\n  .. .. ..$ soilorder              : chr [1:3] \"inceptisols\" \"entisols\" \"alfisols\"\n  .. .. ..$ suborder               : chr [1:3] \"udepts\" \"fluvents\" \"udalfs\"\n  .. .. ..$ greatgroup             : chr [1:3] \"dystrudepts\" \"udifluvents\" \"hapludalfs\"\n  .. .. ..$ subgroup               : chr [1:3] \"fluvaquentic dystrudepts\" \"oxyaquic udifluvents\" \"typic hapludalfs\"\n  .. .. ..$ tax_partsize           : chr [1:3] \"fine-loamy\" \"fine-loamy\" \"loamy\"\n  .. .. ..$ tax_partsizemod        : logi [1:3] NA NA NA\n  .. .. ..$ tax_ceactcl            : chr [1:3] \"active\" \"active\" \"active\"\n  .. .. ..$ tax_reaction           : chr [1:3] NA \"nonacid\" NA\n  .. .. ..$ tax_tempcl             : chr [1:3] \"thermic\" \"thermic\" \"thermic\"\n  .. .. ..$ tax_minclass           : chr [1:3] \"mixed\" \"mixed\" \"mixed\"\n  .. .. ..$ taxfamhahatmatcl       : logi [1:3] NA NA NA\n  .. .. ..$ originyear             : logi [1:3] NA NA NA\n  .. .. ..$ establishedyear        : int [1:3] 1937 1904 1916\n  .. .. ..$ descriptiondateinitial : chr [1:3] \"2010-02-11 00:00:00+00\" \"2002-07-18 00:00:00+00\" \"2007-09-06 00:00:00+00\"\n  .. .. ..$ descriptiondateupdated : chr [1:3] \"2010-02-11 00:00:00+00\" \"2002-07-18 00:00:00+00\" \"2021-01-27 16:02:50.637+00\"\n  .. .. ..$ statsgoflag            : chr [1:3] \"TRUE\" \"TRUE\" \"TRUE\"\n  .. .. ..$ areasymbol             : chr [1:3] \"NC\" \"SC\" \"NC\"\n  .. .. ..$ areaname               : chr [1:3] \"North Carolina\" \"South Carolina\" \"North Carolina\"\n  .. .. ..$ areatypename           : chr [1:3] \"State or Territory\" \"State or Territory\" \"State or Territory\"\n  .. .. ..$ subgroup_mod           : chr [1:3] \"fluvaquentic\" \"oxyaquic\" \"typic\"\n  .. .. ..$ greatgroup_mod         : chr [1:3] \"dystr\" \"udi\" \"hapl\"\n  .. .. ..$ drainagecl             : chr [1:3] \"somewhat poorly\" \"well to moderately well\" \"well\"\n  .. .. ..$ ac                     : int [1:3] 1254622 215993 614348\n  .. .. ..$ n_polygons             : int [1:3] 38657 10260 34850\n  .. ..@ sp          :Formal class 'SpatialPoints' [package \"sp\"] with 3 slots\n  .. .. .. ..@ coords     : num [1, 1] 0\n  .. .. .. ..@ bbox       : logi [1, 1] NA\n  .. .. .. ..@ proj4string:Formal class 'CRS' [package \"sp\"] with 1 slot\n  .. .. .. .. .. ..@ projargs: chr NA\n  .. ..@ diagnostic  :'data.frame': 0 obs. of  0 variables\n  .. ..@ restrictions:'data.frame': 0 obs. of  0 variables\n $ competing       :'data.frame':   1 obs. of  3 variables:\n  ..$ series   : chr \"CHEWACLA\"\n  ..$ competing: chr \"OAKBORO\"\n  ..$ family   : chr \"fine-loamy, mixed, active, thermic fluvaquentic dystrudepts\"\n $ geog_assoc_soils:'data.frame':   45 obs. of  2 variables:\n  ..$ series: chr [1:45] \"CHEWACLA\" \"CHEWACLA\" \"CHEWACLA\" \"CHEWACLA\" ...\n  ..$ gas   : chr [1:45] \"ALTAVISTA\" \"AUGUSTA\" \"BIBB\" \"BUNCOMBE\" ...\n $ geomcomp        :'data.frame':   2 obs. of  9 variables:\n  ..$ series         : chr [1:2] \"CHEWACLA\" \"WILKES\"\n  ..$ Interfluve     : num [1:2] 1 0.178\n  ..$ Crest          : num [1:2] 0 0.027\n  ..$ Head Slope     : int [1:2] 0 0\n  ..$ Nose Slope     : int [1:2] 0 0\n  ..$ Side Slope     : num [1:2] 0 0.795\n  ..$ Base Slope     : int [1:2] 0 0\n  ..$ n              : int [1:2] 3 185\n  ..$ shannon_entropy: num [1:2] 0 0.848\n $ hillpos         :'data.frame':   3 obs. of  8 variables:\n  ..$ series         : chr [1:3] \"CHEWACLA\" \"CONGAREE\" \"WILKES\"\n  ..$ Toeslope       : num [1:3] 1 0.846 0\n  ..$ Footslope      : num [1:3] 0 0.154 0\n  ..$ Backslope      : num [1:3] 0 0 0.637\n  ..$ Shoulder       : num [1:3] 0 0 0.225\n  ..$ Summit         : num [1:3] 0 0 0.139\n  ..$ n              : int [1:3] 75 13 245\n  ..$ shannon_entropy: num [1:3] 0 0.619 1.294\n $ mtnpos          : logi FALSE\n $ terrace         :'data.frame':   2 obs. of  5 variables:\n  ..$ series         : chr [1:2] \"CHEWACLA\" \"CONGAREE\"\n  ..$ Tread          : num [1:2] 0.977 1\n  ..$ Riser          : num [1:2] 0.0233 0\n  ..$ n              : int [1:2] 86 35\n  ..$ shannon_entropy: num [1:2] 0.16 0\n $ flats           :'data.frame':   2 obs. of  7 variables:\n  ..$ series         : chr [1:2] \"CHEWACLA\" \"CONGAREE\"\n  ..$ Dip            : num [1:2] 0.1455 0.0667\n  ..$ Talf           : num [1:2] 0.855 0.867\n  ..$ Flat           : int [1:2] 0 0\n  ..$ Rise           : num [1:2] 0 0.0667\n  ..$ n              : int [1:2] 55 15\n  ..$ shannon_entropy: num [1:2] 0.598 0.7\n $ shape_across    :'data.frame':   3 obs. of  8 variables:\n  ..$ series         : chr [1:3] \"CHEWACLA\" \"CONGAREE\" \"WILKES\"\n  ..$ Concave        : num [1:3] 0.0364 0.0213 0\n  ..$ Linear         : num [1:3] 0.953 0.957 0.359\n  ..$ Convex         : num [1:3] 0.0109 0.0213 0.641\n  ..$ Complex        : int [1:3] 0 0 0\n  ..$ Undulating     : int [1:3] 0 0 0\n  ..$ n              : int [1:3] 275 94 195\n  ..$ shannon_entropy: num [1:3] 0.312 0.297 0.942\n $ shape_down      :'data.frame':   3 obs. of  8 variables:\n  ..$ series         : chr [1:3] \"CHEWACLA\" \"CONGAREE\" \"WILKES\"\n  ..$ Concave        : num [1:3] 0.3309 0.0217 0\n  ..$ Linear         : num [1:3] 0.658 0.946 0.636\n  ..$ Convex         : num [1:3] 0.0109 0.0326 0.3641\n  ..$ Complex        : int [1:3] 0 0 0\n  ..$ Undulating     : int [1:3] 0 0 0\n  ..$ n              : int [1:3] 275 92 195\n  ..$ shannon_entropy: num [1:3] 0.996 0.357 0.946\n $ pmkind          :'data.frame':   6 obs. of  5 variables:\n  ..$ series: chr [1:6] \"CHEWACLA\" \"CHEWACLA\" \"CONGAREE\" \"CONGAREE\" ...\n  ..$ pmkind: chr [1:6] \"Alluvium\" \"Residuum\" \"Alluvium\" \"Fluviomarine deposits\" ...\n  ..$ n     : int [1:6] 205 1 72 13 1 262\n  ..$ total : int [1:6] 206 206 86 86 86 262\n  ..$ P     : num [1:6] 0.9951 0.0049 0.8372 0.1512 0.0116 ...\n $ pmorigin        :'data.frame':   24 obs. of  5 variables:\n  ..$ series  : chr [1:24] \"CHEWACLA\" \"CHEWACLA\" \"CHEWACLA\" \"CHEWACLA\" ...\n  ..$ pmorigin: chr [1:24] \"Igneous and metamorphic rock\" \"Sedimentary rock\" \"Granite and gneiss\" \"Mixed\" ...\n  ..$ n       : int [1:24] 29 11 2 2 1 1 1 1 1 1 ...\n  ..$ total   : int [1:24] 51 51 51 51 51 51 51 51 51 51 ...\n  ..$ P       : num [1:24] 0.5686 0.2157 0.0392 0.0392 0.0196 ...\n $ mlra            :'data.frame':   21 obs. of  4 variables:\n  ..$ series    : chr [1:21] \"CHEWACLA\" \"CHEWACLA\" \"CHEWACLA\" \"CHEWACLA\" ...\n  ..$ mlra      : chr [1:21] \"148\" \"135A\" \"136\" \"133A\" ...\n  ..$ area_ac   : int [1:21] 7911 4245 920965 105979 85493 55614 30799 19434 14232 9855 ...\n  ..$ membership: num [1:21] 0.006 0.003 0.734 0.084 0.068 0.044 0.025 0.015 0.011 0.008 ...\n $ climate.annual  :'data.frame':   24 obs. of  12 variables:\n  ..$ series     : chr [1:24] \"CHEWACLA\" \"CHEWACLA\" \"CHEWACLA\" \"CHEWACLA\" ...\n  ..$ climate_var: chr [1:24] \"Elevation (m)\" \"Effective Precipitation (mm)\" \"Frost-Free Days\" \"Mean Annual Air Temperature (degrees C)\" ...\n  ..$ minimum    : num [1:24] 0 128.8 177 12.1 986 ...\n  ..$ q01        : num [1:24] 7 216 188 13 1069 ...\n  ..$ q05        : num [1:24] 33 245.9 196 13.5 1094 ...\n  ..$ q25        : num [1:24] 125 310.2 208 14.9 1136 ...\n  ..$ q50        : num [1:24] 191 348.8 218 15.7 1175 ...\n  ..$ q75        : num [1:24] 247 442.9 227 16.4 1277 ...\n  ..$ q95        : num [1:24] 347 569.2 235 17.3 1394 ...\n  ..$ q99        : num [1:24] 479 740.4 244 17.8 1575.1 ...\n  ..$ maximum    : num [1:24] 919 1382.8 300 19.7 2202 ...\n  ..$ n          : int [1:24] 29784 29784 29784 29784 29784 29784 29784 29784 7547 7547 ...\n $ climate.monthly :'data.frame':   72 obs. of  14 variables:\n  ..$ series     : chr [1:72] \"CHEWACLA\" \"CHEWACLA\" \"CHEWACLA\" \"CHEWACLA\" ...\n  ..$ climate_var: chr [1:72] \"ppt1\" \"ppt2\" \"ppt3\" \"ppt4\" ...\n  ..$ minimum    : num [1:72] 61 64 81 63 60 78 83 74 68 53 ...\n  ..$ q01        : num [1:72] 75 71 93 71 69 83 92 85 81 72 ...\n  ..$ q05        : num [1:72] 83 73 99 75 72 ...\n  ..$ q25        : num [1:72] 93 83 105 82 81 96 108 96 91 82 ...\n  ..$ q50        : num [1:72] 105 106 119 88 92 101 115 102 98 86 ...\n  ..$ q75        : num [1:72] 116 121 128 95 101 106 123 110 105 91 ...\n  ..$ q95        : num [1:72] 131 135 137 111 112 117 133 129 118 100 ...\n  ..$ q99        : num [1:72] 150 144 147 122 125 133 143 142 137 109 ...\n  ..$ maximum    : num [1:72] 248 227 239 150 167 198 220 207 192 158 ...\n  ..$ n          : int [1:72] 29784 29784 29784 29784 29784 29784 29784 29784 29784 29784 ...\n  ..$ month      : Factor w/ 12 levels \"1\",\"2\",\"3\",\"4\",..: 1 2 3 4 5 6 7 8 9 10 ...\n  ..$ variable   : Factor w/ 2 levels \"Potential ET (mm)\",..: 2 2 2 2 2 2 2 2 2 2 ...\n $ NCCPI           :'data.frame':   3 obs. of  16 variables:\n  ..$ series             : chr [1:3] \"CHEWACLA\" \"CONGAREE\" \"WILKES\"\n  ..$ n                  : int [1:3] 266 94 158\n  ..$ nccpi_irrigated_q01: num [1:3] 0.188 0.816 0.268\n  ..$ nccpi_irrigated_q05: num [1:3] 0.346 0.825 0.269\n  ..$ nccpi_irrigated_q25: num [1:3] 0.564 0.861 0.32\n  ..$ nccpi_irrigated_q50: num [1:3] 0.597 0.907 0.361\n  ..$ nccpi_irrigated_q75: num [1:3] 0.654 0.925 0.419\n  ..$ nccpi_irrigated_q95: num [1:3] 0.849 0.979 0.561\n  ..$ nccpi_irrigated_q99: num [1:3] 0.93 0.984 0.614\n  ..$ nccpi_q01          : num [1:3] 0.347 0.5926 0.0426\n  ..$ nccpi_q05          : num [1:3] 0.56 0.651 0.0564\n  ..$ nccpi_q25          : num [1:3] 0.624 0.76 0.146\n  ..$ nccpi_q50          : num [1:3] 0.685 0.813 0.231\n  ..$ nccpi_q75          : num [1:3] 0.711 0.852 0.268\n  ..$ nccpi_q95          : num [1:3] 0.837 0.936 0.379\n  ..$ nccpi_q99          : num [1:3] 0.84 0.947 0.57\n $ soilweb.metadata:'data.frame':   24 obs. of  2 variables:\n  ..$ product    : chr [1:24] \"block diagram archive\" \"cached sketches\" \"component pedons\" \"ESID-series cross-tabulation\" ...\n  ..$ last_update: chr [1:24] \"2019-12-17\" \"2023-10-12\" \"2023-10-09\" \"2023-11-06\" ...",
    "crumbs": [
      "Графика и статистика",
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>Продвинутая графика</span>"
    ]
  },
  {
    "objectID": "06-AdvGraphics.html#advgraphics_template",
    "href": "06-AdvGraphics.html#advgraphics_template",
    "title": "6  Продвинутая графика",
    "section": "6.5 Базовый шаблон ggplot",
    "text": "6.5 Базовый шаблон ggplot\nДля начала посмотрим, как можно показать суммарный экспорт по годам:\n\ntrades_total = trades |&gt; \n  group_by(time) |&gt; \n  summarise(export = sum(export),\n            import = sum(import))\n  \nggplot(data = trades_total) +\n  geom_point(mapping = aes(x = time, y = export))\n\n\n\n\n\n\n\n\nБазовый (минимально необходимый) шаблон построения графика через ggplot выглядит следующим образом:\n\nggplot(data = &lt;DATA&gt;) + \n  &lt;GEOM_FUNCTION&gt;(mapping = aes(&lt;MAPPINGS&gt;))\n\nгде:\n\nDATA — источник данных (фрейм, тиббл)\nGEOM_FUNCTION — функция, отвечающая за геометрический тип графика (точки, линии, гистограммы и т.д.)\nMAPPINGS — перечень соответствий между переменными данных (содержащихся в DATA) и графическими переменными (координатами, размерами, цветами и т.д.)",
    "crumbs": [
      "Графика и статистика",
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>Продвинутая графика</span>"
    ]
  },
  {
    "objectID": "06-AdvGraphics.html#advgraphics_geoms",
    "href": "06-AdvGraphics.html#advgraphics_geoms",
    "title": "6  Продвинутая графика",
    "section": "6.6 Геометрические типы и преобразования",
    "text": "6.6 Геометрические типы и преобразования\nggplot предлагает несколько десятков различных видов геометрий для отображения данных. С их полным перечнем можно познакомиться тут. Мы рассмотрим несколько наиболее употребительных, а геометрии, связанные со статистическими преобразованиями, оставим для следующей темы.\nВ первом примере мы отображали данные по экспорту за разные года, однако точечный тип не очень подходит для данного типа графика, поскольку он показывает динамику изменения. А это означает, что желательно соединить точки линиями. Для этого используем геометрию geom_line():\n\nggplot(data = trades_total) +\n  geom_line(mapping = aes(x = time, y = export))\n\n\n\n\n\n\n\n\nПоскольку в данном случае величина является агрегированной за год, более правильным может быть показ ее изменений в виде ступенчатого линейного графика, который получается через геометрию geom_step():\n\nggplot(data = trades_total) +\n  geom_step(mapping = aes(x = time, y = export))\n\n\n\n\n\n\n\n\nМожно совместить несколько геометрий, добавив их последовательно на график:\n\nggplot(data = trades_total) +\n  geom_line(mapping = aes(x = time, y = export)) +\n  geom_point(mapping = aes(x = time, y = export))\n\n\n\n\n\n\n\n\nЕсли у нескольких геометрий одинаковые отображения, их можно вынести в вызов функции ggplot() (чтобы не дублировать):\n\nggplot(data = trades_total, mapping = aes(x = time, y = export)) +\n  geom_line() +\n  geom_point()\n\n\n\n\n\n\n\n\nНаглядность линейного графика можно усилить, добавив “заливку” области с использованием geom_area():\n\nggplot(data = trades_total, mapping = aes(x = time, y = export)) +\n  geom_area(alpha = 0.5) + # полигон с прозрачностью 0,5\n  geom_line() +\n  geom_point()\n\n\n\n\n\n\n\n\nДля построения столбчатой диаграммы следует использовать геометрию geom_col(). Например, вот так выглядит структура экспорта продукции машиностроения из Евросоюза по ведущим партнерам:\n\ntrades |&gt; \n  filter(sitc06 == 'Machinery and transport equipment', \n         export &gt; 10000,\n         time == as.Date('2022-01-01')) |&gt; \n  ggplot(mapping = aes(x = partner, y = export)) +\n  geom_col()\n\n\n\n\n\n\n\n\nРазвернуть диаграмму можно, используя функцию coord_flip():\n\ntrades |&gt; \n  filter(sitc06 == 'Machinery and transport equipment', \n         export &gt; 10000,\n         time == as.Date('2022-01-01')) |&gt; \n  ggplot(mapping = aes(x = partner, y = export)) +\n  geom_col() +\n  coord_flip()",
    "crumbs": [
      "Графика и статистика",
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>Продвинутая графика</span>"
    ]
  },
  {
    "objectID": "06-AdvGraphics.html#advgraphics_aes",
    "href": "06-AdvGraphics.html#advgraphics_aes",
    "title": "6  Продвинутая графика",
    "section": "6.7 Графические переменные и группировки",
    "text": "6.7 Графические переменные и группировки\nГрафические переменные — это параметры, определяющие внешний вид символов. К ним относятся цвет (тон, насыщенность и светлота), размер, форма, ориентировка, внутренняя структура символа. В ggplot значения графических переменных могут быть едиными для всех измерений, а могут зависеть от величины измерений. С точки зрения управления здесь все просто: если вы хотите, чтобы какой-то графический параметр зависел от значения показателя, он должен быть указан внутри конструкции mapping = aes(...). Если необходимо, чтобы этот параметр был одинаковым для всех измерений, вы должны его указать внутри &lt;GEOM_FUNCTION&gt;(...), то есть не передавать в mapping.\nДля управления цветом, формой и размером (толщиной) графического примитива следует использовать параметры color, shape и size соответственно. Посмотрим, как они работают внутри и за пределами функции aes():\n\n# один цвет для графика (параметр за пределами aes)\nggplot(trades_total) + \n    geom_line(mapping = aes(x = time, y = export), color = 'blue')\n\n\n\n\n\n\n\ntrade_russia = trades |&gt; filter(partner == 'Russia')\n\nggplot(trade_russia) + # у каждой группы данных свой цвет (параметр внутри aes)\n  geom_line(mapping = aes(x = time, y = export, color = sitc06))\n\n\n\n\n\n\n\nggplot(trade_russia, \n       mapping = aes(x = time, y = export, color = sitc06)) + # а теперь и с точками\n  geom_line() +\n  geom_point()\n\n\n\n\n\n\n\n\nАналогичным образом работает параметр формы значка:\n\n# один значок для графика\nggplot(trades_total) + \n    geom_point(mapping = aes(x = time, y = export), shape = 15)\n\n\n\n\n\n\n\nggplot(trade_russia) + # у каждой группы данных свой значок\n    geom_point(mapping = aes(x = time, y = export, shape = sitc06))\n\n\n\n\n\n\n\n\nДля изменения размера значка или линии используйте параметр size:\n\n# изменение размера значка и линии\nggplot(trades_total, mapping = aes(x = time, y = export)) + \n    geom_point(size = 5) +\n    geom_line(size = 2)\n\n\n\n\n\n\n\n\nЕсли вы используете зависимые от значений графические переменные и при этом хотите добавить на график еще одну геометрию (c постоянными параметрами), то вам необходимо сгруппировать объекты второй геометрии по той же переменной, по которой вы осуществляете разбиение в первой геометрии. Для этого используйте параметр group:\n\nggplot(trade_russia, aes(x = time, y = export)) + \n    geom_point(aes(shape = sitc06)) +\n    geom_line(aes(group = sitc06))\n\n\n\n\n\n\n\n\nДля изменения цвета столбчатых диаграмм следует использовать параметр fill, а цвет и толщина обводки определяются параметрами color и size:\n\ntrades |&gt; \n  filter(sitc06 == 'Machinery and transport equipment', \n         export &gt; 10000,\n         time == as.Date('2017-01-01')) |&gt; \n  ggplot(mapping = aes(x = partner, y = export)) +\n  geom_col(fill = 'plum4', color = 'black', linewidth = 0.2) +\n  coord_flip()\n\n\n\n\n\n\n\n\nЦвет на столбчатых диаграммах можно использовать для отображения дополнительных переменных, например типа экспортируемой продукции. По умолчанию столбики будут образовывать стек\n\ntrades |&gt; \n  filter(time == as.Date('2022-01-01')) |&gt; \n  group_by(partner) |&gt; \n  filter(sum(export) &gt; 30000) |&gt; \n  ggplot(mapping = aes(x = partner, y = export, fill = sitc06)) +\n  geom_col(color = 'black', size = 0.2) +\n  coord_flip()\n\n\n\n\n\n\n\n\nЕсли вам важно не абсолютное количество, а процентное соотношение величин, вы можете применить вид группировки position == 'fill:\n\ntrades |&gt; \n  filter(time == as.Date('2022-01-01')) |&gt; \n  group_by(partner) |&gt; \n  filter(sum(export) &gt; 30000) |&gt; \n  ggplot(mapping = aes(x = partner, y = export, fill = sitc06)) +\n    geom_col(color = 'black', size = 0.2, position = 'fill') +\n    coord_flip()\n\n\n\n\n\n\n\n\nЕще один вид группировки — это группировка по соседству. Чтобы использовать ее, применить метод position == 'dodge:\n\ntrade_russia |&gt; \n  filter(time &gt;= as.Date('2013-01-01')) |&gt; \n  ggplot(mapping = aes(x = time, y = export, fill = sitc06)) +\n    geom_col(color = 'black', size = 0.2, position = 'dodge')",
    "crumbs": [
      "Графика и статистика",
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>Продвинутая графика</span>"
    ]
  },
  {
    "objectID": "06-AdvGraphics.html#advgraphics_coords",
    "href": "06-AdvGraphics.html#advgraphics_coords",
    "title": "6  Продвинутая графика",
    "section": "6.8 Системы координат",
    "text": "6.8 Системы координат\nggplot поддерживает множество полезных преобразований координат, таких как смена осей X и Y, переход к логарифмическим координатам и использование полярной системы вместо декартовой прямоугольной.\nСмена переменных происходит благодаря уже знакомой нам функции coord_flip(). Рассмотрим, например, как изменилась структура экспорта/импорта по годам:\n\ntrades_type = trades |&gt; \n  group_by(sitc06, time) |&gt; \n  summarise(export = sum(export),\n            import = sum(import))\n\nggplot(trades_type) + \n    geom_point(mapping = aes(x = export, y = import, color = sitc06, size = time), alpha = 0.5)\n\n\n\n\n\n\n\nggplot(trades_type) + \n    geom_point(mapping = aes(x = export, y = import, color = sitc06, size = time), alpha = 0.5) +\n    coord_flip()\n\n\n\n\n\n\n\n\nПоскольку объемы продукции различаются на порядки, для различимости малых объемов целесообразно перейти к логарифмической шкале. Для этого используем scale_log_x() и scale_log_y():\n\nggplot(trades_type, mapping = aes(x = export, y = import, color = sitc06, size = time)) + \n  geom_point(alpha = 0.5) +\n  scale_x_log10() +\n  scale_y_log10()\n\n\n\n\n\n\n\n\nПреобразование в полярную систему координат используется для того чтобы получить круговую секторную диаграмму Найтингейл (coxcomb chart):\n\ntrades |&gt; \n  filter(sitc06 == 'Machinery and transport equipment', \n         export &gt; 10000,\n         time == as.Date('2022-01-01')) |&gt; \n  ggplot(mapping = aes(x = partner, y = export, fill = partner)) +\n  geom_col() +\n  coord_polar()\n\n\n\n\n\n\n\n\nРазумеется, здесь тоже можно использовать преобразование шкалы по оси Y (которая теперь отвечает за радиус). Применим правило квадратного корня, добавив вызов функции scale_y_sqrt():\n\ntrades |&gt; \n  filter(sitc06 == 'Machinery and transport equipment', \n         export &gt; 10000,\n         time == as.Date('2017-01-01')) |&gt; \n  ggplot(mapping = aes(x = partner, y = export, fill = partner)) +\n  geom_col() +\n  coord_polar() +\n  scale_y_sqrt()\n\n\n\n\n\n\n\n\nЧтобы построить классическую секторную диаграмму, необходимо, чтобы угол поворота соответствовал величине показателя (оси Y), а не названию категории (оси X). Для этого при вызове функции coord_polar() следует указать параметр theta = 'y', а при вызове geom_col() оставить параметр x пустым:\n\ntrades |&gt; \n  filter(sitc06 == 'Machinery and transport equipment',\n         export &gt; 10000,\n         time == as.Date('2017-01-01')) |&gt; \n  ggplot(mapping = aes(x = '', y = export, fill = partner)) +\n    geom_col(color = 'black', linewidth = 0.2) +\n    coord_polar(theta = 'y')",
    "crumbs": [
      "Графика и статистика",
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>Продвинутая графика</span>"
    ]
  },
  {
    "objectID": "06-AdvGraphics.html#advgraphics_titles",
    "href": "06-AdvGraphics.html#advgraphics_titles",
    "title": "6  Продвинутая графика",
    "section": "6.9 Названия осей и легенды",
    "text": "6.9 Названия осей и легенды\nggplot предоставляет ряд функций для аннотирования осей и легенды. Для этого можно использовать одну из следующих функций:\n\nlabs(...) модифицирует заголовок легенды для соответствующей графической переменной, либо заголовок/подзаголовок графика\nxlab(label) модифицирует подпись оси X\nylab(label) модифицирует подпись оси Y\nggtitle(label, subtitle = NULL) модифицирует заголовок и подзаголовок графика\n\nСоздадим подписи легенд, отвечающих за цвет и размер значка на графике соотношения импорта и экспорта разных видов продукции:\n\nggplot(trades_type) + \n  geom_point(mapping = aes(x = export, y = import, color = sitc06, size = time), alpha = 0.5) +\n  labs(color = \"Вид продукции\", size = 'Год')\n\n\n\n\n\n\n\n\nДобавим заголовок и подзаголовок графика:\n\nggplot(trades_type) + \n  geom_point(mapping = aes(x = export, y = import, color = sitc06, size = time), alpha = 0.5) +\n  labs(color = \"Вид продукции\", size = 'Год') +\n  ggtitle('Соотношение импорта и экспорта в странах Евросоюза (млн долл. США)',\n          subtitle = 'Данные по ключевым партнерам')\n\n\n\n\n\n\n\n\nИзменим подписи осей:\n\nggplot(trades_type) + \n  geom_point(mapping = aes(x = export, y = import, color = sitc06, size = time), alpha = 0.5) +\n  labs(color = \"Вид продукции\", size = 'Год') +\n  ggtitle('Соотношение импорта и экспорта в странах Евросоюза (млн долл. США)',\n          subtitle = 'Данные по ключевым партнерам') +\n  xlab('Экспорт') +\n  ylab('Импорт')",
    "crumbs": [
      "Графика и статистика",
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>Продвинутая графика</span>"
    ]
  },
  {
    "objectID": "06-AdvGraphics.html#advgraphics_axes",
    "href": "06-AdvGraphics.html#advgraphics_axes",
    "title": "6  Продвинутая графика",
    "section": "6.10 Разметка осей",
    "text": "6.10 Разметка осей\nПервое, что вам скорее всего захочется убрать — это экспоненциальная запись чисел. На самом деле, эта запись не является параметром ggplot или стандартной системы graphics. Количество значащих цифр, после которых число автоматически представляется в экспоненциальном виде, управляется параметром scipen. Мы можем задать его достаточно большим, чтобы запретить переводить любые разумные числа в экспоненциальный вид:\n\noptions(scipen = 999)\nggplot(trades_type) + \n  geom_point(mapping = aes(x = export, y = import, color = sitc06, size = time), alpha = 0.5) +\n  labs(color = \"Вид продукции\", size = 'Год') +\n  ggtitle('Соотношение импорта и экспорта в странах Евросоюза (млн долл. США)',\n          subtitle = 'Данные по ключевым партнерам') +\n  xlab('Экспорт') +\n  ylab('Импорт')\n\n\n\n\n\n\n\n\nДля управления разметкой осей необходимо использовать функции scale_x_continuous(), scale_y_continuous(), scale_x_log10(...), scale_y_log10(...), scale_x_reverse(...), scale_y_reverse(...), scale_x_sqrt(...), scale_y_sqrt(...), которые, с одной стороны, указывают тип оси, а с другой стороны — позволяют управлять параметрами сетки координат и подписями.\nДля изменения координат линий сетки и подписей необходимо использовать, соответственно, параметры breaks и labels:\n\nggplot(trades_type, mapping = aes(x = export, y = import, color = sitc06, size = time)) + \n  geom_point(alpha = 0.5) +\n  scale_x_log10(breaks = seq(0, 500000, 100000)) +\n  scale_y_log10(breaks = seq(0, 500000, 100000))\n\n\n\n\n\n\n\n\nВ данном случае, как раз, будет достаточно полезным параметр labels, поскольку метки можно сделать более компактными, поделив их на 1000 (и не забыть потом указать, что объемы теперь указаны не в миллионах, а в миллиардах долларов):\n\nbrks = seq(0, 500000, 100000)\nggplot(trades_type, mapping = aes(x = export, y = import, color = sitc06, size = time)) + \n  geom_point(alpha = 0.5) +\n  scale_x_log10(breaks = brks, labels = brks / 1000) +\n  scale_y_log10(breaks = brks, labels = brks / 1000)\n\n\n\n\n\n\n\n\nДля обычной шкалы используйте функции scale_x_continuous() и scale_y_continuous():\n\nggplot(trades_type, mapping = aes(x = export, y = import, color = sitc06, size = time)) + \n  geom_point(alpha = 0.5) +\n  scale_x_continuous(breaks = brks, labels = brks / 1000) +\n  scale_y_continuous(breaks = brks, labels = brks / 1000)\n\n\n\n\n\n\n\n\nДля того чтобы принудительно указать диапазоны осей и графических переменных, следует использовать функции lims(...), xlim(...) и ylim(...). Например, мы можем приблизиться в левый нижний угол графика, задав диапазон 0-200000 по обеим осям:\n\nggplot(trades_type, mapping = aes(x = export, y = import, color = sitc06, size = time)) + \n  geom_point(alpha = 0.5) +\n  xlim(0, 50000) +\n  ylim(0, 100000)\n\n\n\n\n\n\n\n\nФункция lims() работает еще хитрее: она позволяет применять графические переменные только к ограниченному набору значений исходных данных. Например, таким путем я могу выделить на графике продукцию машиностроения:\n\nggplot(trades_type, mapping = aes(x = export, y = import, color = sitc06, size = time)) + \n  geom_point(alpha = 0.5) +\n  lims(color = 'Machinery and transport equipment')",
    "crumbs": [
      "Графика и статистика",
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>Продвинутая графика</span>"
    ]
  },
  {
    "objectID": "06-AdvGraphics.html#advgraphics_labels",
    "href": "06-AdvGraphics.html#advgraphics_labels",
    "title": "6  Продвинутая графика",
    "section": "6.11 Подписи и аннотации",
    "text": "6.11 Подписи и аннотации\nС точки зрения ggplot текст на графике, отображающий входные данные, является одной из разновидностей геометрии. Размещается он с помощью функции geom_text(). Как и в случае с другими геометриями, параметры, зависящие от исходных данных, должны быть переданы внутри mapping = aes(...):\n\nggplot(data = trades_total, mapping = aes(x = time, y = export)) +\n  geom_area(alpha = 0.5) + # полигон с прозрачностью 0,5\n  geom_line() +\n  geom_point() +\n  geom_text(aes(label = floor(export / 1000))) # добавляем подписи\n\n\n\n\n\n\n\n\nВыравнивание подписи относительно якорной точки (снизу, сверху, справа, слева) по горизонтали и вертикали управляется параметрами hjust и vjust, а смещения по осям X (в координатах графика) — параметрами nudge_x и nudge_y:\n\nggplot(data = trades_total, mapping = aes(x = time, y = export)) +\n  geom_area(alpha = 0.5) + # полигон с прозрачностью 0,5\n  geom_line() +\n  geom_point() +\n  geom_text(aes(label = floor(export / 1000)), \n            vjust = 0, nudge_y = 40000) # добавляем подписи\n\n\n\n\n\n\n\n\nПодписи с фоновой плашкой добавляются через функцию geom_label(), которая имеет аналогичный синтаксис:\n\ntrades |&gt; \n  filter(sitc06 == 'Machinery and transport equipment', \n         export &gt; 10000,\n         time == as.Date('2022-01-01')) |&gt; \n  ggplot(mapping = aes(x = partner, y = export)) +\n  geom_col(fill = 'plum4', color = 'black', size = 0.2) +\n  coord_flip() +\n  geom_label(aes(y = export / 2, label = floor(export / 1000))) # добавляем подписи\n\n\n\n\n\n\n\n\nАннотации представляют собой объекты, размещаемые на графике вручную, и используемые, как правило, для выделения объектов и областей. Для размещения аннотаций используется функция annotate():\n\nggplot(data = trades_total, mapping = aes(x = time, y = export)) +\n  geom_area(alpha = 0.5) + # полигон с прозрачностью 0,5\n  geom_line() +\n  geom_point() +\n  geom_text(aes(label = floor(export / 1000)), \n            vjust = 0, nudge_y = 40000) +\n  annotate(\"text\", x = as.Date('2009-01-01'), y = 550000, \n           label = \"Это провал\", color = 'red')\n\n\n\n\n\n\n\n\nАннотировать можно не только подписями, но и регионами. Например, мы можем выделить область, которая соответствует импорту/экспорту продукции химической промышленности:\n\nggplot(trades_type, mapping = aes(x = export, y = import, color = sitc06, size = time)) + \n  annotate(\"rect\", xmin = 100000, xmax = 470000, ymin = 50000, ymax = 300000,  alpha = .2, color = 'black', size = 0.1) +\n  geom_point(alpha = 0.5) +\n  annotate(\"text\", x = 175000, y = 200000, label = \"Chemicals\", color = 'coral', size = 6)",
    "crumbs": [
      "Графика и статистика",
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>Продвинутая графика</span>"
    ]
  },
  {
    "objectID": "06-AdvGraphics.html#advgraphics_facets",
    "href": "06-AdvGraphics.html#advgraphics_facets",
    "title": "6  Продвинутая графика",
    "section": "6.12 Фасеты",
    "text": "6.12 Фасеты\nФасеты представляют собой множество графиков, каждый из которых отображает свою переменную или набор значений. Для разбиения на фасеты используется функция facet_wrap(), которой необходимо передать переменную разбиения с тильдой. Например, рассмотрим изменение структуры импорта по годам:\n\nbrks = c(0, 50, 100, 150, 200)\ntrades |&gt; \n  filter(sitc06 == 'Machinery and transport equipment',\n         import &gt; 20000) |&gt; \n  ggplot(mapping = aes(x = partner, y = import)) +\n  geom_col() +\n  scale_y_continuous(breaks = brks * 1e3, labels = brks) +\n  ggtitle('Импорт продукции машиностроения (мдрд долл. США)',\n        subtitle = 'Данные по ключевым партнерам') +\n  coord_flip() +\n  facet_wrap(~time)",
    "crumbs": [
      "Графика и статистика",
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>Продвинутая графика</span>"
    ]
  },
  {
    "objectID": "06-AdvGraphics.html#advgraphics_themes",
    "href": "06-AdvGraphics.html#advgraphics_themes",
    "title": "6  Продвинутая графика",
    "section": "6.13 Темы",
    "text": "6.13 Темы\nСистема ggplot интересна также тем, что для нее существует множество предопределенных “тем” или скинов для оформления графиков. Часть из них входит в состав самой библиотеки. Дополнительные темы можно установить через пакет ggthemes. Чтобы изменить тему оформления ggplot, достаточно прибавить в конце построения графика соответствующую функцию. Например, классическая черно-белая тема получается прибавлением функции theme_bw():\n\nggplot(data = trades_total, mapping = aes(x = time, y = export)) +\n  geom_area(alpha = 0.5) + # полигон с прозрачностью 0,5\n  geom_line() +\n  geom_point() +\n  geom_text(aes(label = floor(export / 1000)), \n            vjust = 0, nudge_y = 40000) +\n  theme_bw()\n\n\n\n\n\n\n\nggplot(trades_type) + \n  geom_point(mapping = aes(x = export, y = import, color = sitc06, size = time), alpha = 0.5) +\n  labs(color = \"Вид продукции\", size = 'Год') +\n  ggtitle('Соотношение импорта и экспорта в странах Евросоюза (млн долл. США)',\n          subtitle = 'Данные по ключевым партнерам') +\n  xlab('Экспорт') +\n  ylab('Импорт') +\n  theme_bw()",
    "crumbs": [
      "Графика и статистика",
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>Продвинутая графика</span>"
    ]
  },
  {
    "objectID": "06-AdvGraphics.html#advgraphics_review",
    "href": "06-AdvGraphics.html#advgraphics_review",
    "title": "6  Продвинутая графика",
    "section": "6.14 Краткий обзор",
    "text": "6.14 Краткий обзор\nДля просмотра презентации щелкните на ней один раз левой кнопкой мыши и листайте, используя кнопки на клавиатуре:\n\n\n\n\n\nПрезентацию можно открыть в отдельном окне или вкладке браузере. Для этого щелкните по ней правой кнопкой мыши и выберите соответствующую команду.",
    "crumbs": [
      "Графика и статистика",
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>Продвинутая графика</span>"
    ]
  },
  {
    "objectID": "06-AdvGraphics.html#questions_tasks_advgraphics",
    "href": "06-AdvGraphics.html#questions_tasks_advgraphics",
    "title": "6  Продвинутая графика",
    "section": "6.15 Контрольные вопросы и упражнения",
    "text": "6.15 Контрольные вопросы и упражнения\n\n6.15.1 Вопросы\n\nНазовите три основных компоненты шаблона построения графика в ggplot2.\nКак называются геометрии ggplot2, отвечающие за построение точек, линий и ступенчатых линий?\nКак называется геометрия ggplot2, отвечающая за построение столбчатой диаграммы?\nКак сделать так, чтобы графический параметр ggplot2 был постоянным для всех измерений?\nКак сделать так, чтобы графический параметр ggplot2 зависел от значения переменной?\nПеречислите названия параметров, отвечающих за цвет, размер, заливку и тип значка графического примитива.\nЕсли вы используете зависимые от значений графические переменные и при этом хотите добавить на график еще одну геометрию с постоянными параметрами, то как это можно реализовать?\nПеречислите названия режимов группировки столбчатых диаграмм и пути их реализации.\nКакая функция ggplot2 позволяет поменять местами оси координат?\nПеречислите типы шкал для осей координат, которые доступны в ggplot2.\nНазовите функцию, позволяющую перейти к полярной системе координат при построении графика в ggplot2.\nВ чем отличие построения розы-диаграммы (coxcomb chart) и секторной диаграммы (pie chart) средствами ggplot2?\nЧто делает функция labs()?\nКакие функции позволяют определить названия осей и заголовок графика?\nЧто делает функция lims()?\nКак ограничить область построения графика заданным диапазоном значений координат?\nКак ограничить применение графических переменных только к определенным значениям измерений?\nНазовите геометрии, которые позволяют размещать подписи и подписи с плашками (фоном) на графиках ggplot2.\nЧем отличаются аннотации от геометрии подписей в ggplot? Какие виды аннотаций можно создавать?\nКаким образом можно построить фасетный график, на котором каждое изображение соответствует значению переменной? Каков синтаксис вызова соответствующей функции?\nКак поменять стиль отображения (тему) графика ggplot2?\nКак получить программный доступ к таблицам Евростата, не прибегая к закачке файлов? Какой пакет можно использовать для этого?\nЧто является уникальным идентификатором таблицы в данных Евростата и как его узнать?\nКак преобразовать коды Евростата в загруженных таблицах в человеко-читаемые обозначения?\n\n\n\n6.15.2 Упражнения\n\nУпражнения данной главы частично повторяют упражнения предыдущей главы по базовой графике в целях сравнения двух графических систем R.\n\n\nПостройте для набора данных quakes пакета datasets гистограммы распределения глубин и магнитуд, а также диаграмму рассеяния для двух этих характеристик. Используйте сначала функцию qplot(), а затем выполните то же самое с использованием полного синтаксиса ggplot2().\nНа портале открытых данных Тульской области есть данные о распределении площади лесов и запасов древесины по преобладающим породам и группам возраста. Скачайте эти данные в виде таблицы CSV и постройте по ним круговую и столбчатую диаграмму для категории Площадь земель, занятых лесными насаждениями (покрытых лесной растительностью), всего. Подберите цвета, попробуйте изменить ориентировку столбцов на горизонтальную, а для круговой диаграммы поменять угол поворота.\nИспользуя данные1 по балансу масс ледника Гарабаши, постройте график с тремя кривыми (аккумуляции, абляции и кумулятивного баланса) за период 1981 по 2017 г. Добавьте на график легенду. Обратите внимание на то, что таблица содержит агрегирующие строки (1982-1997, 1998-2017, 1982-2017), которые вам необходимо предварительно исключить.\n\nПодсказка: Чтобы построить кривую кумулятивного баланса, используйте функцию cumsum.\n\nЗагрузите таблицу данных по импорту/экспорту продуктов питания, напитков и табака с портала Евростата (с использованием пакета eurostat). Постройте линейный график изменения суммарных величин импорта и экспорта по данному показателю (у вас должно получиться 2 графика на одном изображении). Используйте цвет для разделения графиков. Добавьте текстовые подписи величин импорта и экспорта. Постройте также две круговых диаграммы, показывающих соотношение ведущих импортеров и экспортеров за последний имеющийся год. Сделайте сначала это отдельными графиками, а затем одним фасетным графиком (для этого потребуется привести таблицу к длинной форме).\nПостройте линейный график хода температуры , а также столбчатую диаграмму хода суммарной солнечной радиации в Екатеринбурге на примере данных NASA POWER, загруженных в разделе 6.3.\n\nПодсказка: Для построения столбчатой диаграммы вам потребуется использовать функцию geom_col(), поскольку высота столбика отражает не встречаемость значения, а величину переменной. Также вам потребуется преобразовать таблицу среднемесячных величин к длинной форме, где название месяца будет отдельной переменной (тип — упорядоченный фактор).\n\n\n\n\n\nСамсонов Т.Е. Визуализация и анализ географических данных на языке R. М.: Географический факультет МГУ, 2023. DOI: 10.5281/zenodo.901911",
    "crumbs": [
      "Графика и статистика",
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>Продвинутая графика</span>"
    ]
  },
  {
    "objectID": "07-BaseStats.html#stat_analysis_prerequisites",
    "href": "07-BaseStats.html#stat_analysis_prerequisites",
    "title": "7  Основы статистики",
    "section": "7.1 Предварительные требования",
    "text": "7.1 Предварительные требования\nДля работы по теме текущей лекции вам понадобятся пакеты из tidyverse. Помимо этого, мы будем работать с данными через интерфейс Google Sheets напрямую с использованием пакетов googledrive и googlesheets4. Также в лекции используется пакет ggrepel, позволяющий устранять конфликты подписей на графиках ggplot:\n\nlibrary(tidyverse)\nlibrary(googlesheets4)\nlibrary(ggrepel)\nlibrary(readxl)",
    "crumbs": [
      "Графика и статистика",
      "<span class='chapter-number'>7</span>  <span class='chapter-title'>Основы статистики</span>"
    ]
  },
  {
    "objectID": "07-BaseStats.html#stat_analysis_intro",
    "href": "07-BaseStats.html#stat_analysis_intro",
    "title": "7  Основы статистики",
    "section": "7.2 Введение",
    "text": "7.2 Введение\nМатематическая статистика — раздел математики, посвящённый математическим методам систематизации, обработки и использования статистических данных для научных и практических выводов. Под статистическими данными обычно понимают числовую информацию, извлекаемую из результатов выборочных обследований, результаты серии неточных измерений и вообще любую систему количественных данных (Прохоров 2011).\nСтатистический метод представляет собой важнейший инструмент исследования, применяющийся во всех без исключения областях науки и технологий. Математическая статистика тесно связана с теорией вероятностей – разделом математики, изучающим математические модели случайных явлений. В силу огромного разнообразия статистических методов и специфики их применения в разных приложения, в одной лекции нет возможности (и смысла) представить их в одной лекции.\nВ связи с этим в настоящем разделе представляются основные инструменты статистики, такие как: простейшие приемы статистического описания (описательные статистики), проверка статистических гипотез, оценка плотности распределения, корреляция и регрессия. Помимо этого, в настоящем разделе большое внимание уделено построению специализированных графиков, отражающих особенности распределения величины: гистограмм, диаграмм размаха, линий регрессии и локальной регрессии, кривых и поверхностей плотности распределения.\n\n7.2.1 Источники данных\n\n7.2.1.1 База данных Gapminder\nВ данной лекции мы будем работать с базой данных Gapminder, которая содержит уникальный набор показателей по странам мира, агрегированный из различных источников (многие показатели имеют ряды на несколько столетий!):\n\n\n\n\n\nБаза данных Gapminder\n\n\n\n\nGapminder отлично подходит для знакомства со основами статистического анализа в R, поскольку эта база данных содержит показатели с разным видом распределения, которые сгруппированы по макрорегионам и континентам, и, разумеется, имеют между собой ряд взаимосвязей, совместное поведение которых можно изучать посредством корреляционного и регрессионного анализа.\nДанные Gapminder можно загружать в текстовом формате и формате Microsoft Excel, но также можно и через программный интерфейс Google Sheets. Для этого требуется выбрать показатель в каталоге данных, расположенном по адресу https://www.gapminder.org/data/, открыть описание источника и перейти к онлайн-таблице:\n\n\n\n\n\nПоследовательность действия для открытия данных Gapminder в формате Google Sheets\n\n\n\n\nКлюч открывшейся таблицы расположен в адресной строке между компонентами /d/ и /edit#:\n\n\n\n\n\nКлюч таблицы Google Sheets из базы данных Gapminder\n\n\n\n\n\n\n7.2.1.2 Пакет googlesheets4\nДоступ к облачным таблицам — удобный способ работы с табличными данными, который позволяет избавиться от манипуляций с локальными файлами. Свои данные вы тоже можете хранить в таблицах Google. Если таблицы регулярно обновляются держателем данных, загрузка их из облачного хранилища будет гарантировать вам актуальность анализируемой информации. Ограниченем такого режима работы является то, что для доступа к данным вам нужен Интернет.\nПакет googlesheets4 открывает доступ к таблицам Google. С кратким руководством по использованию пакета вы можете ознакомиться тут. Данный пакет использует версию 4.x Google Sheets API (отсюда цифра 4 в навании) и рекомендуется к использованию вместо устаревшего пакета googlesheets.\nПакет googlesheets4 работает в связке с пакетом googledrive, обеспечивающим общие методы доступа к Google Drive. Для загрузки достаточно вызвать функцию read_sheet(), передав ей в качестве аргумента ключ таблицы Google (см. предыдущий раздел):\nВ качестве примера возьмем данные по ВВП на душу населения:\n\ngdpdf = read_sheet('1cxtzRRN6ldjSGoDzFHkB8vqPavq1iOTMElGewQnmHgg')\ngdpdf\n\n# A tibble: 260 × 256\n   GDP per capita PPP, with p…¹ `1764` `1765` `1766` `1767` `1768` `1769` `1770`\n   &lt;chr&gt;                         &lt;dbl&gt;  &lt;dbl&gt;  &lt;dbl&gt;  &lt;dbl&gt;  &lt;dbl&gt;  &lt;dbl&gt;  &lt;dbl&gt;\n 1 Abkhazia                         NA     NA     NA     NA     NA     NA     NA\n 2 Afghanistan                      NA     NA     NA     NA     NA     NA     NA\n 3 Akrotiri and Dhekelia            NA     NA     NA     NA     NA     NA     NA\n 4 Albania                          NA     NA     NA     NA     NA     NA     NA\n 5 Algeria                          NA     NA     NA     NA     NA     NA     NA\n 6 American Samoa                   NA     NA     NA     NA     NA     NA     NA\n 7 Andorra                          NA     NA     NA     NA     NA     NA     NA\n 8 Angola                           NA     NA     NA     NA     NA     NA     NA\n 9 Anguilla                         NA     NA     NA     NA     NA     NA     NA\n10 Antigua and Barbuda              NA     NA     NA     NA     NA     NA     NA\n# ℹ 250 more rows\n# ℹ abbreviated name: ¹​`GDP per capita PPP, with projections`\n# ℹ 248 more variables: `1771` &lt;dbl&gt;, `1772` &lt;dbl&gt;, `1773` &lt;dbl&gt;, `1774` &lt;dbl&gt;,\n#   `1775` &lt;dbl&gt;, `1776` &lt;dbl&gt;, `1777` &lt;dbl&gt;, `1778` &lt;dbl&gt;, `1779` &lt;dbl&gt;,\n#   `1780` &lt;dbl&gt;, `1781` &lt;dbl&gt;, `1782` &lt;dbl&gt;, `1783` &lt;dbl&gt;, `1784` &lt;dbl&gt;,\n#   `1785` &lt;dbl&gt;, `1786` &lt;dbl&gt;, `1787` &lt;dbl&gt;, `1788` &lt;dbl&gt;, `1789` &lt;dbl&gt;,\n#   `1790` &lt;dbl&gt;, `1791` &lt;dbl&gt;, `1792` &lt;dbl&gt;, `1793` &lt;dbl&gt;, `1794` &lt;dbl&gt;, …\n\n\nАналогично рассмотрим показатель ожидаемой продолжительности жизни:\n\nlifedf = read_sheet('1H3nzTwbn8z4lJ5gJ_WfDgCeGEXK3PVGcNjQ_U5og8eo')\nlifedf\n\n# A tibble: 260 × 218\n   `Life expectancy`     `1800` `1801` `1802` `1803` `1804` `1805` `1806` `1807`\n   &lt;chr&gt;                  &lt;dbl&gt;  &lt;dbl&gt;  &lt;dbl&gt;  &lt;dbl&gt;  &lt;dbl&gt;  &lt;dbl&gt;  &lt;dbl&gt;  &lt;dbl&gt;\n 1 Abkhazia                NA     NA     NA     NA     NA     NA     NA     NA  \n 2 Afghanistan             28.2   28.2   28.2   28.2   28.2   28.2   28.2   28.1\n 3 Akrotiri and Dhekelia   NA     NA     NA     NA     NA     NA     NA     NA  \n 4 Albania                 35.4   35.4   35.4   35.4   35.4   35.4   35.4   35.4\n 5 Algeria                 28.8   28.8   28.8   28.8   28.8   28.8   28.8   28.8\n 6 American Samoa          NA     NA     NA     NA     NA     NA     NA     NA  \n 7 Andorra                 NA     NA     NA     NA     NA     NA     NA     NA  \n 8 Angola                  27.0   27.0   27.0   27.0   27.0   27.0   27.0   27.0\n 9 Anguilla                NA     NA     NA     NA     NA     NA     NA     NA  \n10 Antigua and Barbuda     33.5   33.5   33.5   33.5   33.5   33.5   33.5   33.5\n# ℹ 250 more rows\n# ℹ 209 more variables: `1808` &lt;dbl&gt;, `1809` &lt;dbl&gt;, `1810` &lt;dbl&gt;, `1811` &lt;dbl&gt;,\n#   `1812` &lt;dbl&gt;, `1813` &lt;dbl&gt;, `1814` &lt;dbl&gt;, `1815` &lt;dbl&gt;, `1816` &lt;dbl&gt;,\n#   `1817` &lt;dbl&gt;, `1818` &lt;dbl&gt;, `1819` &lt;dbl&gt;, `1820` &lt;dbl&gt;, `1821` &lt;dbl&gt;,\n#   `1822` &lt;dbl&gt;, `1823` &lt;dbl&gt;, `1824` &lt;dbl&gt;, `1825` &lt;dbl&gt;, `1826` &lt;dbl&gt;,\n#   `1827` &lt;dbl&gt;, `1828` &lt;dbl&gt;, `1829` &lt;dbl&gt;, `1830` &lt;dbl&gt;, `1831` &lt;dbl&gt;,\n#   `1832` &lt;dbl&gt;, `1833` &lt;dbl&gt;, `1834` &lt;dbl&gt;, `1835` &lt;dbl&gt;, `1836` &lt;dbl&gt;, …\n\n\nДальнейшие примеры статистического анализа будут основываться на этих данных.",
    "crumbs": [
      "Графика и статистика",
      "<span class='chapter-number'>7</span>  <span class='chapter-title'>Основы статистики</span>"
    ]
  },
  {
    "objectID": "07-BaseStats.html#stat_analysis_one",
    "href": "07-BaseStats.html#stat_analysis_one",
    "title": "7  Основы статистики",
    "section": "7.3 Одна переменная",
    "text": "7.3 Одна переменная\n\n7.3.1 Оценка распределения\nДля оценки распределения случайной величины можно использовать графические и статистические способы. Выявление типа распределения важно, поскольку статистические методы не универсальны, и во многих случаях предполагают, что изучаемая переменная подчиняется определенному закону распределения (как правило, нормальному).\nПриведем выгруженные ранее данные ВВП к аккуратному виду, избавившись от множества столбцов с годом измерения. Сразу получим данные за 2015 год для анализа:\n\ngdpdf_tidy = gdpdf %&gt;% \n   pivot_longer(cols = `1764`:`2018`, \n                names_to = 'year', \n                values_to = 'gdp',\n                names_transform = list(year = as.integer)) %&gt;% \n   rename(Country = 1)\n\ngdpdf15 = filter(gdpdf_tidy, year == 2015)\n\ngdpdf15\n\n# A tibble: 260 × 3\n   Country                year    gdp\n   &lt;chr&gt;                 &lt;int&gt;  &lt;dbl&gt;\n 1 Abkhazia               2015    NA \n 2 Afghanistan            2015  1418.\n 3 Akrotiri and Dhekelia  2015    NA \n 4 Albania                2015  7343.\n 5 Algeria                2015  6797.\n 6 American Samoa         2015    NA \n 7 Andorra                2015    NA \n 8 Angola                 2015  6512.\n 9 Anguilla               2015    NA \n10 Antigua and Barbuda    2015 14884.\n# ℹ 250 more rows\n\n\nДля визуальной проверки вида распределения можно использовать геометрию geom_histogram():\n\nggplot(gdpdf15, aes(x = gdp)) + \n  geom_histogram()\n\n\n\n\n\n\n\n\nИзменить ширину кармана можно, используя параметр binwidth:\n\nggplot(gdpdf15, aes(x = gdp)) + \n  geom_histogram(binwidth = 5000, color = 'black', fill = 'steelblue', size = 0.2)\n\n\n\n\n\n\n\n\nПреобразуем в аккуратный вид и строим гистограмму распределения:\n\nlifedf_tidy = lifedf %&gt;% \n  pivot_longer(cols = `1800`:`2016`, \n               names_to = 'year', \n               values_to = 'lifexp',\n               names_transform = list(year = as.integer)) %&gt;% \n  rename(Country = 1)\n\nlifedf15 = dplyr::filter(lifedf_tidy, year == 2015)\n\nggplot(lifedf15, aes(x = lifexp)) + \n  geom_histogram(binwidth = 2, color = 'black', fill = 'olivedrab', size = 0.2)\n\n\n\n\n\n\n\n\nДля графической оценки распределения удобно использовать не только гистограмму, но также метод ядерного сглаживания (kernel density), который позволяет строить аппроксимацию функции плотности вероятности. Условно говоря, ядро является функцией, которая позволяет распространить потенциал каждого элемента выборки на его ближайшую окрестность. Чем больше элементов выборки сконцентрировано вблизи данной точки, тем сильнее будет их совокупно наведенный потенциал в данной точке, и тем, соответственно, выше оценка плотности распределения, которая получается суперпозицией этих потенциалов. Математически операция ядерной оценки плотности в точке \\(x\\) определяется как: \\[\n\\hat f_h (x) = \\frac{1}{nh}\\sum_{i=1}^{n}K\\Big(\\frac{x - x_i}{h}\\Big)\n\\] где \\(K\\) — ядерная функция, \\(h &gt; 0\\) — сглаживающий параметр, \\(x_i\\) — элементы выборки, \\(n\\) — размер выборки. Ядерная функция должна удовлетворять двум критериям: \\(K(x) \\geq 0\\), \\(\\int_{-\\infty}^{+\\infty} K(x) dx = 1\\). Отсюда ясно, что любая модель функции плотности распределения может быть использована в качестве ядра: равномерное, нормальное и т.д. Как правило, ядерная функция носит бесконечно убывающий характер: чем дальше мы находимся от точки, тем меньше ее вклад в плотность распределения.\nВ ggplot за аппроксимацию плотности распределения методом ядерного сглаживания отвечает геометрия geom_density():\n\nggplot(gdpdf15, aes(x = gdp)) + \n  geom_density(color = 'black', fill = 'steelblue', alpha = 0.5)\n\n\n\n\n\n\n\nggplot(lifedf15, aes(x = lifexp)) + \n  geom_density(color = 'black', fill = 'olivedrab', alpha = 0.5)\n\n\n\n\n\n\n\n\nВы можете комбинировать гистограммы и оценку плотности распределения, но для этого гистограмма по оси Y должна отражать не фактическое количество элементов в каждом классе, а долю или плотность вероятности (y = stat(density)):\n\nggplot(gdpdf15, aes(x = gdp)) + \n  geom_histogram(aes(y = stat(density)), fill = 'grey', color = 'black', size = 0.1) +\n  geom_density(color = 'black', fill = 'steelblue', alpha = 0.5)\n\n\n\n\n\n\n\nggplot(lifedf15, aes(x = lifexp)) + \n  geom_histogram(aes(y = stat(density)), fill = 'grey', color = 'black', size = 0.1) +\n  geom_density(color = 'black', fill = 'olivedrab', alpha = 0.5)\n\n\n\n\n\n\n\n\nПри построении гистограмм и оценке плотности распределения мы допустили ошибку: приняли, что все измерения являются равнозначными. Однако в данном случае это не так. Население Люксембурга и Пакистана отличается на два порядка — это означает, что Пакистан должен иметь соответственно больший вес при построении гистограммы. Для учета этой характеристики подгрузим из Gapminder данные по численности населения и присоединим их к нашим таблицам по ВВП и продолжительности жизни:\n\npopdf_tidy = \n  read_sheet('1IbDM8z5XicMIXgr93FPwjgwoTTKMuyLfzU6cQrGZzH8') %&gt;% # численность населения\n  pivot_longer(cols = `1800`:`2015`, \n               names_to = 'year', \n               values_to = 'pop',\n               names_transform = list(year = as.integer)) %&gt;% \n  rename(Country = 1)\n\n(tab = gdpdf_tidy %&gt;% \n    inner_join(lifedf_tidy) %&gt;% \n    inner_join(popdf_tidy))\n\n# A tibble: 19,359 × 5\n   Country   year   gdp lifexp   pop\n   &lt;chr&gt;    &lt;int&gt; &lt;dbl&gt;  &lt;dbl&gt; &lt;dbl&gt;\n 1 Abkhazia  1800    NA     NA    NA\n 2 Abkhazia  1810    NA     NA    NA\n 3 Abkhazia  1820    NA     NA    NA\n 4 Abkhazia  1830    NA     NA    NA\n 5 Abkhazia  1840    NA     NA    NA\n 6 Abkhazia  1850    NA     NA    NA\n 7 Abkhazia  1860    NA     NA    NA\n 8 Abkhazia  1870    NA     NA    NA\n 9 Abkhazia  1880    NA     NA    NA\n10 Abkhazia  1890    NA     NA    NA\n# ℹ 19,349 more rows\n\n\nТеперь мы можем произвести взвешенную оценку плотности распределения:\n\ntab15 = tab %&gt;%  \n  dplyr::filter(year == 2015) %&gt;% \n  drop_na() # все веса должны быть непустыми!\n\nggplot(tab15, aes(x = gdp, y = stat(density), weight = pop/sum(pop))) + \n  geom_histogram(binwidth = 5000, fill = 'grey', color = 'black', size = 0.1) +\n  geom_density(color = 'black', fill = 'steelblue', alpha = 0.5)\n\n\n\n\n\n\n\nggplot(tab15, aes(x = lifexp, y = stat(density), weight = pop/sum(pop))) + \n  geom_histogram(binwidth = 2.5, fill = 'grey', color = 'black', size = 0.1) +\n  geom_density(color = 'black', fill = 'olivedrab', alpha = 0.5)\n\n\n\n\n\n\n\n\nГрафики плотности распределения удобны тем, что их, в отличие от гистограмм, удобно комбинировать на одном изображении, используя цвет для разделения по еще одной переменной. Например, мы можем оценить, как изменились мировые диспропорции в продолжительности жизни и доходов населения за последние 50 лет (обратите внимание на параметр fill = year в эстетике:\n\ntab85 = tab %&gt;% \n  dplyr::filter(year %in%  c(1965, 2015)) %&gt;% \n  drop_na()\n\nggplot(tab85, aes(x = gdp, fill = factor(year), weight = pop/sum(pop))) + \n  geom_density(alpha = 0.5)\n\n\n\n\n\n\n\nggplot(tab85, aes(x = lifexp, fill = factor(year), weight = pop/sum(pop))) + \n  geom_density(alpha = 0.5)\n\n\n\n\n\n\n\n\n\n\n7.3.2 Описательные статистики\nОписательные статистики — это числовые характеристики, описывающие особенности статистического распределения изучаемой величины. К таким характеристикам относят выборочное среднее, медиану, минимум, максимум и ряд других величин. Можно вычислять эти характеристики для всей выборки, но для включения географического контекста мы стратифицируем ее по макрорегионам, которые используются в базе данных Gapminder. Подгрузим эту информацию (географические данные находятся по адресу https://www.gapminder.org/data/geo/):\n\ncountries = read_sheet('1qHalit8sXC0R8oVXibc2wa2gY7bkwGzOybEMTWp-08o', 2) %&gt;%\n  select(Country = name, Region = eight_regions) %&gt;%\n  mutate(Country = factor(Country, levels = Country[order(.$Region)]))\n\n# '1IbDM8z5XicMIXgr93FPwjgwoTTKMuyLfzU6cQrGZzH8' %&gt;% # численность населения\n#   as_id() %&gt;% # преобразуем идентификатор в класс drive_id чтобы отличать его от пути\n#   drive_get() %&gt;% \n#   read_sheet(sheet = 2) -&gt; countries\n\nВизуализируем:\n\nggplot(countries, aes(x = Country, y = 1, fill = Region)) +\n  geom_col() +\n  geom_text(aes(y = 0.5, label = Country), size = 3) +\n  facet_wrap(~Region, scales = \"free\", ncol = 4) +\n  theme_bw()+\n  theme(panel.grid = element_blank(),\n        axis.title.y = element_blank(),\n        axis.text.y = element_blank(),\n        axis.ticks.y = element_blank(),\n        axis.title.x = element_blank(),\n        axis.text.x = element_blank(),\n        axis.ticks.x = element_blank()) +\n  guides(fill=FALSE) +\n  coord_flip()\n\n\n\n\n\n\n\n\nПрисоединим эти данные к исходной таблице:\n\n(tabreg = tab %&gt;% \n  left_join(countries) %&gt;% \n  dplyr::filter(year == 2015) %&gt;% \n  drop_na())\n\n# A tibble: 172 × 6\n   Country              year    gdp lifexp      pop Region            \n   &lt;chr&gt;               &lt;int&gt;  &lt;dbl&gt;  &lt;dbl&gt;    &lt;dbl&gt; &lt;chr&gt;             \n 1 Afghanistan          2015  1418.   53.8 32526562 asia_west         \n 2 Albania              2015  7343.   78    2896679 europe_east       \n 3 Algeria              2015  6797.   76.4 39666519 africa_north      \n 4 Angola               2015  6512.   59.6 25021974 africa_sub_saharan\n 5 Antigua and Barbuda  2015 14884.   76.4    91818 america_north     \n 6 Argentina            2015 16640.   76.5 43416755 america_south     \n 7 Armenia              2015  5561.   74.7  3017712 europe_east       \n 8 Australia            2015 38085.   82.3 23968973 east_asia_pacific \n 9 Austria              2015 37811.   81.3  8544586 europe_west       \n10 Azerbaijan           2015 10475.   72.9  9753968 europe_east       \n# ℹ 162 more rows\n\n\nМы уже знакомы с функциями min(), max(), median(), mean(), sd(), которые дают значения соответствующих описательных статистик для векторов данных. Как представить их все одновременно? Для визуализации отличий в статистических параметрах исследуемой выборки удобно использовать тип графика, который называется boxplot (а по русски — диаграмма размаха, улей, или ящик с усами). В ggplot за него отвечает геометрия geom_boxplot():\n\nggplot(tabreg, aes(x = Region, y = gdp)) +\n  geom_boxplot() + coord_flip()\n\n\n\n\n\n\n\nggplot(tabreg, aes(x = Region, y = lifexp)) +\n  geom_boxplot() + coord_flip()\n\n\n\n\n\n\n\n\nДанные графики наглядно показывают, что регионы отличаются по ряду статистических параметров исследуемой переменной: среднему значению, размаху вариации (разбросу значений), среднеквадратическому отклонению Эти статистики можно получить и в табличном виде:\n\n(tabreg %&gt;% \n  group_by(Region) %&gt;% \n  summarise(gdp_mean = mean(gdp),\n            gdp_sd = sd(gdp),\n            lifexp_mean = mean(lifexp),\n            lifexp_sd = sd(lifexp)))\n\n# A tibble: 8 × 5\n  Region             gdp_mean gdp_sd lifexp_mean lifexp_sd\n  &lt;chr&gt;                 &lt;dbl&gt;  &lt;dbl&gt;       &lt;dbl&gt;     &lt;dbl&gt;\n1 africa_north          6897.  3386.        73        4.97\n2 africa_sub_saharan    3583.  4553.        62.3      5.31\n3 america_north        13835. 11451.        74.9      4.00\n4 america_south        10350.  4277.        75.1      3.50\n5 asia_west            16374. 20957.        73.7      6.51\n6 east_asia_pacific    14062. 16634.        72.4      6.68\n7 europe_east          13634.  7030.        75.9      2.86\n8 europe_west          33571. 11104.        81.5      1.24\n\n\n\n\n7.3.3 Статистические тесты\nПрежде чем манипулировать вычисленными статистиками (говорить, что в Западной Европе ВВП на душу населения в 10 раз выше, чем в Южной Африке), необходимо убедиться, что их отличия являются статистически значимыми. На статистическую значимость влияет не только абсолютная разность средних, но также характер распределения и объем выборки — выборки малого объема не могут дать высокой статистической значимости.\nДля сравнения средних значений и дисперсий двух статистических выборок обычно используют тест Стьюдента и тест Фишера соответственно.\nПроведем тесты для сравнения средних по Европе и Южной Африке используя функцию t.test() (на самом деле это тест Уэлча, являющийся модификацией теста Стьюдента):\n\nt.test(tabreg %&gt;% dplyr::filter(Region == 'africa_sub_saharan') %&gt;% pull(gdp),\n       tabreg %&gt;% dplyr::filter(Region == 'europe_west') %&gt;% pull(gdp))\n\n\n    Welch Two Sample t-test\n\ndata:  tabreg %&gt;% dplyr::filter(Region == \"africa_sub_saharan\") %&gt;% pull(gdp) and tabreg %&gt;% dplyr::filter(Region == \"europe_west\") %&gt;% pull(gdp)\nt = -11.384, df = 20.547, p-value = 2.487e-10\nalternative hypothesis: true difference in means is not equal to 0\n95 percent confidence interval:\n -35473.63 -24502.15\nsample estimates:\nmean of x mean of y \n 3583.326 33571.214 \n\nt.test(tabreg %&gt;% dplyr::filter(Region == 'africa_sub_saharan') %&gt;% pull(lifexp),\n       tabreg %&gt;% dplyr::filter(Region == 'europe_west') %&gt;% pull(lifexp))\n\n\n    Welch Two Sample t-test\n\ndata:  tabreg %&gt;% dplyr::filter(Region == \"africa_sub_saharan\") %&gt;% pull(lifexp) and tabreg %&gt;% dplyr::filter(Region == \"europe_west\") %&gt;% pull(lifexp)\nt = -23.037, df = 55.262, p-value &lt; 2.2e-16\nalternative hypothesis: true difference in means is not equal to 0\n95 percent confidence interval:\n -20.87392 -17.53317\nsample estimates:\nmean of x mean of y \n 62.25435  81.45789 \n\n\np-значения для данных тестов очень малы, что позволяет нам принять (не отвергать) гипотезу о неравенстве средних для Западной Европы и Южной Африки.\nПроверим, так ли значимы отличия в средних для Северной и Южной Америки:\n\nt.test(tabreg %&gt;% dplyr::filter(Region == 'america_north') %&gt;% pull(gdp),\n       tabreg %&gt;% dplyr::filter(Region == 'america_south') %&gt;% pull(gdp))\n\n\n    Welch Two Sample t-test\n\ndata:  tabreg %&gt;% dplyr::filter(Region == \"america_north\") %&gt;% pull(gdp) and tabreg %&gt;% dplyr::filter(Region == \"america_south\") %&gt;% pull(gdp)\nt = 1.1742, df = 23.283, p-value = 0.2522\nalternative hypothesis: true difference in means is not equal to 0\n95 percent confidence interval:\n -2650.736  9620.806\nsample estimates:\nmean of x mean of y \n 13834.72  10349.69 \n\nt.test(tabreg %&gt;% dplyr::filter(Region == 'america_north') %&gt;% pull(lifexp),\n       tabreg %&gt;% dplyr::filter(Region == 'america_south') %&gt;% pull(lifexp))\n\n\n    Welch Two Sample t-test\n\ndata:  tabreg %&gt;% dplyr::filter(Region == \"america_north\") %&gt;% pull(lifexp) and tabreg %&gt;% dplyr::filter(Region == \"america_south\") %&gt;% pull(lifexp)\nt = -0.20306, df = 25.802, p-value = 0.8407\nalternative hypothesis: true difference in means is not equal to 0\n95 percent confidence interval:\n -3.121651  2.560540\nsample estimates:\nmean of x mean of y \n 74.86111  75.14167 \n\n\nВ данном случае, несмотря на то, что вычисленные значения средних отличаются, тест показывает очень высокие p-значения (0.25 и 0.84 соответственно), что не позволяет нам говорить о том, что эти отличия статистически значимы. Соответственно, делать на их основе какие-либо научные выводы нельзя.\nАналогичным образом можно проверить статистическую значимость отличий в дисперсии (вариации значений) для разных регионов. Для этого используем функцию var.test() применительно к регионам Западной и Восточной Европы:\n\nvar.test(tabreg %&gt;% dplyr::filter(Region == 'europe_east') %&gt;% pull(gdp),\n       tabreg %&gt;% dplyr::filter(Region == 'europe_west') %&gt;% pull(gdp))\n\n\n    F test to compare two variances\n\ndata:  tabreg %&gt;% dplyr::filter(Region == \"europe_east\") %&gt;% pull(gdp) and tabreg %&gt;% dplyr::filter(Region == \"europe_west\") %&gt;% pull(gdp)\nF = 0.40087, num df = 22, denom df = 18, p-value = 0.0434\nalternative hypothesis: true ratio of variances is not equal to 1\n95 percent confidence interval:\n 0.1585416 0.9726112\nsample estimates:\nratio of variances \n         0.4008741 \n\nvar.test(tabreg %&gt;% dplyr::filter(Region == 'europe_east') %&gt;% pull(lifexp),\n       tabreg %&gt;% dplyr::filter(Region == 'europe_west') %&gt;% pull(lifexp))\n\n\n    F test to compare two variances\n\ndata:  tabreg %&gt;% dplyr::filter(Region == \"europe_east\") %&gt;% pull(lifexp) and tabreg %&gt;% dplyr::filter(Region == \"europe_west\") %&gt;% pull(lifexp)\nF = 5.3246, num df = 22, denom df = 18, p-value = 0.0006859\nalternative hypothesis: true ratio of variances is not equal to 1\n95 percent confidence interval:\n  2.105831 12.918723\nsample estimates:\nratio of variances \n          5.324617 \n\n\nДанный тест показывает, что отличия в вариации значений ВВП на душу населения для Западной и Восточной Европы носят пограничный характер (p = 0.04), и принимать их можно только если стоит относительно высокое пороговое значение p = 0.05. В то же время, вариация продолжительности жизни для Западной Европы существенной меньше, чем для Восточной и при данной выборке это отличие обладает высокой статистической значимостью (p = 0.0007). Соответственно, его можно принимать с уверенностью.",
    "crumbs": [
      "Графика и статистика",
      "<span class='chapter-number'>7</span>  <span class='chapter-title'>Основы статистики</span>"
    ]
  },
  {
    "objectID": "07-BaseStats.html#stat_analysis_two",
    "href": "07-BaseStats.html#stat_analysis_two",
    "title": "7  Основы статистики",
    "section": "7.4 Две переменных",
    "text": "7.4 Две переменных\nДостаточно часто в задачах анализа данных возникает необходимость совместного изучения нескольких переменных. Данный раздел посвящен анализу двух переменных.\n\n7.4.1 Оценка распределения\n\n7.4.1.1 Диаграмма рассеяния\nПервичный анализ производится путем оценки совместного распределения переменных на плоскости (для двух переменных) путем построения диаграммы рассеяния. С этим графиком мы уже хорошо знакомы:\n\nggplot(tabreg, aes(gdp, lifexp)) +\n  geom_point()\n\n\n\n\n\n\n\n\nОчевидно, что в данном случае мы имеем с нелинейной зависимостью. Чтобы упростить задачу по дальнейшему анализу, можно попробовать перейти к логарифмической шкале по оси X:\n\noptions(scipen = 999)\nggplot(tabreg, aes(gdp, lifexp)) +\n  geom_point() +\n  scale_x_log10()\n\n\n\n\n\n\n\n\nНа диаграмме рассеяния важно показать не только местоположение точек, но также их весовую значимость, которая в данном случае определяется численностью населения в стране. Введем соответствующую графическую переменную — размер точки:\n\nggplot(tabreg, aes(gdp, lifexp, size = pop)) +\n  geom_point(alpha = 0.5) +\n  scale_x_log10()\n\n\n\n\n\n\n\n\nЕще сильнее повысить информативность диаграммы рассеяния можно, используя цвет точек для обозначения региона принадлежности. Это позволит понять связь между введенной нами географической стратификацией и распределением элементов выборки на диаграмме рассеяния:\n\nggplot(tabreg, aes(gdp, lifexp, size = pop, color = Region)) +\n  geom_point(alpha = 0.5) +\n  scale_x_log10() +\n  theme_bw()\n\n\n\n\n\n\n\n\nИспользование цвета наглядно показывает, что африканские страны занимают нижнюю левую часть диаграммы рассеяния с малой величиной ВВП и низкой продолжительностью жизни.\nЦелесообразно также добавить подписи крупнейших стран мира с населением более 100 млн чел, а также страны, занимающие экстремальные позиции по обеим осям, чтобы понять положение ключевых игроков на диаграмме:\n\ntablab = tabreg %&gt;% # табличка для подписей\n  dplyr::filter(\n    pop &gt; 1e8 | \n    gdp == min(gdp) | \n    gdp == max(gdp) | \n    lifexp == min(lifexp) | \n    lifexp == max(lifexp)\n  )\n\nggplot(tabreg, aes(gdp, lifexp, color = Region)) +\n  geom_point(aes(size = pop), alpha = 0.5) +\n  geom_text(data = tablab, \n            aes(label = Country),\n            check_overlap = TRUE,\n            show.legend = FALSE) + # убрать текст из легенды\n  scale_x_log10() +\n  theme_bw()\n\n\n\n\n\n\n\n\nУстранение перекрытий подписей можно осуществить, используя геометрию geom_text_repel() из пакета ggrepel вместо стандартной geom_text()\n\nggplot(tabreg, aes(gdp, lifexp,  color = Region)) +\n  geom_point(aes(size = pop), alpha = 0.5) +\n  geom_text_repel(data = tablab, \n                  aes(label = Country),\n                  box.padding = 0.7,  # зазор вокруг подписи\n                  segment.size = 0.2, # толщина линии выноски\n                  show.legend = FALSE) + # убрать текст из легенды\n  scale_x_log10() +\n  labs(label = element_blank()) +\n  theme_bw()\n\n\n\n\n\n\n\n\n\n\n7.4.1.2 Плотность распределения\nПлотность совместного распределения двух случайных величин представляет собой уже не кривую, а поверхность, которую можно построить с использованием геометрии geom_density_2d(). По умолчанию эта геометрия визуализируется в форме изолиний:\n\nggplot(tabreg, aes(gdp, lifexp)) +\n  geom_point(alpha = 0.5) +\n  geom_density_2d()+\n  scale_x_log10() +\n  theme_bw()\n\n\n\n\n\n\n\n\nУсилить наглядность представления можно, добавив вспомогательную растровую поверхность плотности распределения (по которой, собственно, и строятся изолинии). Обратите внимание, что для растра используется функция stat_density():\n\nggplot(tabreg, aes(gdp, lifexp)) +\n  stat_density_2d(geom = \"raster\", aes(fill = stat(density)), contour = FALSE) +\n  geom_density_2d(color = 'black', size = 0.2) +\n  geom_point(alpha = 0.5) +\n  scale_fill_gradient(low = \"white\", high = \"red\") +\n  scale_x_log10() +\n  theme_bw()\n\n\n\n\n\n\n\n\nГрафик двумерной плотности распределения показывает, что мода распределения, т.е. наиболее часто встречающийся случай, примерно соответствует странам с продолжительностью жизни 75 лет и ВВП на душу населения $10000.\nВ некоторых случаях удобнее оказывается не аппроксимация непрерывной поверхности плотности распределения, а подсчет количества измерений по ячейкам регулярной сетки — квадратным или гексагональным. Такой подход бывает особенно полезен, когда точек измерений очень много и из-за их количества оказывается проблематично разглядеть области их концентрации. Агрегирование данных по ячейкам осуществляется путем применения геометрий geom_bin2d() и geom_hex():\n\nggplot(tabreg, aes(gdp, lifexp)) +\n  geom_bin2d(bins = 10)+\n  geom_point(alpha = 0.5) +\n  scale_fill_gradient(low = \"white\", high = \"red\") +\n  scale_x_log10() +\n  theme_bw()\n\n\n\n\n\n\n\nggplot(tabreg, aes(gdp, lifexp)) +\n  geom_hex(bins = 10) +\n  geom_point(alpha = 0.5) +\n  scale_fill_gradient(low = \"white\", high = \"red\") +\n  scale_x_log10() +\n  theme_bw()\n\n\n\n\n\n\n\n\n\n\n\n7.4.2 Корреляция и регрессия\nКорреляционный анализ позволяет дать численную характеристику статистической связи между двумя случайными величинами, а регрессионный анализ — моделировать эту взаимосвязь посредством построения функции взаимосвязи зависимой и множества независимых переменных.\n\n7.4.2.1 Корреляция\nКоэффициент корреляции — это числовая характеристика совместного распределения двух случайных величин, характеризующая их взаимосвязь. Наиболее часто в статистике употребляется выборочный коэффициент корреляции Пирсона, в котором перебираются все пары соответствующих друг другу значений из рядов \\(X = \\{x_i\\}\\) и \\(Y = \\{y_i\\}\\): \\[\nr_{xy} = \\frac{\\sum_{i=1}^{n}(x_i - \\bar x)(y_i - \\bar y)}{\\sqrt{\\sum_{i=1}^{n}(x_i - \\bar x)^2} \\sqrt{\\sum_{i=1}^{n}(y_i - \\bar y)^2}},\n\\] где \\(\\bar x\\) и \\(\\bar y\\) соответствуют выборочным средним для \\(X\\) и \\(Y\\).\nВажно помнить, что коэффициент корреляции Пирсона характеризует силу линейной связи между двумя величинами. Поэтому, если наблюдаемая нами картина взаимосвязи носит нелинейный характер, необходимо предварительно линеаризовать ее, то есть выполнить преобразование над переменными, приводящее к получению линейной зависимости. В нашем в случае изучения ВВП на душу населения и продолжительности жизни мы видели, что линеаризация возможна путем логарифмирования показателя ВВП.\nДля вычисления коэффициента корреляции Пирсона в R с оценкой уровня значимости используется функция cor.test():\n\ncor.test(tabreg$gdp, tabreg$lifexp)\n\n\n    Pearson's product-moment correlation\n\ndata:  tabreg$gdp and tabreg$lifexp\nt = 11.376, df = 170, p-value &lt; 0.00000000000000022\nalternative hypothesis: true correlation is not equal to 0\n95 percent confidence interval:\n 0.5632175 0.7347928\nsample estimates:\n      cor \n0.6574446 \n\n\nРезультат теста в данном случае показывает, что коэффициент корреляции с вероятностью 0,95 находится в интервале от 0,56 до 0,73, и его математическое ожидание равно 0,66.\nПроверим, можно ли уточнить эту оценку, выполнив логарифмирование показателя ВВП:\n\ncor.test(log(tabreg$gdp), tabreg$lifexp)\n\n\n    Pearson's product-moment correlation\n\ndata:  log(tabreg$gdp) and tabreg$lifexp\nt = 17.327, df = 170, p-value &lt; 0.00000000000000022\nalternative hypothesis: true correlation is not equal to 0\n95 percent confidence interval:\n 0.7375973 0.8473619\nsample estimates:\n      cor \n0.7990415 \n\n\nВидим, что логарифмирование показателя позволяет повысить значение коэффициента корреляции до 0,8. При этом доверительный интервал, заключающий в себя эту величину с вероятностью 0,95 существенно сузился: с 0,17 до 0,11. Очевидно, мы получили более корректную оценку взаимосвязи.\n\n\n7.4.2.2 Регрессия\nДля построения статистической модели этой зависимости, позволяющей по значениям независимой переменной вычислять значения зависимой переменной, необходимо провести регрессионный анализ. В общем случае кривая регрессии обычно выражается линейной комбинацией набора функций: \\[\ny(x) = β_0φ_0(x)+ β_1φ_1(x)+...+ β_mφ_m(x)\n\\] Наиболее часто используется полиномиальная регрессия, при которой \\[\ny(x) = β_0+β_1x+...+ β_mx^m.\n\\] В этом случае основная задача регрессионного анализа сводится к поиску неизвестных коэффициентов \\(β_0,...,β_m\\), который осуществляется методом наименьших квадратов. Результатом этого поиска являются выборочные коэффициенты регрессии \\(\\hat β_0,...,\\hat β_m\\), которые дают оценку искомых параметров \\(β_0,...,β_m\\). В итоге эмпирическая линия регрессии определяется многочленом \\[\n\\hat y(x)=\\hat β_0+\\hat β_1x+...+\\hat β_mx_m,\n\\] который и служит статистической оценкой неизвестной формы функциональной зависимости между исследуемыми величинами.\nДля представления моделей в R существует специальный объект, который называется формула. Формула имеет вид f ~ x + y + ..., что интерпретируется соответствующими функциями как \\(f = β_0 + β_1x + β_2y + \\dots\\)\n\nОбратите внимание на символ тильды (~) — он является отличительной особенностью формулы и интерпретируется как «зависит от».\n\nВместо переменных в формуле вы можете использовать функции от переменных. Например log(f) ~ log(x) + sqrt(y) означает модель \\(\\log f = β_0 + β_1 \\log x + β_2 \\sqrt y\\). Если необходимо выполнить алгебраические преобразования переменных или задать конкретное значение свободного члена, то их необходимо заключить в специальную функцию I(): f ~ log(x) + I(y ^ 2) + I(0) будет означать модель вида \\(f = β_1 \\log x + β_2 y^2\\).\nДля краткой записи полиномиальной зависимости можно использовать вспомогательную функцию poly(), которая в качестве второго аргумента принимает степень многочлена. Т.е. f ~ poly(x, 3) означает модель вида \\(f = β_0 + β_1x + β_2x^2 + β_3x^3\\).\nОценка параметров линейных моделей осуществляется с помощью функции lm(). В нашем случае модель носит простой характер:\n\nmodel = lm(lifexp ~ log(gdp), data = tabreg)\ncoef(model)\n\n(Intercept)    log(gdp) \n  25.129347    5.261476 \n\n\nПолученные данные говорят нам о том, что уравнение имеет вид \\(lifexp = 25.13 + 5.26 \\log(gdp)\\). Чтобы получить подробную сводку о качестве модели, мы можем вызвать summary():\n\nsummary(model)\n\n\nCall:\nlm(formula = lifexp ~ log(gdp), data = tabreg)\n\nResiduals:\n     Min       1Q   Median       3Q      Max \n-18.4327  -1.9398   0.6394   3.1638  10.1937 \n\nCoefficients:\n            Estimate Std. Error t value            Pr(&gt;|t|)    \n(Intercept)  25.1293     2.7178   9.246 &lt;0.0000000000000002 ***\nlog(gdp)      5.2615     0.3037  17.327 &lt;0.0000000000000002 ***\n---\nSignif. codes:  0 '***' 0.001 '**' 0.01 '*' 0.05 '.' 0.1 ' ' 1\n\nResidual standard error: 4.785 on 170 degrees of freedom\nMultiple R-squared:  0.6385,    Adjusted R-squared:  0.6363 \nF-statistic: 300.2 on 1 and 170 DF,  p-value: &lt; 0.00000000000000022\n\n\nРезультаты оценки говорят о том, что регрессия построена удовлетворительно. Коэффициент детерминации (квадрат коэффициента корреляции) равен 0,64.\nДля визуализации модели можно извлечь из нее значения используя функцию fitted():\n\ndf = tibble(lifexp = fitted(model),\n            gdp = tabreg$gdp)\n              \nggplot(tabreg, aes(gdp, lifexp)) +\n  geom_point(alpha = 0.5) +\n  geom_line(data = df, aes(gdp, lifexp), color = 'red', size = 1) +\n  theme_bw()\n\n\n\n\n\n\n\n\nЕсли вам нужно только построить линию регрессии, но не находить ее коэффициенты, то вы можете пропустить этап оценки параметров модели и вывести график линейной регрессии средствами ggplot, используя геометрию geom_smooth() с параметром method = lm:\n\nggplot(tabreg, aes(gdp, lifexp)) +\n  geom_point(alpha = 0.5) +\n  geom_smooth(method = 'lm',\n              color = 'red', size = 1) +\n  scale_x_log10() +\n  theme_bw()",
    "crumbs": [
      "Графика и статистика",
      "<span class='chapter-number'>7</span>  <span class='chapter-title'>Основы статистики</span>"
    ]
  },
  {
    "objectID": "07-BaseStats.html#stats_review",
    "href": "07-BaseStats.html#stats_review",
    "title": "7  Основы статистики",
    "section": "7.5 Краткий обзор",
    "text": "7.5 Краткий обзор\nДля просмотра презентации щелкните на ней один раз левой кнопкой мыши и листайте, используя кнопки на клавиатуре:\n\n\n\n\n\nПрезентацию можно открыть в отдельном окне или вкладке браузере. Для этого щелкните по ней правой кнопкой мыши и выберите соответствующую команду.",
    "crumbs": [
      "Графика и статистика",
      "<span class='chapter-number'>7</span>  <span class='chapter-title'>Основы статистики</span>"
    ]
  },
  {
    "objectID": "07-BaseStats.html#questions_tasks_stat_analysis",
    "href": "07-BaseStats.html#questions_tasks_stat_analysis",
    "title": "7  Основы статистики",
    "section": "7.6 Контрольные вопросы и упражнения",
    "text": "7.6 Контрольные вопросы и упражнения\n\n7.6.1 Вопросы\n\nПеречислите названия геометрий ggplot2, отвечающих за построение гистограммы и функции плотности распределения.\nКак работает метод ядерного сглаживания, используемый для аппроксимации функции плотности распределения? Каким критериям должна отвечать ядерная функция?\nКак совместить на одном графике гистограмму распределения и функцию плотности вероятности? Какой показатель должна отображать гистограмма высотой столбиков?\nМожно ли при построении графиков статистического характера определить различные веса для измерений? В какой параметр они должны передаваться? Какому критерию должны отвечать веса?\nС помощью какой геометрии можно построить диаграмму размаха средствами ggplot2? Как следует интерпретировать этот график?\nКак оценить статистическую значимость отличий в средних значениях и дисперсиях двух выборок? Какие тесты можно использовать для этого?\nЧто из себя представляет плотность совместного распределения двух случайных величин? Какая геометрия ggplot2 позволяет аппроксимировать ее и нанести на диаграмму рассеяния?\nС помощью каких геометрий ggplot2 можно сгруппировать элементы диаграммы рассеяния ячейками ортогональной и гексагональной сеток? В каких случаях это оказывается полезно?\nЧто такое коэффициент корреляции Пирсона, и какими ограничениями обладает этот показатель?\nКакая функция позволяет осуществить тест на корреляцию между двумя переменными в R?\nЧто позволяет получить регрессионный анализ?\nКакой вид имеет уравнение регрессии в общем случае?\nКакой вид регрессии используется чаще всего?\nС помощью какого метода находят выборочные коэффициенты регрессии?\nЧто такое формула в R, и для чего она используется?\nКак называется символ ~, и что он означает в формулах?\nКаким образов в формуле можно указать алгебраическое преобразование переменной?\nС помощью какой функции осуществляется оценка параметров линейных регрессионных моделей в R?\nКакие функции позволяют извлечь из модели выборочные коэффициенты регрессии, а также смоделированные (fitted) значения?\nКак на основе полученной модели нанести линию регрессии на график ggplot2? Опишите последовательность действий.\nМожно ли нанести линию регрессии на график ggplot2, не используя явное построение модели? Какую геометрию и с какими параметрами следует использовать для этого?\nЧто такое локальная регрессия (LOESS), и как работает этот метод?\nКакая геометрия, и с какими параметрами используется для построения линии локальной регрессии на графике ggplot2?\nЧто показывает полупрозрачная серая полоса вокруг линии регрессии на графике ggplot2?\n\n\n\n7.6.2 Упражнения\n\nИсследуйте данные 15 проб Ковдорского месторождения по содержанию \\(Fe\\) и \\(P_2O_5\\) в железной руде1. Постройте диаграмму рассеяния между компонентами руды, рассчитайте коэффициент корреляции, постройте и нанесите на график уравнение регрессии.\nПроанализируйте данные по индексу расчлененности TRI для Северо-Западной и Юго-Восточной областей Восточного Саяна. Постройте график плотности распределения, на котором нанесены кривые для обеих областей. Установите, являются ли различия в средних значениях и дисперсиях расчлененности между этими областями статистически значимыми.\n\n\n\nИзучите по данным Gapminder соотношение доли сельскохозяйсвенных земель в общей площади и доле водозабора на сельскохозяйственные нужды за 2002 год. Есть ли какая-то зависимость между этими переменными? Что можно сказать о том, как распределены страны мира по этим двум показателям? Постройте по ним диаграммы размаха, сгруппировав по 4, 6 или 8 регионам Gapminder. Дайте оценку статистической значимости отличий в средних значениях и дисперсии между двумя выбранными вами регионами по доле водозабора на сельскохозяйственные нужды.\n\n\n\n\nСамсонов Т.Е. Визуализация и анализ географических данных на языке R. М.: Географический факультет МГУ, 2023. DOI: 10.5281/zenodo.901911\n\n\n\n\n\n\n\nПрохоров, Ю. С. 2011. “Математическая Статистика.” In Большая Российская Энциклопедия. Том 19, 349–52. Издательство «Большая российская энциклопедия».",
    "crumbs": [
      "Графика и статистика",
      "<span class='chapter-number'>7</span>  <span class='chapter-title'>Основы статистики</span>"
    ]
  },
  {
    "objectID": "08-AdvStats.html#temporal_prerequisites",
    "href": "08-AdvStats.html#temporal_prerequisites",
    "title": "8  Временные ряды",
    "section": "8.1 Предварительные требования",
    "text": "8.1 Предварительные требования\nДля работы по теме текущей лекции вам понадобятся пакеты из tidyverse. Для работы с временными данными мы воспользуемся пакетом lubridate, который входит в tidyverse, но автоматически не подключается в сессию. Мы также воспользуемся пакетом gganimate, который позволяет анимировать графики, построенные с помощью ggplot, и пакетами tsibble, feasts и fable для анализа временных рядов.",
    "crumbs": [
      "Графика и статистика",
      "<span class='chapter-number'>8</span>  <span class='chapter-title'>Временные ряды</span>"
    ]
  },
  {
    "objectID": "08-AdvStats.html#temporal_lubridate",
    "href": "08-AdvStats.html#temporal_lubridate",
    "title": "8  Временные ряды",
    "section": "8.2 Создание и преобразование дат и времени",
    "text": "8.2 Создание и преобразование дат и времени\nНапомним, что текущее время и дату можно получить с помощью системных функций Sys.Date() и Sys.time():\n\n(date = Sys.Date())\n\n[1] \"2023-12-19\"\n\n(time = Sys.time())\n\n[1] \"2023-12-19 09:31:33 MSK\"\n\n\nПолученные объекты имеют типы Date и POSIXct:\n\nclass(date)\n\n[1] \"Date\"\n\nclass(time)\n\n[1] \"POSIXct\" \"POSIXt\" \n\n\nНесмотря на то, что время и даты печатаются на экран в виде человекочитаемых строк, их внутреннее представление выражается в количестве дней (для дат) и секунд (для времени в форммате POSIXct) начиная с некоторой точки отсчета. Такой точкой отсчета по умолчанию является начало эпохи UNIX, соответстующее \\(1\\) января \\(1970\\) года по гринвичскому (UTC) времени. Чтобы убедиться в этом, воспользуемся функцией difftime, доступной в базовом R:\n\nas.integer(date)\n\n[1] 19710\n\ndifftime(date, as.Date('1970-01-01'))\n\nTime difference of 19710 days\n\nas.integer(time)\n\n[1] 1702967493\n\ndifftime(time, as.POSIXct('1970-01-01 00:00:00', tz = 'UTC'), units = 'secs')\n\nTime difference of 1702967494 secs\n\n\nРабота с датами и временем может быть достаточно утомительной при отсутствии специализированных средств. Пакет lubridate значительно облегчает эту работу. Основные функции lubridate включают синтаксический разбор (“парсинг”) дат в разных форматах, извлечение разных компонент даты и времени (секунд, минут, часов, суток, недель, годов), вычисление разностей и периодов, а также множество вспомогательных функций (хелперов), облегачающих преобразование временных данных.\nРассмотрим базовые возможности пакета на нескольких примерах.\nСоздание дат возможно на основе целочисленных и строковых значений:\n\nymd(20150515)\n\n[1] \"2015-05-15\"\n\ndmy('15052015')\n\n[1] \"2015-05-15\"\n\n\nДля создания отметки времени необходимо сформировать строку, которая можети быть интерпретирована должным образом. При необходимости указывается часовой пояс:\n\nymd_hms('2015-05-15 22:15:34') # по умолчанию Гринвичское время\n\n[1] \"2015-05-15 22:15:34 UTC\"\n\nymd_hms('2015-05-15 22:15:34', tz = \"Europe/Moscow\")\n\n[1] \"2015-05-15 22:15:34 MSK\"\n\n\nИзвлечение компоненты даты/времени — одна из самых удобных и востребованных функций lubridate. С помощью этих функций вы можете вытащить из объекта год, месяц, неделю, день, час и секунду:\n\nyear(time)\n\n[1] 2023\n\nmonth(time)\n\n[1] 12\n\nweek(time)\n\n[1] 51\n\nday(time)\n\n[1] 19\n\nhour(time)\n\n[1] 9\n\nsecond(time)\n\n[1] 33.91441\n\n\nОбратите внимание на то, что недели отсчитываются от начала года, а не месяца.\nОтдельно следует отметить функцию yday(), которая позволяет определить номер дня в году:\n\nyday(date)\n\n[1] 353\n\n\nЗамена компонент даты/времени осуществляется с использованием тех же функций. Например, если мы хотим то же число и время, но за другой (заранее известный) год и месяц, мы можем заменить соответствующие компоненты, используя оператор &lt;-:\n\nyear(time) &lt;- 2015\nmonth(time) &lt;- 01\ntime\n\n[1] \"2015-01-19 09:31:33 MSK\"\n\n\nОкругление дат и времени выполняется с помощью функций round_date(), floor_date() и ceiling_date() соответственно. Например, получить первый день в текущем году можно так:\n\nfloor_date(Sys.Date(), unit = 'year')\n\n[1] \"2023-01-01\"\n\n\nПериоды (periods) — это промежутки дат, выраженные в годах, месяцах или днях. Их удобно использовать для того чтобы сместить текущую дату на заданный интервал. Например, к ранее определенной дате можно прибавить 1 год, 4 месяца, 3 недели и 2 дня:\n\ndate\n\n[1] \"2023-12-19\"\n\ndate + years(1) + months(4) + weeks(3) + days(2)\n\n[1] \"2025-05-12\"\n\n\nДлительности (durations) — это промежутки времени, выраженные в секундах. Работают они в целом аналогично периодам:\n\ndweeks(1)\n\n[1] \"604800s (~1 weeks)\"\n\ntime\n\n[1] \"2015-01-19 09:31:33 MSK\"\n\ntime + dweeks(1)\n\n[1] \"2015-01-26 09:31:33 MSK\"\n\ntime + weeks(1)\n\n[1] \"2015-01-26 09:31:33 MSK\"\n\n\nИнтервалы — это отрезки между двумя датами. Интервал можно преобразовывать в периоды и длительности:\n\n(int = lubridate::interval(Sys.time(), time))\n\n[1] 2023-12-19 09:31:34 MSK--2015-01-19 09:31:33 MSK\n\nas.period(int, 'days')\n\n[1] \"-3256d 0H 0M -0.272432088851929S\"\n\nas.duration(int)\n\n[1] \"-281318400.272432s (~-8.91 years)\"",
    "crumbs": [
      "Графика и статистика",
      "<span class='chapter-number'>8</span>  <span class='chapter-title'>Временные ряды</span>"
    ]
  },
  {
    "objectID": "08-AdvStats.html#temporal_complete",
    "href": "08-AdvStats.html#temporal_complete",
    "title": "8  Временные ряды",
    "section": "8.3 Создание временного фрейма данных",
    "text": "8.3 Создание временного фрейма данных\nДанные во временных рядах часто соответствуют равноотстоящим по времени срезам (раз в несколько часов, раз в день, раз в три месяца и т.д.), что обусловлено регулярным характером сбора информации (наблюдения, предоставление отчетности и т.д.). Соответствующее предположение лежит и в основе многих функций временного анализа (таких как автокорреляционная функция). Если в данных отсутствуют некоторые временные срезы, это нарушает регулярность временного ряда, что может привести к его некорректной интерпретации. Необходимо восстановить пропущенные сроки, явным образом указав, что данных на эти сроки нет.\nПомимо этого, дата может быть записана в некорректной форме. Например, оператор ввода данных перепутал месяц и день 18 марта, что привело к созданию несуществующей даты 03.18 в одной из строк.\nПодобные несовершенства временных рядов важно выявить на самых ранних стадиях анализа данных. Рассмотрим, как эту задачу можно решить средствами R. В качестве источника данных будем использовать данные1 об уровне воды на гидропосте Паялка (р. Умба, Мурманская область) с 1932 по 2014 год. Отсутствие информации в файле данных закодировано числом 9999:\n\n(src = read_delim('data/in_Umba.txt', delim = ' ', \n                 col_names = c('day', 'month', 'year', 'level'), na = '9999'))\n\n# A tibble: 30,316 × 4\n     day month  year level\n   &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt;\n 1     1     1  1932  49.4\n 2     2     1  1932  NA  \n 3     3     1  1932  NA  \n 4     4     1  1932  NA  \n 5     5     1  1932  NA  \n 6     6     1  1932  NA  \n 7     7     1  1932  NA  \n 8     8     1  1932  NA  \n 9     9     1  1932  NA  \n10    10     1  1932  47  \n# ℹ 30,306 more rows\n\n\nСформируем даты на основе первых трёх столбцов и проверим, все ли из них корректны. Если компоненты даты некорректны, то функция ymв() вернет NA:\n\ntab = src |&gt;\n    mutate(Date = ymd(paste(year, month, day)))\n\nФункция сообщила, что один временной срез был преобразован некорректно. Можно проверить, какой именно:\n\ntab |&gt; \n  filter(is.na(Date))\n\n# A tibble: 1 × 5\n    day month  year level Date  \n  &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;date&gt;\n1    29     2  1941  27.4 NA    \n\n\nПроверка показала, что преобразование в дату оказалось невозможно только для одной строки. В этой строке оператором была введена несуществующая дата — 29 февраля 1941 года. Этот год не является високосным, а значит количество дней в феврале должно равняться 28.\nВ таблице временного фрейма данных класса tsibble каждый элемент определяется временным индексом и ключом. Ключ обязательным не является. В нашем случае данные ключа не имют, т.к. переменная лишь одного типа — расход. Попробуем создать временную таблицу:\n\ntsbl = as_tsibble(tab, index = Date)\n\nError in `validate_index()`:\n! Column `Date` (index) must not contain `NA`.\n\n\nКак видно, создать класс временного фрейма данных не получилось, потому что есть пропуски дат. Необходимо отбраковать пустые даты:\n\ntsbl = tab |&gt; \n  filter(!is.na(Date)) |&gt; \n  as_tsibble(index = Date)\n\nError in `validate_tsibble()`:\n! A valid tsibble must have distinct rows identified by key and index.\nℹ Please use `duplicates()` to check the duplicated rows.\n\n\nДиагностическая информация говорит о том, что в таблице есть полностью идентичные строки. Можно их найти с помощью duplicates():\n\ntab |&gt; \n  filter(!is.na(Date)) |&gt; \n  duplicates(index = Date)\n\n# A tibble: 2 × 5\n    day month  year level Date      \n  &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;date&gt;    \n1    31    12  1942  25.4 1942-12-31\n2    31    12  1942  42.8 1942-12-31\n\n\nЧто делать с подобными дубликатами дат — решать вам. Если известно, какие данные правильные, а какие ошибочные — можно убрать конкретные строки. Оставим только уникальные даты посредством dplyr::distinct():\n\ntsbl = tab |&gt; \n  filter(!is.na(Date)) |&gt; \n  distinct(Date, .keep_all = T) |&gt; \n  as_tsibble(index = Date)\n\ntsbl\n\n# A tsibble: 30,314 x 5 [1D]\n     day month  year level Date      \n   &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;date&gt;    \n 1     1     1  1932  49.4 1932-01-01\n 2     2     1  1932  NA   1932-01-02\n 3     3     1  1932  NA   1932-01-03\n 4     4     1  1932  NA   1932-01-04\n 5     5     1  1932  NA   1932-01-05\n 6     6     1  1932  NA   1932-01-06\n 7     7     1  1932  NA   1932-01-07\n 8     8     1  1932  NA   1932-01-08\n 9     9     1  1932  NA   1932-01-09\n10    10     1  1932  47   1932-01-10\n# ℹ 30,304 more rows\n\n\nОбъект tsibble создан. Наличие уникальных дат еще не говорит о том, что в датах нет пропусков. Чтобы это выяснить, можно использовать scan_gaps() (индивидуальные пропуски) или count_gaps() (периоды пропусков):\n\nscan_gaps(tsbl)\n\n# A tsibble: 2 x 1 [1D]\n  Date      \n  &lt;date&gt;    \n1 1941-12-31\n2 1942-01-01\n\ncount_gaps(tsbl)\n\n# A tibble: 1 × 3\n  .from      .to           .n\n  &lt;date&gt;     &lt;date&gt;     &lt;int&gt;\n1 1941-12-31 1942-01-01     2\n\n\nХорошим тоном является приведение всех подобных пропусков в явные пропущенные значения таблице. Их можно выполнить посредством fill_gaps():\n\ntsbl = fill_gaps(tsbl)\nscan_gaps(tsbl)\n\n# A tsibble: 0 x 1 [?]\n# ℹ 1 variable: Date &lt;date&gt;\n\n\nНа этом подготовку данных к обработке можно закончить и приступать к анализу и моделированию.",
    "crumbs": [
      "Графика и статистика",
      "<span class='chapter-number'>8</span>  <span class='chapter-title'>Временные ряды</span>"
    ]
  },
  {
    "objectID": "08-AdvStats.html#temporal_interp",
    "href": "08-AdvStats.html#temporal_interp",
    "title": "8  Временные ряды",
    "section": "8.4 Интерполяция по времени",
    "text": "8.4 Интерполяция по времени\nОдна из распространенных задач при работе с временными данными — это интерполяция по времени. Во-первых, интерполяция может использоваться для заполнения пропусков данных. Во-вторых, необходимость в интерполяции возникает когда неравномерно распределенные по времени данные надо перенести на регулярные сроки (скажем, через час), чтобы обеспечить их сравнимость с другими рядами данных. Заметим, что и в том и в другом случае необходимо учитывать автокорреляционные свойства временного ряда и с осторожностью подходить к интерполяции на длительных промежутках времени, поскольку такая интерполяция может не иметь под собой физических оснований.\n\n8.4.1 Заполнение временных пропусков\nРассмотрим заполнение пропусков данных на примере загруженных в предыдущем параграфе данных по уровням воды на гидропосте Паялка. На первом этапе анализа пропусков данных целесообразно получить сводную таблицу, которая бы систематизировала все пропуски и непрерывные ряды данных. Для этого сначала выставим маркер data/gap (данные/пропуск) на против каждой строки в новом поле type, а затем пронумеруем все группы последовательно идущих друг за другом меток совпадающего типа. Для реализации последнего шага выполним следующее:\n\nсформируем группы непрерывно идущих следом друг за другом меток одного типа, используя функцию rle (run-length encoding); полученный объект содержит вектор lengths, количество элементов которого равняется количеству групп, а значение каждого элемента равно количеству объектов соответствующей по порядку группы;\nномер каждой группы (от 1 до количества групп) продублируем столько раз, сколько элементов содержится в каждой группе\n\nПосле этого сгруппируем данные по номеру группы и вычислим дату начала, дату конца, продолжительность и тип каждого периода. Полученная таблица наглядно демонстрирует разбиение временного ряда на периоды наличия и отсутствия данных:\n\nfind_gaps = function(df, variable) {\n  df |&gt; \n    as_tibble() |&gt;\n    mutate(type = if_else(is.na(df[variable]), 'gap', 'data'),\n           num = with(rle(type), rep(seq_along(lengths), lengths))) |&gt; \n    group_by(num) |&gt; \n    summarise(start_date = min(Date),\n              end_date = max(Date),\n              duration = end_date - start_date + 1,\n              type = first(type))\n}\ntimerep = find_gaps(tab, 'level')\n\n\n\n\n\n\n\nПутём интерполяции можно заполнить все пропуски в данном ряду, однако достоверность (правдоподобие) интерполяции будет снижаться при увеличении длины пропуска. Критическую длину пропуска целесообразно связать с пороговым значением автокорреляции — коэффициента корреляции исходного ряда данных и его копии, полученной со сдвигом \\(\\tau\\). Автокорреляцию как правило рассчитываеют не при фиксированном сдвиге, а для серии сдвигов. Полученная функция показывает зависимость автокорреляции от величины сдвига и носит название автокорреляционной функции (АКФ):\n\\[\\Psi(\\tau) = \\int_{-\\infty}^{+\\infty} f(t) f^* (t - \\tau) dt,\\] где \\(^*\\) означает комплексное сопряжение (для вещественнозначных функций эту звездочку можно игнорировать, она нужна в целях обобщения понятия автокорреляции для случайных процессов, сечения которых являются комплексными случайными переменными).\nАвтокорреляционная функция случайного процесса \\(X(t)\\) будет иметь вид:\n\\[K(\\tau) = \\mathbb E \\big[X(t) X^* (t - \\tau) \\big],\\] где \\(\\mathbb E \\big[~ \\big]\\) — математическое ожидание.\nДля нецикличных процессов, плавно изменяющихся во времени, при увеличении \\(\\tau\\) значение АКФ падает, а это означает, что установив минимально допустимое значение автокорреляции, можно выяснить соответствующий ему сдвиг по времени. Найденная величина и будет максимально допустимой при интерполяции длиной пропуска.\nДля вычисления автокорреляционной функции можно воспользоваться встроенной функцией acf(), однако с ней может быть не очень удобно работать, поскольку оне не умеет работать с пропусками в данных, и нужно искать длительный промежуток непрерывных измерений. Вместо этого воспользуемся функцией ACF() из пакета feasts:\n\nacorr = tsbl |&gt; ACF(level)\nacorr\n\n# A tsibble: 41 x 2 [1D]\n        lag   acf\n   &lt;cf_lag&gt; &lt;dbl&gt;\n 1       1D 0.994\n 2       2D 0.982\n 3       3D 0.964\n 4       4D 0.943\n 5       5D 0.919\n 6       6D 0.893\n 7       7D 0.866\n 8       8D 0.839\n 9       9D 0.812\n10      10D 0.786\n# ℹ 31 more rows\n\n\nВизуализировать результаты можно посредством функции autoplot() из того же пакета:\n\nautoplot(acorr)\n\n\n\n\n\n\n\n\nРезультат соответствует нашим ожиданиям: автокорреляционная функция монотонно убывает при увеличении сдвига по времени. Осталось устновить пороговое значение автокорреляции и найти соответствующий ему сдвиг.\nВ гидрологии за допустимую величину автокорреляции при восстановлении рядов данных принято брать значение, равное \\(0.7\\). Найдем индекс первого элемента менее данной величины, используя функцию detect_index() из пакета purrr:\n\n(max_dur = purrr::detect_index(acorr$acf, ~ .x &lt; 0.7))\n\n[1] 14\n\n\nПолученное значение говорит нам о том, что при заданном допуске допустимо интерполировать значения в пропусках данных короче, чем 14 дней.\nИнтерполяцию можно проводить разными способами, но самый правильный при отсутствии связанных переменных — это авторегрессионные модели. Для начала визуализируем участок в окрестности одного из пробелов\n\nautoplot(tsbl, level, size = 1) +\n  scale_x_date(limits = c(ymd(19320101), ymd(19350101)))\n\n\n\n\n\n\n\n\nДля выполнения обычной линейной интерполяции между пропускаи воспользуемся функцией na.approx() из пакета zoo и округлим полученные значения до одного знака после запятой (что соответствует точности исходных данных):\n\n(tsbl_int = tsbl |&gt; \n  mutate(level_interp = zoo::na.approx(level, maxgap = max_dur) |&gt; round(1)))\n\n# A tsibble: 30,316 x 6 [1D]\n     day month  year level Date       level_interp\n   &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;date&gt;            &lt;dbl&gt;\n 1     1     1  1932  49.4 1932-01-01         49.4\n 2     2     1  1932  NA   1932-01-02         49.1\n 3     3     1  1932  NA   1932-01-03         48.9\n 4     4     1  1932  NA   1932-01-04         48.6\n 5     5     1  1932  NA   1932-01-05         48.3\n 6     6     1  1932  NA   1932-01-06         48.1\n 7     7     1  1932  NA   1932-01-07         47.8\n 8     8     1  1932  NA   1932-01-08         47.5\n 9     9     1  1932  NA   1932-01-09         47.3\n10    10     1  1932  47   1932-01-10         47  \n# ℹ 30,306 more rows\n\nautoplot(tsbl_int, level_interp, color = 'red', size = 1) +\n  geom_line(aes(Date, level), tsbl, size = 1) +\n  scale_x_date(limits = c(ymd(19320101), ymd(19350101)))\n\n\n\n\n\n\n\n\nАналогичного результата можно достичь с применением модели ARIMA, которая подыскивает наилучший интерполятор с учетом авторегрессии и сглаживающего среднего:\n\ntsbl_int2 = tsbl |&gt; \n  model(mdl = ARIMA(level ~ 0 + pdq(0,1,0) + PDQ(0,0,0))) |&gt; \n  interpolate(tsbl)\n\nautoplot(tsbl_int2, level, color = 'magenta', size = 1) +\n  geom_line(aes(Date, level), tsbl, size = 1) +\n  scale_x_date(limits = c(ymd(19320101), ymd(19350101)))\n\n\n\n\n\n\n\n\nВ заключение проведем заново оценку ситуации с пропусками в данных. Для этого необходимо привести данные к обычному классу tibble:\n\ntimerep_interp = find_gaps(tsbl_int, 'level_interp')\n\n\n\n\n\n\n\nАналогичная таблица, заполненная методом ARIMA, уже не имеет пропусков, поскольку не установлены временные ограничения на длину интервала интерполяции:\n\ntimerep_interp2 = find_gaps(tsbl_int2, 'level')\n\n\n\n\n\n\n\nПо результатам автокореляционного анализа и интерполяции удалось заполнить значительное число пропусков в данных. Однако по прежнему остаются значительные по длине пропуски, которые уже требуют привлечения дополнительных источников информации для их заполнения.",
    "crumbs": [
      "Графика и статистика",
      "<span class='chapter-number'>8</span>  <span class='chapter-title'>Временные ряды</span>"
    ]
  },
  {
    "objectID": "08-AdvStats.html#temporal_prognosis",
    "href": "08-AdvStats.html#temporal_prognosis",
    "title": "8  Временные ряды",
    "section": "8.5 Интерполяция с учетом предикторов",
    "text": "8.5 Интерполяция с учетом предикторов\nВ некоторых случая интерполяцию можно уточнить с использованием предикторов. Рассмотрим уточнение прогноза уровня воды с учетом информации о температурах и осадках на р. Умба:\n\nmeteo = read_delim('data/in_Umba_meteo.txt', delim = ' ', \n                 col_names = c('day', 'month', 'year', 'temp', 'prec'), na = '9999') |&gt; \n  mutate(Date = ymd(paste(year, month, day)),\n         tempsm = zoo::rollmean(temp, 10, fill = NA, align = 'center'),\n         precsum = zoo::rollsum(prec, 5, fill = NA, align = 'center')) |&gt; \n  select(Date, temp, tempsm, prec, precsum)\n\ntsbl_all = left_join(tsbl_int, meteo, by = 'Date')\ntsbl_all\n\n# A tsibble: 30,316 x 10 [1D]\n     day month  year level Date       level_interp   temp tempsm  prec precsum\n   &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;date&gt;            &lt;dbl&gt;  &lt;dbl&gt;  &lt;dbl&gt; &lt;dbl&gt;   &lt;dbl&gt;\n 1     1     1  1932  49.4 1932-01-01         49.4 -14.9   NA    0.184   NA   \n 2     2     1  1932  NA   1932-01-02         49.1 -15.1   NA    0.578   NA   \n 3     3     1  1932  NA   1932-01-03         48.9 -10.4   NA    0.942    3.97\n 4     4     1  1932  NA   1932-01-04         48.6  -7.58  NA    1.44     4.07\n 5     5     1  1932  NA   1932-01-05         48.3  -8.46 -11.3  0.826    4.42\n 6     6     1  1932  NA   1932-01-06         48.1 -13.0  -10.7  0.288    4.64\n 7     7     1  1932  NA   1932-01-07         47.8 -13.3   -9.72 0.925    3.95\n 8     8     1  1932  NA   1932-01-08         47.5 -10.4   -8.83 1.16     3.79\n 9     9     1  1932  NA   1932-01-09         47.3 -10.4   -8.33 0.75     4.53\n10    10     1  1932  47   1932-01-10         47    -9.16  -7.62 0.662    4.49\n# ℹ 30,306 more rows\n\n\nРасширим временной диапазон рассмотрения\n\nautoplot(tsbl_all, level_interp, size = 1) +\n  scale_x_date(limits = c(ymd(19320101), ymd(19360101)))\n\n\n\n\n\n\n\n\nВидно, что период в начале 1935 года слишком длинный для того чтобы его прогнозировать с использованиме исключительно авторегрессионных свойств и сглаживающего среднего. Попробуем для этого применить связь с осадками и температурой:\n\ntsbl_int_met = tsbl_all |&gt; \n  model(mdl = ARIMA(level_interp ~ tempsm + precsum)) |&gt; \n  interpolate(tsbl_all)\n\nautoplot(tsbl_int_met, level_interp, color = 'green', size = 1) +\n  geom_line(aes(Date, level_interp), tsbl_all, size = 1) +\n  scale_x_date(limits = c(ymd(19320101), ymd(19360101)))\n\n\n\n\n\n\n\n\n\n8.5.1 Пересчет на другую временную сетку\nКогда данные, поступающие из различных источников, привязаны к несовпадающим временным срезам, возникает задача приведения их к единой временной сетке. Как правило, эта сетка имеет регулярный шаг (каждый час, каждый месяц и т.д.), поскольку это упрощает выполнение статистического анализа.\nОдним из источников данных, не привязанных к жесткой временной сетке, является геосенсорная сеть домашних метеостанций NETATMO, которая собирает информацию с пользовательских устройств примерно каждый полчаса. Сроки, однако, четко не соблюдаются. Помимо этого, система, в силу её добровольно-волонтёрского характера, не предусматривает бесперебойное функционирование всех метеостанций: пользователь может отключить свой прибор на несколько часов или дней, в результате чего в данных могут образоваться дополнительные пропуски. Вследствие этого данные NETATMO характеризуются высокой степенью иррегулярности во времени.\nЗагрузим в качестве примера данные по метеостанции с идентификатором 70_ee_50_00_8e_1a, расположенной в пределах Московского мегаполиса (данные выгружены посредством NETATMO Weather API):\n\n(tab = read_csv('data/70_ee_50_00_8e_1a.csv'))\n\n# A tibble: 1,405 × 11\n   altitude humidity id                latitude longitude pressure temperature\n      &lt;dbl&gt;    &lt;dbl&gt; &lt;chr&gt;                &lt;dbl&gt;     &lt;dbl&gt;    &lt;dbl&gt;       &lt;dbl&gt;\n 1      189       55 70:ee:50:00:8e:1a     55.7      37.6    1014.        23.1\n 2      189       56 70:ee:50:00:8e:1a     55.7      37.6    1013.        22.5\n 3      189       57 70:ee:50:00:8e:1a     55.7      37.6    1014.        21.9\n 4      189       59 70:ee:50:00:8e:1a     55.7      37.6    1014.        21.1\n 5      189       62 70:ee:50:00:8e:1a     55.7      37.6    1014         20  \n 6      189       65 70:ee:50:00:8e:1a     55.7      37.6    1014.        19.7\n 7      189       66 70:ee:50:00:8e:1a     55.7      37.6    1014.        19.6\n 8      189       67 70:ee:50:00:8e:1a     55.7      37.6    1014.        19.5\n 9      189       68 70:ee:50:00:8e:1a     55.7      37.6    1014.        19.2\n10      189       68 70:ee:50:00:8e:1a     55.7      37.6    1015.        19.2\n# ℹ 1,395 more rows\n# ℹ 4 more variables: time_humidity &lt;dttm&gt;, time_pressure &lt;dttm&gt;,\n#   time_temperature &lt;dttm&gt;, timezone &lt;chr&gt;\n\n\nВизуальная инспекция данных подсказывает нам, что данные по температуре, влажности и давлению получены на произвольные сроки с дискретностью порядка \\(30\\) или \\(60\\) минут, при этом для всех трех метеопараметров эти сроки не совпадают:\n\n\n\n\n\n\nЧтобы осуществлять совместный анализ этих данных, необходимо привести их к единой временной сетке. Временная плотность данных NETATMO позволяет сделать такую сетку через каждые \\(30\\) минут. Алгоритм интерполяции данных для каждой из характеристик будет следующий:\n\nОпределить минимальное и максимальное время измерений и округлить их до ближайшего времени, кратного \\(30\\) минутам в большую (для минимального времени) и меньшую (для максимального времени) сторону.\nСформировать последовательность временных срезов между полученными границами \\(30\\)-минутной серии.\nИнтерполировать величину показателя на новую сетку.\n\nОпределим расчетные интервалы времени для каждой из характеристик:\n\ntab = tab |&gt; select(id, temperature, time_temperature)\n\ntmin = ceiling_date(min(tab$time_temperature), \n                    unit = '30 minutes')\ntmax = floor_date(max(tab$time_temperature), \n                  unit = '30 minutes')\n\nВ данном случае видно, что возможные границы сроков интерполяции для всех трех переменных совпадают, что несколько облегачает задачу. Проинтерполуруем данные на единую регулярную временную сетку через \\(30\\) минут, используя функцию approx() из базового R. По умолчанию данная функция использует линейную интерполяцию по ближайшим значениям до и после интерполируемого:\n\ntime_interp = tibble(\n  datetime = seq(tmin, tmax, by = '30 min'),\n  temp = round(approx(tab$time_temperature, \n                      tab$temperature, \n                      xout = datetime)$y, 1)\n)\n\nНадежность каждого интерполированного значения можно оценить, задав максимальную продолжительность интерполируемого интервала. Предположим, что она не должна превышать \\(60\\) минут:\n\nidx = sapply(time_interp$datetime, \\(x) match(TRUE, tab$time_temperature &gt;= x))\n\ntime_interp = time_interp |&gt; \n  mutate(before_time = datetime - tab$time_temperature[idx-1],\n         after_time = tab$time_temperature[idx] - datetime,\n         valid = after_time - before_time &lt;= minutes(60))\nsummary(time_interp)\n\n    datetime                        temp       before_time      \n Min.   :2019-09-04 14:30:00   Min.   : 0.60   Length:2049      \n 1st Qu.:2019-09-15 06:30:00   1st Qu.: 8.00   Class :difftime  \n Median :2019-09-25 22:30:00   Median :11.00   Mode  :numeric   \n Mean   :2019-09-25 22:30:00   Mean   :11.63                    \n 3rd Qu.:2019-10-06 14:30:00   3rd Qu.:15.20                    \n Max.   :2019-10-17 06:30:00   Max.   :24.90                    \n  after_time         valid        \n Length:2049       Mode :logical  \n Class :difftime   FALSE:280      \n Mode  :numeric    TRUE :1769     \n                                  \n                                  \n                                  \n\ncat('Valid are ', round(100 * sum(time_interp$valid) / nrow(time_interp), 1), \n    '% of interpolated values', sep = '')\n\nValid are 86.3% of interpolated values\n\n\n\n\n8.5.2 Прогнозирование по времени\nРассмотрим задачу прогнозирования количества потребляемой электроэнергии в штате Виктория (Австралия) в зависимости от температуры воздуха. Существует корреляция между этими переменными.\n\ndata(vic_elec, package = 'tsibbledata')\n\nvic_elec_daily = vic_elec |&gt; \n  filter(year(Time) == 2014) |&gt; \n  index_by(Date = date(Time)) |&gt; \n  summarise(\n    Demand = sum(Demand) / 1e3,\n    Temperature = max(Temperature),\n    Holiday = any(Holiday)\n  ) |&gt; \n  mutate(Day_Type = case_when(\n    Holiday ~ \"Holiday\",\n    wday(Date) %in% 2:6 ~ \"Weekday\",\n    TRUE ~ \"Weekend\"\n  ))\n\nvic_elec_daily |&gt; \n  pivot_longer(c(Demand, Temperature)) |&gt; \n    ggplot(aes(x = Date, y = value)) +\n    geom_line() +\n    facet_grid(name ~ ., scales = \"free_y\") + ylab(\"\")\n\n\n\n\n\n\n\n\nВыполним построение модели:\n\nfit = vic_elec_daily |&gt; \n  model(ARIMA(Demand ~ Temperature + I(Temperature^2) +\n                (Day_Type == \"Weekday\")))\n\nИ прогнозирование:\n\nvic_elec_future = new_data(vic_elec_daily, 14) |&gt; \n  mutate(\n    Temperature = 26,\n    Holiday = c(TRUE, rep(FALSE, 13)),\n    Day_Type = case_when(\n      Holiday ~ \"Holiday\",\n      wday(Date) %in% 2:6 ~ \"Weekday\",\n      TRUE ~ \"Weekend\"\n    )\n  )\n\nforecast(fit, vic_elec_future) |&gt; \n  autoplot(vic_elec_daily) +\n  labs(title=\"Daily electricity demand: Victoria\",\n       y=\"GW\")",
    "crumbs": [
      "Графика и статистика",
      "<span class='chapter-number'>8</span>  <span class='chapter-title'>Временные ряды</span>"
    ]
  },
  {
    "objectID": "08-AdvStats.html#temporal_loess",
    "href": "08-AdvStats.html#temporal_loess",
    "title": "8  Временные ряды",
    "section": "8.6 Аппроксимация по времени",
    "text": "8.6 Аппроксимация по времени\nОдной из важных составляющих работы с временными данными является анализ временных трендов и закономерностей. В качестве примера возьмем данные межгодичных изменений характеристик стока реки Мезень на посту Малонисогорская2:\n\n(tab = read_csv('data/Mezen.csv'))\n\n# A tibble: 75 × 57\n   year_number Year1 Year2 datestart  datepolend    Qy  Qmax datemax     Qygr\n         &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;date&gt;     &lt;date&gt;     &lt;dbl&gt; &lt;dbl&gt; &lt;date&gt;     &lt;dbl&gt;\n 1           1  1938  1939 2000-03-23 2000-06-08  98.1   747 2000-04-03  19.9\n 2           2  1939  1940 2000-03-16 2000-07-11  66.9   487 2000-04-28  14.8\n 3           3  1940  1941 2000-03-09 2000-07-12  97.4   995 2000-04-28  18.9\n 4           4  1941  1942 2000-03-24 2000-07-21 214.   2030 2000-05-01  31.4\n 5           5  1942  1943 2000-04-02 2000-07-31 242.   2790 2000-05-08  26.9\n 6           6  1943  1944 2000-03-24 2000-06-15  71.3   451 2000-05-02  26.5\n 7           7  1944  1945 2000-02-26 2000-06-30  89.0   530 2000-04-28  27.0\n 8           8  1945  1946 2000-03-25 2000-07-13 128.   1220 2000-04-27  33.9\n 9           9  1946  1947 2000-03-15 2000-06-30 179.   2150 2000-04-28  25.8\n10          10  1947  1948 2000-03-06 2000-07-15 153.   1720 2000-04-16  31.3\n# ℹ 65 more rows\n# ℹ 48 more variables: Qmmsummer &lt;dbl&gt;, monmmsummer &lt;date&gt;, Qmmwin &lt;dbl&gt;,\n#   nommwin &lt;date&gt;, Q30s &lt;dbl&gt;, date30s1 &lt;date&gt;, date30s2 &lt;date&gt;, Q30w &lt;dbl&gt;,\n#   date30w1 &lt;date&gt;, date30w2 &lt;date&gt;, Q10s &lt;dbl&gt;, date10s1 &lt;date&gt;,\n#   date10s2 &lt;date&gt;, Q10w &lt;dbl&gt;, date10w1 &lt;date&gt;, date10w2 &lt;date&gt;, Q5s &lt;dbl&gt;,\n#   date5s1 &lt;date&gt;, date5s2 &lt;date&gt;, Q5w &lt;dbl&gt;, date5w1 &lt;date&gt;, date5w2 &lt;date&gt;,\n#   Wy &lt;dbl&gt;, Wgr &lt;dbl&gt;, Wpol1 &lt;dbl&gt;, Wpol2 &lt;dbl&gt;, Wpol3 &lt;dbl&gt;, Wpavs1 &lt;dbl&gt;, …\n\n\nПостроим график межгодичной изменчивости объема грунтового стока (переменная Wgr в \\(км^3\\)). Для того чтобы нанести линию глобального тренда, добавим грамматику geom_smooth(method = 'lm'):\n\nggplot(tab, mapping = aes(Year1, Wgr)) +\n  geom_line() +\n  geom_area(alpha = 0.5) +\n  geom_smooth(method = 'lm') +\n  labs(title = 'Объем грунтового стока на р. Мезень в д. Малонисогорская',\n       x = 'Год',\n       y = 'куб. км')\n\n\n\n\n\n\n\n\nКак видно из данного графика, в масштабах десятилетий грунтовый сток имеет очевидный тренд на увеличение. В то же время, наблюдаяются колебания более короткого временного масштаба: серии годов повышенного стока сменяются годами более низкого стока. Чтобы графически выявить эти колебания, можно аппроксимировать исходный ряд данных с помощью кривой локальной регрессии. Для этого добавим грамматику geom_smooth() без параметров (это равносильно также вызову geom_smooth(method = 'loess')):\n\nggplot(tab, mapping = aes(Year1, Wgr)) +\n  geom_line() +\n  geom_area(alpha = 0.5) +\n  geom_smooth(method = 'lm') +\n  geom_smooth(color = 'orangered', span = 0.2) +\n  labs(title = 'Объем грунтового стока на р. Мезень в д. Малонисогорская',\n       x = 'Год',\n       y = 'куб. км')\n\n\n\n\n\n\n\n\nМетод локальной регрессии изначально был разработан для построения кривых регрессии в случае когда зависимость между переменными ведет себя сложным образом и не может быть описана в терминах традиционной линейной и нелинейной регрессии — глобальных методов. В этом случае область значений независимой переменной \\(X\\) можно покрыть конечным числом отрезков, для каждого из которых далее находят регрессию традиционным методом — как правило, линейную или квадратичную. Данный метод получил название LOWESS (Locally weighted scatterplot smoothing). В дальнейшем эта аббревиатура была редуцирована до LOESS.\nВ классической постановке метод LOESS реализуется следующим образом (Cleveland 1979). Пусть дано \\(n\\) точек исходных данных с координатами \\(x\\) (независимая переменная) и \\(y\\) (зависимая). Задается число \\(0 &lt; \\alpha \\leq 1\\), которое обозначает долю от общего количества точек \\(n\\), выбираемую в окрестности каждой точки для построения регрессии. В абсолютном исчислении количество ближайших точек будет равно \\(r = [\\alpha n]\\), где \\([\\cdot]\\) — округление до ближайшего целого.\nТогда вес, который будет иметь каждая \\(k\\)-я точка исходных данных в уравнении регрессии для \\(i\\)-й точки исходных данных будет определяться по формуле:\n\\[w_k (x_i) = W\\big((x_k - x_i)h_i^{-1}\\big),\\]\nгде \\(h_i\\) — расстояние до \\(r\\)-го по близости соседа точки \\(x_i\\), а \\(W\\) — весовая функция, отвечающая следующим условиям:\n\n\\(W(x) &gt; 0\\) если \\(|x| &lt; 1\\);\n\\(W(-x) = W(x)\\);\n\\(W(x)\\) невозрастающая функция для \\(x \\geq 0\\);\n\\(W(x) = 0\\) если \\(|x| \\geq 1\\).\n\nОдним из стандартных вариантов весовой функции является “трикубическая” функция, определяемая как:\n\\[\nW(x) = \\begin{cases}\n(1 - |x|^3)^3, & \\text{если } |x| &lt; 1, \\\\\n0, & \\text{если } |x| \\geq 1.\n\\end{cases}\n\\]\nСогласно определению весовой функции более близкие к \\(x_i\\) точки оказывают большее влияние на коэффициенты регрессии. Помимо этого за пределами расстояния \\(h_i\\) веса всех точек исходных данных будут обнуляться.\nСглаженная оценка \\(\\hat{y}_i\\) в точке \\(x_i\\) получается в виде полинома степени \\(d\\):\n\\[\\hat{y}_i = \\sum_{j=0}^d \\hat{\\beta}_j (x_i) x_i^j,\\] где коэффициенты \\(\\hat{\\beta}_j\\) находятся методом наименьших квадратов путем минимизации ошибки:\n\\[\\sum_{k=1}^n w_k (x_i) (y_k - \\beta_0 - \\beta_1 x_k - ... - \\beta_d x_k^d)^2\\] Процедура поиска коэффициентов регрессии повторяется для каждой из \\(n\\) точек.\nВ методе LOESS используются степени регрессии \\(d = 0, 1, 2\\). Кубические и более высокие степени полиномов на практике не применяются. При степени равной 0 метод носит название сглаживающего среднего. Для построения линии локальной регрессии используйте функцию geom_smooth() без параметра method или с явным указанием параметра method = 'loess':\n\nggplot(data, aes(t, y)) +\n  geom_point() +\n  geom_smooth() \n\nПри визуализации линии локальной регрессии ggplot автоматически добавляет доверительные интервалы, показывающие диапазон нахождения искомой регрессионной кривой с вероятностью 0,95. Вы можете регулировать поведение локальной регрессии, задавая параметры n (количество ближайших точек \\(r\\)), span (доля ближайших точек \\(\\alpha\\)) и formula (формула аппроксимируемой зависимости). По умолчанию используется регрессия первой степени (formula = y ~ x), значения n = 80 и span = 0.75. Вы можете их изменить, например задать более компактный охват для поиска коэффициентов. В этом случае кривая будет более чувствительна к локальному разбросу элементов выборкию. Нанесем несколько кривых локальной регрессии, используя разный охват данных:\n\nggplot(tab, mapping = aes(Year1, Wgr)) +\n  geom_line() +\n  geom_area(alpha = 0.5) +\n  geom_smooth(color = 'yellow', span = 0.1) +\n  geom_smooth(color = 'orangered', span = 0.2) +\n  geom_smooth(color = 'darkred', span = 0.4) +\n  labs(title = 'Объем грунтового стока на р. Мезень в д. Малонисогорская',\n       x = 'Год',\n       y = 'куб. км')\n\n\n\n\n\n\n\n\nВидно, что при увеличении охвата локальная регрессия начинает отрадать колебания более крупного временного масштаба, но при этом хуже отражает реальный разброс значений, что приблажает ее к глобальной регрессии.\nВместо координат исходных точек для построения регрессии можно использовать и произвольные координаты \\(X\\). В этом случае кривая будет соединять точки, полученные локальной регрессионной оценкой в заданных координатах \\(X\\). Именно этот принцип используется в двумерном (и многомерном) случае. Пусть даны измерения показателя в \\(N\\) исходных точках и задано число \\(\\alpha\\) — сглаживающий параметр. Тогда аппроксимация показателя в каждом узле интерполяции получается путем построения поверхности тренда (см. выше) по \\(\\alpha N\\) ближайшим исходным точкам. Как и в одномерном случае, близкие точки будут оказывать более сильное влияние на коэффициенты регрессии, чем удаленные.\nМетод LOESS предоставляет широкие возможности настройки благодаря вариативности параметра сглаживания и степени регрессионного полинома.",
    "crumbs": [
      "Графика и статистика",
      "<span class='chapter-number'>8</span>  <span class='chapter-title'>Временные ряды</span>"
    ]
  },
  {
    "objectID": "08-AdvStats.html#temporal_tests",
    "href": "08-AdvStats.html#temporal_tests",
    "title": "8  Временные ряды",
    "section": "8.7 Статистики",
    "text": "8.7 Статистики\nСуществует ряд статистик и статистических тестов, которые часто используются для временных данных. Среди них мы рассмотрим следующие:\n\nТест Манна-Кендалла на значимость линейного тренда\nТест Петтитт на точку перелома — Оценка тренда по методу Тейла-Сена\n\nДля выполнения тестов Манна-Кендалла, Петтитт и оценки тренда по методу Тейла-Сена для объема грунтового стока Мезеня подключим пакет trend:\n\n(mk = mk.test(tab$Wgr))\n\n\n    Mann-Kendall trend test\n\ndata:  tab$Wgr\nz = 7.8129, n = 75, p-value = 5.589e-15\nalternative hypothesis: true S is not equal to 0\nsample estimates:\n           S         varS          tau \n1.709000e+03 4.779167e+04 6.158559e-01 \n\n(pt = pettitt.test(tab$Wgr))\n\n\n    Pettitt's test for single change-point detection\n\ndata:  tab$Wgr\nU* = 1324, p-value = 4.131e-11\nalternative hypothesis: two.sided\nsample estimates:\nprobable change point at time K \n                             38 \n\n(ts = sens.slope(tab$Wgr))\n\n\n    Sen's slope\n\ndata:  tab$Wgr\nz = 7.8129, n = 75, p-value = 5.589e-15\nalternative hypothesis: true z is not equal to 0\n95 percent confidence interval:\n 0.01378903 0.02202750\nsample estimates:\nSen's slope \n 0.01810404 \n\n\nВсе три теста в данном случе дают высокую статистическую значимость временных изменений (p-значения), при этом тест Петтитт говорит, что точка перелома находится в 38-й позиции ряда. Если разделить исследуемый временной ряд на две выборки этой точкой, то они будут иметь статистически значимое отличие в характеристиках среднего значения показателя. Метод Тейла-Сена также говорит нам, что грунтовый сток увеличивается ежегодно примерно на \\(1.8\\%\\) (величина тренда равна \\(0.0181\\)), что за период 70 лет даёт абсолютный прирост грунтового стока более чем в 2 раза.\nДля наглядности нанесем полученную точку перелома на график:\n\nggplot(tab, mapping = aes(Year1, Wgr)) +\n  geom_line() +\n  geom_area(alpha = 0.5) +\n  geom_smooth(method = 'lm', color = 'red') +\n  geom_vline(xintercept = tab$Year1[pt$estimate], color = \"red\", size = 0.5) +\n  annotate(\"text\", label = tab$Year1[pt$estimate], \n           x = tab$Year1[pt$estimate] + 4, y = max(tab$Wgr), \n           size = 4, colour = \"red\") +\n  labs(title = 'Объем грунтового стока на р. Мезень в д. Малонисогорская',\n     x = 'Год',\n     y = 'куб. км')",
    "crumbs": [
      "Графика и статистика",
      "<span class='chapter-number'>8</span>  <span class='chapter-title'>Временные ряды</span>"
    ]
  },
  {
    "objectID": "08-AdvStats.html#temporal_animation",
    "href": "08-AdvStats.html#temporal_animation",
    "title": "8  Временные ряды",
    "section": "8.8 Анимация",
    "text": "8.8 Анимация\nАнимационная графика возволяет наглядно визуализировать изменения. Наиболее часто речь идет об изменениях по времени. В этом случае время работает в роли невидимой переменной, которая влияет на положение графических примитивов на изображении. Данный подход органично вписывается в концепцию грамматики графики, на основе которой построен пакет ggplot2 (см. Главу @ref(advgraphics)). Соответствующую реализацию грамматики анимаций предоставляет пакет gganimate(R-gganimate?).\nВозможности анимаций в gganimate реализуются посредством добавления новых грамматик к построенному графику ggplot2. К числу этих грамматик относятся:\n\ntransition_*() — распределение данных по времени;\nview_*() — поведение осей координат во времени;\nshadow_*() — отображение данных, не относящихся к текущему временному срезу;\nenter_*()/exit_*() — характер появления/исчезновения данных в процессе анимации;\nease_aes() — порядок смягчения (интерполяции) графических переменных в моменты перехода.\n\nВ качестве первого примера используем уже знакомые нам данные реанализа NASA POWER суточного осреднения, выгрузив информацию по точкам в трех городах (Мурманск, Москва, Краснодар) за 2018 год:\n\n# TODO: set eval = TRUE after NASA POWER server is available\ncities = list(\n  Мурманск = c(33, 69),\n  Москва = c(38, 56),\n  Краснодар = c(39, 45)\n)\n\ntab = purrr::imap(cities, function(coords, city){\n  get_power(\n    community = \"AG\",\n    lonlat = coords,\n    pars = c(\"RH2M\", \"T2M\", \"PRECTOT\"),\n    dates = c(\"2018-01-01\", \"2018-12-31\"),\n    temporal_average = \"DAILY\"\n  ) |&gt; mutate(CITY = city,\n               MONTH = month(YYYYMMDD))\n}) |&gt; bind_rows()\n\n\n8.8.1 Переход по времени\nРассмотрим колебания температуры по 12 месяцам посредством диаграммы размаха, реализовав анимационный переход по времени посредством функции transition_time(). Текущий временной срез передается в переменную окружения frame_time, которая подается в подзаголовок графика (см параметр subtitle функции labs()):\n\nggplot(tab, aes(CITY, T2M)) +\n  geom_boxplot() +\n  labs(title = \"Температура воздуха в 2018 году по данным NASA POWER\",\n       subtitle = 'Месяц: {round(frame_time)}') +\n  xlab('Город') +\n  ylab('Т, °С') +\n  transition_time(MONTH)\n\n\n\n\n\n\n\n\n\n\n\nТекущий срез при выполнении анимации по времени доступен в переменной окружения frame_time.\n\nАналогичную анимацию можно провести и на примере функции плотности распределения:\n\nggplot(tab, aes(T2M, fill = CITY)) +\n  geom_density(alpha = 0.5) +\n  labs(title = \"Температура воздуха в 2018 году по данным NASA POWER\",\n       subtitle = 'Месяц: {round(frame_time)}',\n       fill = 'Город') +\n  xlab('Т, °С') +\n  ylab('Плотность распределения') +\n  transition_time(MONTH)\n\n\n\n\n\n\n\n\n\n\nЗагрузим ранее использованные в Главе @ref(stat_analysis) данные Gapminder по соотношению продолжительности жизни и ВВП на душу населения, но на этот раз не будем фильтровать их по времени:\n\ncountries = read_excel('data/gapminder.xlsx', 2) |&gt;\n  select(Country = name, Region = eight_regions) |&gt;\n  mutate(Country = factor(Country, levels = Country[order(.$Region)]))\n\ngdpdf_tidy = read_sheet('1cxtzRRN6ldjSGoDzFHkB8vqPavq1iOTMElGewQnmHgg') |&gt; ### ВВП на душу населения\n  pivot_longer(cols = `1764`:`2018`, names_to = 'year', values_to = 'gdp') |&gt; \n  rename(Country = 1)\n\npopdf_tidy = read_sheet()'1IbDM8z5XicMIXgr93FPwjgwoTTKMuyLfzU6cQrGZzH8') |&gt; # численность населения\n  pivot_longer(cols = `1800`:`2015`, names_to = 'year', values_to = 'pop') |&gt; \n  rename(Country = 1)\n\nlifedf_tidy = read_sheet('1H3nzTwbn8z4lJ5gJ_WfDgCeGEXK3PVGcNjQ_U5og8eo') |&gt; # продолжительность жизни\n  pivot_longer(cols = `1800`:`2016`, names_to = 'year', values_to = 'lifexp') |&gt; \n  rename(Country = 1)\n\ntab = gdpdf_tidy |&gt; \n  inner_join(lifedf_tidy) |&gt; \n  inner_join(popdf_tidy) |&gt; \n  inner_join(countries) |&gt; \n  mutate(year = as.integer(year)) |&gt; \n  drop_na()\n\nТеперь чтобы отобразить это соотношение в виде анимации, достаточно добавить новый переход по времени:\n\noptions(scipen = 999) # убираем экспоненциальную форму записи числа\nggplot(tab, aes(gdp, lifexp, size = pop, color = Region)) +\n  geom_point(alpha = 0.5) +\n  scale_x_log10() +\n  labs(title = 'Year: {round(frame_time)}') +\n  theme_bw() +\n  transition_time(year)\n\n\n\n\n\n\n\n\n\n\n\n\n8.8.2 Переход по состояниям\nВ ряде случаев вместо перехода по времени целесообразно использовать переход по состояниям. В частности, такой подход оказывается удобен, когда сопоставляются данные за аналогичные временные срезы разных периодов. Например, 12 часов каждого дня недели с анимацией по неделям. Либо каждый день года с анимацией по годам. В этом случае координаты X будут фиксированы, а значение Y будет зависить от текущего состояния.\nПодобную стратегию можно использовать для визуализации изменений внутригодичного распределения величины между годами. Примером таких изменений являются данные о расходах воды на гидропосте Паялка, рассмотренные нами ранее в настоящей главе. В качестве результата мы хотим видеть анимацию гидрографа реки, в которой каждый кадр соответствует календарному году.\nДля составления такой анимации необходимо сначала убедиться, что в данных все года заполнены корректно (не пусты), и что нет годов, за которые вообще нет данных (такие года придется из анимации исключить, так как для них гидрограф построить невозможно). Помимо этого, чтобы обеспечить сопоставимость аналогичных дат за разные года, необходимо сохранить у них только месяц и день. Поскольку такого формата даты не существует, в качестве “трюка” можно просто заменить года всех дат на \\(2000\\) и записать результат в новое поле. Необходимые преобразования реализуются следующим образом:\n\nflt_tab = tsbl_int |&gt; \n  filter(!is.na(year)) |&gt; \n  group_by(year) |&gt;\n  filter(!all(is.na(level_interp))) |&gt; \n  ungroup() |&gt; \n  mutate(yDate = Date)\n\nyear(flt_tab$yDate) &lt;- 2000 # фиктивное поле, в котором аналогичные даты за разные года совпадают\n\nПосле выполнения необходимой подготовки таблица данных готова для анимации. Переход по состояниям реализуется посредством вызова функции transition_states(), при этом параметр state_length = 0 обеспечивает плавность анимации за счет нулевой задержки в каждом состоянии. Полученный график предварительно сохраняется в промежуточную переменную anim, чтобы в дальнейшем можно было управлять качеством анимации путем вызова функции animate(). В частности, мы устанавливаем общее число кадров в \\(10\\) раз больше количества состояний (годов), чтобы обеспечить плавный переход между ними посредством интерполяции (tweening), автоматически выполняемой функцией animate() между кадрами:\n\nanim = ggplot(flt_tab, mapping = aes(x = yDate, y = level_interp)) +\n    geom_ribbon(aes(ymin = 0, ymax = level_interp), alpha = 0.5) +\n    geom_line() +\n    scale_x_date(date_breaks = \"1 month\", date_labels = \"%b\") +\n    labs(title = \"Расход воды на гидропосту Паялка (р. Умба, Мурманская обл.)\",\n         subtitle = 'Год: {closest_state}') +\n    xlab('Дата') +\n    ylab('куб.м/с') +\n    theme(text = element_text(size = 18, family = 'Open Sans')) +\n    transition_states(year, state_length = 0) +\n    view_follow(fixed_y = TRUE)\n\nanimate(anim, \n        fps = 20,                                    # число кадров в секунду\n        nframes = 10 * length(unique(flt_tab$year)), # общее число кадров\n        width = 800, \n        height = 600)\n\n\n\n\n\n\n\n\n\n\n\nТекущий срез при выполнении анимации по состояниям доступен в переменной окружения closest_state.\n\nВ настоящей главе мы рассмотрели лишь базовые возможности создания анимаций средствами пакета gganimate. Более подробно с другими возможностями пакета можно ознакомиться в справочнике по его функциям.",
    "crumbs": [
      "Графика и статистика",
      "<span class='chapter-number'>8</span>  <span class='chapter-title'>Временные ряды</span>"
    ]
  },
  {
    "objectID": "08-AdvStats.html#temporal_review",
    "href": "08-AdvStats.html#temporal_review",
    "title": "8  Временные ряды",
    "section": "8.9 Краткий обзор",
    "text": "8.9 Краткий обзор\nДля просмотра презентации щелкните на ней один раз левой кнопкой мыши и листайте, используя кнопки на клавиатуре:\n\n\n\n\n\nПрезентацию можно открыть в отдельном окне или вкладке браузере. Для этого щелкните по ней правой кнопкой мыши и выберите соответствующую команду.",
    "crumbs": [
      "Графика и статистика",
      "<span class='chapter-number'>8</span>  <span class='chapter-title'>Временные ряды</span>"
    ]
  },
  {
    "objectID": "08-AdvStats.html#questions_tasks_temporal",
    "href": "08-AdvStats.html#questions_tasks_temporal",
    "title": "8  Временные ряды",
    "section": "8.10 Контрольные вопросы и упражнения",
    "text": "8.10 Контрольные вопросы и упражнения\n\n8.10.1 Вопросы\n\nНазовите типы данных, использующиеся для представления дат и времени в R.\nКакая дата является началом эпохи UNIX, используемой в качестве нулевой точки отсчета времени?\nКакая функция может быть использована для расчета разности дат и времени?\nВ чем разница между функциями day() и yday() в пакете lubridate?\nЧем отличаются периоды и длительности в lubridate?\nЕсли вам нужно прибавить к дате требуемое количество лет, месяцев, недель или дней, то какими функциями вы бы воспользовались?\nЧто из себя представляет автокорреляционная функция и каким образом она вычисляется в R?\nЧто из себя представляет кусочно-линейная функция и каким образом она вычисляется в R?\nКакая функция пакета zoo позволяет заполнять отсутствующие значения линейной интерполяцией?\nВ чем суть метода локальной регрессии? Как его можно использовать при исследовании временных рядов?\nКакие параметры geom_smooth() можно использовать чтобы управлять тем, насколько локальной будет регрессия?\nНазовите статистические тесты, которые позволяют оценить величину линейного тренда и его значимость.\nНазовите статистический тест, который позволяет определить номер члена временного ряда, который разбивает выборку на 2 максимально различающиеся по своим моментами подвыборки?\nКакие функции пакета gganimate позволяют осуществлять переходы по времени и состояниям?\nКак можно созданную анимацию экспортировать в файл? Какую функцию необходимо вызвать и какие ее пераметры определить для этого?\n\n\n\n8.10.2 Упражнения\n\nЗагрузите файл с данными по межгодичным изменениям стока на реке Мезень (пост Малонисогорская). Проанализируйте величину и значимость тренда, а также наличие переломного года для характеристик Wpol2 (объем половодья без грунтовой составляющей), а также Wy (суммарный сток). Постройте графики этих характеристик с кривой локальной регрессии. Что можно сказать об их соотношении с грунтовым стоком?\nЗагрузите файл с данными по суточным расходам на реке Протва (пост Спас-Загорье) и проанализируйте полноту временного ряда. Выполните заполнение пропусков дат и расходов, если это требуется.\nЗагрузите из сервиса NASA POWER данные по температурам в любой указанной точке с месячной (monthly) дискретностью за последние 50 лет. Используя модель ARIMA, постройте прогноз на последующие 10 лет.\nПовторите эксперимент с построением анимационных графиков функции плотности распределения температуры и диаграмм размаха по данным NASA POWER, но выбрав координаты трех других географических локаций.\n\n\n\n\nСамсонов Т.Е. Визуализация и анализ географических данных на языке R. М.: Географический факультет МГУ, 2023. DOI: 10.5281/zenodo.901911\n\n\n\n\n\n\n\nCleveland, William S. 1979. “Robust Locally Weighted Regression and Smoothing Scatterplots.” Journal of the American Statistical Association 74 (368): 829. https://doi.org/10.2307/2286407.",
    "crumbs": [
      "Графика и статистика",
      "<span class='chapter-number'>8</span>  <span class='chapter-title'>Временные ряды</span>"
    ]
  },
  {
    "objectID": "09-SpatialData.html#spatial_prerequisites",
    "href": "09-SpatialData.html#spatial_prerequisites",
    "title": "9  Пространственные данные",
    "section": "9.1 Предварительные требования",
    "text": "9.1 Предварительные требования\nДанный модуль посвящен введению в работу с пространственными данными в R. Рассмотрены общие вопросы моделирования реального мира средствами моделей пространственных данных. Рассматривается чтение векторных и растровых данных, их визуализация стандартными средствами.\nНеобходимые для работы пакеты:\n\nlibrary(sf)\nlibrary(stars)\nlibrary(mapview)\nlibrary(dplyr)\nlibrary(readr)",
    "crumbs": [
      "Пространственные данные и карты",
      "<span class='chapter-number'>9</span>  <span class='chapter-title'>Пространственные данные</span>"
    ]
  },
  {
    "objectID": "09-SpatialData.html#spatial_models",
    "href": "09-SpatialData.html#spatial_models",
    "title": "9  Пространственные данные",
    "section": "9.2 Модели пространственных данных",
    "text": "9.2 Модели пространственных данных\nПространственные данные (spatial data) — это данные о пространственных объектах и их наборах. В свою очередь, пространственный объект определяется как цифровая модель материального или абстрактного объекта реального или виртуального мира с указанием его идентификатора, координатных и атрибутивных данных 1.\nЕсли говорить по сути, то пространственные данные можно определить как данные о географических объектах или явлениях, фиксирующие их местоположение и/или распределение в системе координат, привязанной к телу Земли или любого другого небесного тела. Таким образом, отличительной особенностью пространственных данных перед непространственными является координатное описание местоположения. На профессиональном жаргоне пространственные данные также часто называют геоданными. Следует помнить, что этот термин не является научным, и его не следует использовать в публикациях и квалификационных работах.\nВажно знать отличия между векторной и растровой моделью пространственных данных.\nВекторная модель пространственных данных включает описание координатных данных пространственных объектов и, опционально, топологических отношений между ними. Векторные данные фиксируют местоположение и форму объектов в виде геометрических примитивов, таких как точки, линии, полигоны, объемные тела. Выбор модели объекта (например, представить город точкой или полигоном) зависит от масштаба анализа и целей исследования. Векторная модель данных является объектно-ориентированной.\nРастровая модель описывает не объекты, а пространственное распределение некоторой (выбранной исследователем) характеристики. Пространство разбивается регулярной сеткой ячеек, в каждой ячейке фиксируется значение исследуемого параметра (путем статистического осреднения, семплирования в центре ячейки и т.п.). Растровые данные могут быть как количественными (например, поле температуры), так и качественными (например, растр классифицированного снимка, каждая ячейка которого фиксирует принадлежность к тому или иному типу объекта). Таким образом, растровая модель является пространственно-ориентированной (или феномен-ориентированной).\nСуществуют и другие модели пространственных данных, однако их рассмотрение выходит за рамки настоящей лекции.\nВ настоящей лекции мы познакомимся с чтением и визуализацией пространственных данных в векторном и растровом формате, а также рассмотрим вопросы связанные с использованием картографических проекций.",
    "crumbs": [
      "Пространственные данные и карты",
      "<span class='chapter-number'>9</span>  <span class='chapter-title'>Пространственные данные</span>"
    ]
  },
  {
    "objectID": "09-SpatialData.html#vector_data_r",
    "href": "09-SpatialData.html#vector_data_r",
    "title": "9  Пространственные данные",
    "section": "9.3 Векторные данные",
    "text": "9.3 Векторные данные\n\n9.3.1 Simple Features\nSimple Features (официально Simple Features Access) — это стандарт OGC 06-103, разработанный Open Geospatial Consortium (OGC) и реализованный также в виде международного стандарта ISO 19125, который определяет общую модель хранения и доступа к векторным объектам (точка, линия, многоугольник, мульти точечные, мультилинии и т. д.), в географических информационных системах.\nГеометрическое представление пространственных объектов базируется на следующих принципах:\n\nВсе геометрии состоят из точек.\nТочки являются координатами в 2-, 3- или 4-мерном пространстве.\nВсе точки в геометрии имеют одинаковую размерность.\n\nВ дополнение к координатам \\(X\\) и \\(Y\\) имеются два дополнительных дополнительных параметра:\n\nкоордината \\(Z\\), обозначающая высоту\nкоордината \\(M\\), обозначающая некоторую меру, связанную с точкой, а не с признаком в целом (в этом случае это будет атрибут объекта). Измерение \\(M\\) может быть использовано, например, для представления времени или линейных координат (для маршрутов).\n\nКоординаты простой геометрии всегда содержат компоненты \\(X\\) и \\(Y\\), поэтому все разнообразие возможных представлений определяется наличием или отсутствием дополнительных измерений \\(Z\\) и \\(M\\). Таким образом, получаем четыре варианта геометрии:\n\nдвумерные точки \\(XY\\)\nтрехмерные точки \\(XYZ\\)\nтрехмерные точки \\(XYM\\)\nчетырехмерные точки \\(XYZM\\)\n\nВ случае использования широт и долгот \\(X\\) соответствует долготе, \\(Y\\) соответствует широте.\nВсего стандарт Simple Features включает в себя 17 типов геометрий. Из них наиболее употребительными являются следующие 7:\n\n\n\n\n\n\n\nТип\nОписание\n\n\n\n\nPOINT\nнуль-мерная геометрия, содержащая одну точку\n\n\nLINESTRING\nпоследовательность точек, соединенных прямыми, несамопересекающимися отрезками; одномерная геометрия\n\n\nPOLYGON\nгеометрия с положительной площадью (двумерная); последовательность точек, отрезки между которыми формируют замкнутое кольцо без самопересечений; первое кольцо является внешним, ноль и более остальных колец представляют дырки внутри полигона\n\n\nMULTIPOINT\nмножество точек; геометрия типа MULTIPOINT называется простой если ни одна пара точек в MULTIPOINT не совпадает\n\n\nMULTILINESTRING\nмножество линий\n\n\nMULTIPOLYGON\nмножество полигонов\n\n\nGEOMETRYCOLLECTION\nмножество геометрий произвольного типа за исключением GEOMETRYCOLLECTION\n\n\n\nПримеры различных видов геометрий представлены на рисунке ниже:\n\n\n\n\n\n\n\n\n\nОставшиеся виды геометрий Simple Features включают: CIRCULARSTRING, COMPOUNDCURVE, CURVEPOLYGON, MULTICURVE, MULTISURFACE, CURVE, SURFACE, POLYHEDRALSURFACE, TIN, TRIANGLE.\nСуществует два официально закрепленных формата представления SF: Well-Known Text (WKT) и Well-Known Binary (WKB), которые необходимы для чтения таких данных человеком и машиной соответственно.\nWell-Known Text (WKT) — стандарт представления геометрии в виде множества списков координат, в которых координаты вершин разделены пробелами, вершины разделены запятыми, а компоненты полигонов и мультигеометрий заключены в круглые скобки и также разделены запятыми. Вышеприведенной картинке соответствуют следующие строки WKT:\n\n## POINT (0.5 0.5)\n## LINESTRING (0 1, 0.5 1.5, 1.2 1.2, 2 1.3, 3 2)\n## POLYGON ((0.5 0.5, 2 0, 3 2, 1.5 4, 0 3, 0.5 0.5), (1 1, 0.8 2, 2 2.2, 1.4 1.1, 1 1))\n## MULTIPOINT ((0.5 0.5), (1 3), (2 1), (0.2 2), (2 3), (1.5 1.5))\n## MULTILINESTRING ((0.5 1.5, 1.2 1.2, 2 1.3), (0 1.5, 0.5 2, 1.2 1.7), (2 1.8, 3 2.5))\n## MULTIPOLYGON (((0.5 0.5, 2 0, 3 2, 1.5 4, 0 3, 0.5 0.5), (1 1, 0.8 2, 2 2.2, 1.4 1.1, 1 1)), ((3 3.3, 3.5 3.1, 4 3, 4 3.7, 3.7 3.96, 3.2 4, 3 3.3), (3.2 3.4, 3.8 3.2, 3.8 3.7, 3.3 3.8, 3.2 3.4)), ((3 1.2, 2.5 0.2, 3.5 0.2, 3.5 1.2, 3 1.2)), ((0 1, 0.1 0.8, 0.2 0.5, 0.1 0.3, 0 0.7, 0 1)))\n## GEOMETRYCOLLECTION (POLYGON ((0.5 0.5, 2 0, 3 2, 1.5 4, 0 3, 0.5 0.5), (1 1, 0.8 2, 2 2.2, 1.4 1.1, 1 1)), MULTIPOINT ((3.5 -0.5), (4 2), (5 0), (3.2 1), (5 2), (4.5 0.5)), MULTILINESTRING ((3 3.5, 3.7 3.2, 4.5 3.3), (2.5 3.5, 3 4, 3.7 3.7), (4.5 3.8, 5.5 4.5)))\n\nWell-Known Binary (WKB) — бинарный формат хранения координат. Именно этот формат фактически используется в базах данных, поскольку он обеспечивает высокую скорость чтения и записи данных (в отличие от текстового). Однако внешний вид данных в формате WKB мало о чем говорит человеку, поскольку он предназначен для чтения компьютером. Например, вышеприведенная строка LINESTRING будет выглядеть так:\n\n## 01 02 00 00 00 05 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 f0 3f 00 00 00 00 00 00 e0 3f 00 00 00 00 00 00 f8 3f 33 33 33 33 33 33 f3 3f 33 33 33 33 33 33 f3 3f 00 00 00 00 00 00 00 40 cd cc cc cc cc cc f4 3f 00 00 00 00 00 00 08 40 00 00 00 00 00 00 00 40\n\n\n\n9.3.2 Базовые библиотеки\nВ R существует высоко развитая инфраструктура для работы с векторными данными, которая обеспечивается пакетом sf.\nПакет sf базируется на библиотеках PROJ, GDAL, GEOS и S2, которые устанавливаются вместе с ним. Их назначение кратко описано на следующем рисунке:\n\n\n\n\n\nАрхитектура программных библиотек для работы с пространственными данными в R\n\n\n\n\nСо многими функциями sf мы познакомимся в последующих разделах нашего курса. Некоторые из них (такие как arrange, filter, mutate из пакета dplyr), должны быть уже знакомы вам по предыдущим лекциям. Можно обратить внимание на то, что практически все функции начинаются с префикса st_, что означает “spatiotemporal”. Данные префиксы были выбраны для унификации с аналогичными названиями функций, используемых в широко распространенной СУБД PostgreSQL для оперирования объектами Simple Features.\n\n\n9.3.3 Чтение\nСуществует большое количество форматов хранения пространственных данных. Но в общем и целом их можно разделить на две категории: файловые форматы (наиболее привычные пользователям) и хранение данных в СУБД — системах управления базами данных. Благодаря библиотеке GDAL пакет sf имеет возможность читать и записывать более 90 различных форматов векторных даных.\nИсторически наиболее распространенным форматом был (и остается) ESRI Shapefile. Данный формат, однако не отвечает современным техническим требованиям с точки зрения гибкости, соответствия стандартам и возможностям хранения разнообразных типов геометрий (напомним, что в стандарте Simple Features их 17, а с учетом четырех вариантов размерности точек получается целых 68 ). Современный формат, который обеспечивает полную поддержку стандарта Simple Features (и не только) — это GeoPackage. Именно его мы и будем использовать в нашем практикуме.\nДля чтения данных средствами sf необходимо использовать функцию st_read():\n\ncountries = st_read('data/ne/countries.gpkg')\n## Reading layer `admin_0_map_units' from data source \n##   `/Users/tsamsonov/GitHub/r-geo-course/data/ne/countries.gpkg' \n##   using driver `GPKG'\n## Simple feature collection with 183 features and 72 fields\n## Geometry type: MULTIPOLYGON\n## Dimension:     XY\n## Bounding box:  xmin: -180 ymin: -90 xmax: 180 ymax: 83.64513\n## Geodetic CRS:  WGS 84\n\nЛог функции сообщил нам следующую информацию:\n\nНабор данных представляет собой коллекцию из 183 пространственных объектов с 72 атрибутами\nТип геометрии MULTIPOLYGON\nРазмерность геометрии \\(XY\\)\nОграничивающий прямоугольник (разброс координат) по осям \\(X\\) и \\(Y\\) имеет диапазон \\([-180, 180] \\times [-90, 83.64513]\\)\nПроекция (CRS — coordinate reference system) имеет название WGS 84.\n\nПодгрузим также для работы данные по другим типам объектов:\n\noceans = st_read('data/ne/oceans.gpkg')\n## Reading layer `ocean' from data source \n##   `/Users/tsamsonov/GitHub/r-geo-course/data/ne/oceans.gpkg' \n##   using driver `GPKG'\n## Simple feature collection with 2 features and 4 fields\n## Geometry type: POLYGON\n## Dimension:     XY\n## Bounding box:  xmin: -180 ymin: -85.60904 xmax: 180 ymax: 90\n## Geodetic CRS:  WGS 84\nrivers = st_read('data/ne/rivers.gpkg')\n## Reading layer `rivers_lake_centerlines' from data source \n##   `/Users/tsamsonov/GitHub/r-geo-course/data/ne/rivers.gpkg' \n##   using driver `GPKG'\n## Simple feature collection with 13 features and 8 fields\n## Geometry type: LINESTRING\n## Dimension:     XY\n## Bounding box:  xmin: -135.3134 ymin: -33.99358 xmax: 129.956 ymax: 72.90651\n## Geodetic CRS:  WGS 84\nlakes = st_read('data/ne/lakes.gpkg')\n## Reading layer `lakes' from data source \n##   `/Users/tsamsonov/GitHub/r-geo-course/data/ne/lakes.gpkg' using driver `GPKG'\n## Simple feature collection with 25 features and 8 fields\n## Geometry type: POLYGON\n## Dimension:     XY\n## Bounding box:  xmin: -124.9536 ymin: -16.53641 xmax: 109.9298 ymax: 66.9693\n## Geodetic CRS:  WGS 84\ncities = st_read('data/ne/cities.gpkg')\n## Reading layer `populated_places' from data source \n##   `/Users/tsamsonov/GitHub/r-geo-course/data/ne/cities.gpkg' \n##   using driver `GPKG'\n## Simple feature collection with 243 features and 103 fields\n## Geometry type: POINT\n## Dimension:     XY\n## Bounding box:  xmin: -175.2206 ymin: -41.29999 xmax: 179.2166 ymax: 64.15002\n## Geodetic CRS:  WGS 84\n\n\n\n9.3.4 Внутренняя структура\nТрадиционно во всех ГИС-приложениях и базах пространственных данных множество пространственных объектов представляется в виде таблицы атрибутов, где каждая строка соответствует объекту, а каждый столбец — атрибуту объекта. С каждой строкой таблицы должна быть ассоциирована информация о геометрии объекта, которая, в зависимости от формата данных, может либо храниться непосредственно в таблице (в специальном столбце), либо быть вынесена в отдельную структуру данных, которая связана с таблицей атрибутов посредством ключа2.\nВ R используется первый подход, в котором информация о геометрии хранится в специальном столбце таблицы. Каждая ячейка этого столбца соответствует геометрическому объекту Simple Features. Представление геометрических объектов реализовано стандартными средствами, такими как списки, матрицы и векторы. Эти структуры данных упорядоченным образом хранят координаты объектов и естественным образом соответствуют способу организации данных, который регламентируется стандартом Simple Features. Поскольку геометрический столбец хранит не обычные переменные, а структуры данных, он реализуется в виде так называемого списка-колонки (list-column), каждый элемент которой соответствует отдельному объекту.\nИсходя из этих соображений, представление пространственных объектов реализовано в R в виде иерархии из трех классов объектов:\n\nsf (simple features) — объект класса data.frame, представляющий множество пространственных объектов со списком-колонкой для хранения геометрии\nsfc (simple features geometry column) — список-колонка в объекте sf, представляющий множество геометрий пространственных объектов\nsfg (simple feature geometry) — геометрия пространственного объекта внутри списка sfc\n\nВ соответствии с перечисленными спецификациями происходит работа с пространственными объектами. То что, объекты типа Simple Features реализованы в виде самых обычных фреймов данных, означает что любая операция, применимая к фрейму данных, будет также применима к объекту типа sf. Это очень важная особенность объектов типа sf, которой сильно не хватало в экосистеме исторического пакета sp.\nПосмотрим, как все это реализовано, на конкретном примере:\n\nclass(countries)\n## [1] \"sf\"         \"data.frame\"\n\nДанная форма записи говорит о том, что прочитанный слой имеет класс sf, который, в свою очередь, является расширением класса data.frame.\nА теперь посмотрим на последние колонки в первых строках таблицы:\n\nhead(countries[tail(colnames(countries))])\n## Simple feature collection with 6 features and 5 fields\n## Geometry type: MULTIPOLYGON\n## Dimension:     XY\n## Bounding box:  xmin: -73.41544 ymin: -55.25 xmax: 75.15803 ymax: 42.68825\n## Geodetic CRS:  WGS 84\n##   tiny homepart min_zoom min_label max_label                       geometry\n## 1  -99        1        0         3         7 MULTIPOLYGON (((61.21082 35...\n## 2  -99        1        0         3         7 MULTIPOLYGON (((23.90415 -1...\n## 3  -99        1        0         5        10 MULTIPOLYGON (((21.02004 40...\n## 4  -99        1        0         4         9 MULTIPOLYGON (((51.57952 24...\n## 5  -99        1        0         2         7 MULTIPOLYGON (((-66.95992 -...\n## 6  -99        1        0         5        10 MULTIPOLYGON (((43.58275 41...\n\nВидно, что геометрия пространственных объектов хранится в заключительном столбце с названием geometry. Данный столбец можно быстро извлечь, применив функцию st_geometry(). Полученный объект будет иметь тип sfc (Simple Feature Geometry Column)\n\noutlines = st_geometry(countries)\nclass(outlines)\n## [1] \"sfc_MULTIPOLYGON\" \"sfc\"\n\nПолученный вывод говорит нам о том, что наши объекты имеют класс sfc_MULTIPOLYGON, который является расширением класса sfc (simple feature geometry column).\nТеперь если просмотреть начало данных, то мы увидим, что это больше не фрейм данных, а аннотированный список:\n\nhead(outlines)\n## Geometry set for 6 features \n## Geometry type: MULTIPOLYGON\n## Dimension:     XY\n## Bounding box:  xmin: -73.41544 ymin: -55.25 xmax: 75.15803 ymax: 42.68825\n## Geodetic CRS:  WGS 84\n## First 5 geometries:\n\nДалее можно опуститься на базовый уровень геометрии, получив доступ к отдельному объекту. Поскольку объект класса sfc представляет собой список, любой элемент можно извлечь по его порядковому номеру. Класс полученного объекта будет:\n\nclass(outlines[[8]])\n## [1] \"XY\"           \"MULTIPOLYGON\" \"sfg\"\n\nИсходя из полученной информации можно сделать вывод, что геометрия 8-го объекта таблицы countries имеет класс sfg, реализованный в виде мультиполигонов (MULTIPOLYGON) с плоскими координатами (XY)\nНаконец, чтобы добраться до координат в чистом виде, необходимо развернуть иерархию списков, из которых состоит объект sfg. Количество уровней вложенности всегда зависит от конкретного объекта, их может быть достаточно много, особенно если объекты представлены мультиполигонами (несколько компонент связности), каждый из которых также состоит из полигонов с дырками. В нашем случае все достаточно просто, так как в слое countries дырок в полигонах нет, а 8-й по счету полигон состоит из одной-единственной геометрии, координаты которой в виде матрицы можно извлечь как:\n\noutlines[[8]][[1]]\n## [[1]]\n##          [,1]     [,2]\n##  [1,] 68.9350 -48.6250\n##  [2,] 69.5800 -48.9400\n##  [3,] 70.5250 -49.0650\n##  [4,] 70.5600 -49.2550\n##  [5,] 70.2800 -49.7100\n##  [6,] 68.7450 -49.7750\n##  [7,] 68.7200 -49.2425\n##  [8,] 68.8675 -48.8300\n##  [9,] 68.9350 -48.6250\n\n\n\n9.3.5 Визуализация\n\n9.3.5.1 Базовая графическая система\nЕсли попытаться применить функцию plot() к геометрии объекта, она попытается нарисовать тематические карты по всем имеющимся атрибутам (но остановится, если их более 9):\n\nplot(countries)\n\n\n\n\n\n\n\n\nЕсли задача стоит нарисовать границы объектов, то нужно отображать объект sfc:\n\nplot(outlines, col = 'red')\n\n\n\n\n\n\n\n\nДля быстрого построения тематических карт по выбранному показателю необходимо при вызове функции plot() указать соответствующий атрибут фрейма данных:\n\nplot(countries['sovereignt'], key.pos = NULL) # Здесь легенда не нужна\n\n\n\n\n\n\n\n\nДля отображения координатной сетки надо указать параметр graticule = TRUE, а подписей координат — axes = TRUE:\n\nplot(countries['gdp_md_est'], graticule = TRUE, axes = TRUE)\n\n\n\n\n\n\n\n\nДля совмещения нескольких слоев на одной карте необходимо при втором и последующих вызовах функции plot() указать параметр add = TRUE. Все остальные настройки визуализации работают так же,как и в обычной графике:\n\ncities_large = cities |&gt; \n  filter(scalerank == 0, \n         ! name %in% c('Washington, D.C.', 'Paris', 'Riyadh', 'Rome', 'São Paulo', 'Kolkata'))\n\nplot(st_geometry(countries), lwd = 0.5, border = 'gray')\nplot(oceans, col = 'steelblue1', border = 'steelblue', add = TRUE)\nplot(lakes, col = 'steelblue1', border = 'steelblue', add = TRUE)\nplot(rivers, col = 'steelblue', add = TRUE)\nplot(cities_large, col = 'black', pch = 19, cex = 0.25, add = TRUE)\ntext(cities_large$longitude, cities_large$latitude, \n     label = cities_large$name, cex = 0.5, pos = 2, offset = 0.25)\n\n\n\n\n\n\n\n\n\nВнимание: чтобы слои совместились на карте, они должна иметь одинаковую систему координат.\n\nЯсно, что на полученных нами картах можно много что улучшить, однако это мы отложим до следующей главы, где подробно разбирается построение тематических карт в R.\n\nВнимание: чтобы слои данных можно было совместно анализировать и наносить на одну карту, они должны иметь одну и ту же координатную систему (проекцию).\n\n\n\n9.3.5.2 Интерактивные карты\nR предоставляет возможности для интерактивного просмотра пространственных данных средствами библиотек веб-картографирования. В данном разделе мы кратко познакомимся с возможностями пакета mapview, который использует возможности библиотеки Leaflet. Функции данного пакета не предназначены для создания тематических карт высокого качества и рассчитаны на выполнение исследовательского анализа данных.\nЧтобы отобразить векторный или растровый слой средствами mapview, достаточно вызвать одноименную функцию данного пакета:\n\nmapview(countries)\n\n\n\n\n\n\n\n\n\n\nЧтобы отобразить определенный показатель, можно использовать параметр zcol, а палитру передать в параметр col.regions:\n\nnconts = length(unique(countries$continent))\nmapview(countries, zcol = 'continent', \n        col.regions = RColorBrewer::brewer.pal(nconts, 'Set1'))\n\n\n\n\n\n\n\n\n\n\nЧтобы скомбинировать несколько слоев, необходимо сложить несколько вызовов mapview():\n\n{ mapview(countries, zcol = 'continent', \n        col.regions = RColorBrewer::brewer.pal(nconts, 'Set1')) + \n  mapview(cities_large, col.regions = 'black', label = 'name', cex = 3) } |&gt; \n  leafem::addStaticLabels(cities_large, label = cities_large$name,\n                          offset = c(0.1, 0),\n                          style = list(\"color\" = \"black\", \"font-weight\" = \"bold\"))\n\n\n\n\n\n\n\n\n\n\n\n\n\n9.3.6 Атрибутивные операции\nПоскольку пространственные объекты хранятся в фреймах данных, к ним можно применять стандартные операции выборки по атрибутам и преобразования таблиц. Например, можно выбрать Италию и отобразить ее на отдельной карте:\n\nitaly = countries |&gt; \n  filter(sovereignt == 'Italy')\nplot(st_geometry(italy))\n\n\n\n\n\n\n\n\nСледующий пример иллюстрирует как выбрать страны с населением более 100 млн человек:\n\nlargest = countries |&gt; \n  select(pop_est) |&gt; \n  filter(pop_est &gt; 100000000)\nplot(outlines, col = 'lightgrey')\nplot(largest, col = 'red', add = TRUE)\n\n\n\n\n\n\n\n\nОбратите внимание на то, что при вызове функции select() столбец geometry не был указан в числе выбираемых переменных. Тем не менее, то, что мы смогли построить карту по результатам выборки, говорит о том, что данный столбец был сохранен. Функции dplyr определены для объектов sf таким образом, чтобы всегда сохранять геометрический столбец.\nЕще интереснее работает агрегирование объектов по атрибутам. В случае, когда агрегируются пространственные объекты, необходимо объединять и их геометрию. При этом если у агрегируемых объектов имеется общая граница, ее необходимо удалить, а если объекты разнесены в пространстве, из них нужно собрать новый мульти-объект.\nНапример, мы можем агрегировать валовой региональный продукт по континентам:\n\ncontinents = countries %&gt;% # этот пайп из пакета magrittr для подстановки в точку\n  filter(., st_is_valid(.)) |&gt;\n  group_by(continent) |&gt;  \n  summarise(gdp = sum(gdp_md_est))\nplot(continents['gdp'])\n\n\n\n\n\n\n\n\nПотрясающе просто, не правда ли? Вдобавок, мы еще и получили границы континентов (достаточно условные, конечно), которых у нас раньше не было. Данный пример также показывает, что атрибутивные операции над пространственными объектами всегда учитывают их геометрию.\n\n\n9.3.7 Создание пространственных объектов\nПространственные объекты в R можно собирать “вручную”, если есть такая необходимость. Например, вам известны координаты границ участков полевого обследования, полученные посредством GPS, а вам необходимо превратить их в полигоны, чтобы выполнить анализ и картографирование. Придется из координат собрать полигоны программным путем. Процесс создания пространственных объектов осуществляется в последовательности их иерархического соподчинения: sfg &gt; sfc &gt; sf.\n\n9.3.7.1 Геометрические объекты (sfg)\nДля создания геометрических объектов в пакете sf существует ряд функций с говорящими названиями:\n\n\n\nФункция\nТип пространственного объекта\n\n\n\n\nst_point()\nPOINT\n\n\nst_linestring()\nLINESTRING\n\n\nst_polygon()\nPOLYGON\n\n\nst_multipoint()\nMULTIPOINT\n\n\nst_multilinestring()\nMULTILINESTRING\n\n\nst_multipolygon()\nMULTIPOLYGON\n\n\nst_geometrycollection()\nGEOMETRYCOLLECTION\n\n\n\nВ зависимости от типа создаваемого объекта, данные функции принимают координаты, организованные в виде одной из трех структур данных:\n\nВектор координат (POINT)\nМатрица координат (MULTIPOINT или LINESTRING), в которой строки соответствуют точкам, столбцы — координатам\nСписок (для всех остальных типов)\n\nПроще всего создаются отдельные точки (POINT):\n\nst_point(c(0, 2)) # XY POINT\nst_point(c(0, 2, -1)) # XYZ POINT\nst_point(c(0, 2, 5), dim = 'XYM') # XYM POINT\nst_point(c(0, 2, -1, 5)) # XYZM POINT\n\nДополнительный параметр dim= служит для уточнения типа геометрии точек и по сути нужен только тогда, когда необходимо создать редко используемые точки типа XYM. во всех остальных случаях (XY, XYZ, XYZM) размерность геометрии распознается по умолчанию.\nПри создании мультиточек (MULTIPOINT) и линий (LINESTRING) необходимо подавать на вход функции уже матрицу координат:\n\ncoords = matrix(c(\n  0, 2,\n  1, 3,\n  3, 1,\n  5, 0\n), ncol = 2, byrow = TRUE)\n\nmp = st_multipoint(coords) # XY MULTIPOINT\nprint(mp)\n\nls = st_linestring(coords) # XY LINESTRING\nprint(ls)\n\nВ первом случае геометрия состоит из отдельных точек. Во втором случае те же самые точки соединены линией:\n\nplot(ls)\nplot(mp, col = 'red', pch = 19, add = TRUE)\n\n\n\n\n\n\n\n\nСоздание трех-(XYZ, XYM) и четырехмерных (ZYXM) мультиточек и линий выполняется аналогично, но матрица должна содержать не 2, а, соответственно 3 или 4 столбца, и при необходимости параметр dim = 'XYM'.\nСоздание полигонов (POLYGON), мультиполигонов (MULTIPOLYGON) и мультилиний (MULTILINESTRING) требует уже создания списков из матриц.\nПочему нельзя представить обычный (не мульти) полигон просто матрицей координат? Потому что полигон может содержать дырки. Например, контур леса может содержать дырку в том месте, где находится озеро. Или озеро может содержать дырку в том месте, где находится остров. Природа предлагает нам бесконечное число таких примеров. В целях универсализации приходится закладываться на возможность наличия дырок в полигонах, поэтому даже полигоны без дырок представляются в виде списков. При этом действу.т следующее правила:\n\nПервая матрица координат в списке отвечает за контур полигона\nВсе остальные матрицы координат отвечают за дыры в полигоне\nКоординаты первой и последней точки в каждой матрице должны совпадать\n\nЕсли дыр в полигоне нет, его список будет содержать только одну матрицу. Рассмотрим оба примера построения полигонов:\n\ncoords = matrix(c( # Координаты главного полигона\n  1, 0,\n  0, 2,\n  2, 3,\n  4, 2,\n  3, 0.5,\n  1, 0\n), ncol = 2, byrow = TRUE)\n\npol = st_polygon(list(coords)) # Простой полигон\nprint(pol)\n\nplot(pol, col = 'lightblue')\n\n\n\n\n\n\n\n\nhole = matrix(c( # Координаты дыры\n  2, 1,\n  3, 1.5,\n  3, 2,\n  2, 2,\n  1.5, 1.5,\n  2, 1\n), ncol = 2, byrow = TRUE)\n\npol2 = st_polygon(list(coords, hole)) # Полигон с дырой\nprint(pol2)\n\nplot(pol2, col = 'lightblue')\n\n\n\n\n\n\n\n\nМультиполигоны (MULTIPOLYGON) и мультилинии (MULTILINESTRING) требуются тогда, когда один и тот же географический объект состоит из нескольких геометрических объектов. Простейший пример — островные государства. Чтобы представить страну, занимающую архипелаг (Багамские острова, Индонезия, Япония и т.д.) как один пространственный объект, необходимо создать мультиполигон. Все компоненты мультиполигона будут иметь общий набор атрибутов (непространственных характеристик). Мультилинии используются реже мультиполигонов и необходимы для представления линейных объектов, разорванных в пространстве. Примером такого объекта может быть любая река или канал, которые разорваны в тех местах, где они протекают через озеро или водохранилище, представленное полигональным объектом.\nВ мультиполигонах добавляется еще один уровень списка, то есть искомые матрицы координат будут располагаться как минимум на втором уровне вложенности:\n\ncoords1 = matrix(c(\n  0.5, 0,\n  0, 1,\n  1, 1.5,\n  2, 1,\n  1.5, 0.25,\n  0.5, 0\n), ncol = 2, byrow = TRUE)\n\ncoords2 = matrix(c(\n  3, 1,\n  2.5, 2,\n  3.5, 2.5,\n  4, 2,\n  4, 1.25,\n  3, 1\n), ncol = 2, byrow = TRUE)\n\nmpol = st_multipolygon(list(list(coords1), list(coords2)))\nprint(mpol)\n\nplot(pol, col = 'grey') # Обычный полигон (серый)\nplot(mpol, col = 'pink', add = TRUE) # Мультиполигон (розовый)\n\n\n\n\n\n\n\n\nКак насчет острова на озере? Если остров и суша, окружающая озеро, составляют единое целое (например, подлежат учету как единый массив леса), их можно собрать как мультиполигон. В этом случае первая компонента мультиполигона будет представлять собой полигон с дыркой, а вторая компонента — остров. Порядок компонент в данном случае роли не играет:\n\ncoords4 = matrix(c(\n  2.2, 1.2,\n  2.8, 1.5,\n  2.8, 1.8,\n  2.2, 1.8,\n  2.0, 1.6,\n  2.2, 1.2\n), ncol = 2, byrow = TRUE)\n\nisland = st_polygon(list(coords4))\n\nmpol2 = st_multipolygon(list(pol2, island))\n\nprint(mpol2)\n\nplot(mpol2, col = 'darkolivegreen4')\n\n\n\n\n\n\n\n\nИз данного примера также видно, что при сборе мультиполигона на самом нижнем уровне вложенности можно подавать не списки матриц координат, а готовые полигоны.\nМультилиния, в отличие от мультиполигона, не требует дополнительного списка верхнего уровня, поскольку линии не могут содержать дыр. Например, можно собрать мультилинию из двух частей, соответствующих участкам реки до и после озера:\n\ncoords1 = matrix(c(\n  -3, 0,\n  -1, 2,\n  0, 2\n), ncol = 2, byrow = TRUE)\n\ncoords2 = matrix(c(\n  4, 2,\n  5, 3,\n  6, 5\n), ncol = 2, byrow = TRUE)\n\nmline = st_multilinestring(list(coords1, coords2))\nprint(mline)\n\nplot(mline, lwd = 3, col = 'blue')\nplot(pol2, col = 'lightblue', add = TRUE)\n\n\n\n\n\n\n\n\nНаконец, еще один вид геометрии — это геометрическая коллекция (GEOMETRYCOLLECTION), который позволяет хранить вместе любые виды геометрий. Эта возможность используется достаточно редко, тем не менее, рассмотреть ее нужно. Геометрическая коллекция собирается из списка объектов с простыми типами геометрии (мы создали их ранее):\n\ncol = st_geometrycollection(list(ls, mp, mline, pol2))\nprint(col)\nplot(col)\n\n\n\n\n\n\n\n\n\n\n9.3.7.2 Списки геометрических объектов (sfc)\nСписки геометрических объектов (класс sfc) используются в таблицах пространственных объектов в качестве столбца, который хранит геометрию объектов. Создание таких списков осуществляется функцией st_sfc(), которой достаточно передать в качестве перечня параметров объекты типа sfg. Рассмотрим создание списка геометрий на примере точечных объектов (для остальных типов объектов порядок действий не меняется):\n\nmoscow.sfg = st_point(c(37.615, 55.752))\nirkutsk.sfg = st_point(c(104.296, 52.298))\npetro.sfg = st_point(c(158.651, 53.044))\n\ncities.sfc = st_sfc(moscow.sfg, irkutsk.sfg, petro.sfg)\nprint(cities.sfc)\n## Geometry set for 3 features \n## Geometry type: POINT\n## Dimension:     XY\n## Bounding box:  xmin: 37.615 ymin: 52.298 xmax: 158.651 ymax: 55.752\n## CRS:           NA\n\nПри создании списка геометрий для него может быть определена система координат (это можно сделать и позднее при создании таблицы пространственных объектов). Для этого используем уже знакомую нам функцию st_crs():\n\nst_crs(cities.sfc) = st_crs(4326) # WGS84\nprint(cities.sfc)\n## Geometry set for 3 features \n## Geometry type: POINT\n## Dimension:     XY\n## Bounding box:  xmin: 37.615 ymin: 52.298 xmax: 158.651 ymax: 55.752\n## Geodetic CRS:  WGS 84\n\n\nДля списка геометрий может быть определена только одна система координат\n\nМожно посмотреть, куда легли наши точки:\n\nplot(cities.sfc, pch = 19)\ncountries |&gt; \n  filter(sovereignt == 'Russia') |&gt; \n  st_geometry() |&gt;\n  plot(add = TRUE)\n\n\n\n\n\n\n\n\n\n\n9.3.7.3 Пространственные объекты (sf)\nПространственные объекты (класс sf) организуются в виде фрейма данных, один из столбцов которого имеет класс sfc. Для этого следует сначала создать обычный фрейм данных с атрибутами, а затем соединить его со списком геометрий посредством функции st_sf:\n\ncity.attr = data.frame(\n  name = c('Москва', 'Иркутск', 'Петропавловск-Камчатский'),\n  established = c(1147, 1661, 1740),\n  population = c(12500, 620, 180)\n)\n\ncites.sf = st_sf(city.attr, geometry = cities.sfc)\nprint(cites.sf)\n## Simple feature collection with 3 features and 3 fields\n## Geometry type: POINT\n## Dimension:     XY\n## Bounding box:  xmin: 37.615 ymin: 52.298 xmax: 158.651 ymax: 55.752\n## Geodetic CRS:  WGS 84\n##                       name established population               geometry\n## 1                   Москва        1147      12500  POINT (37.615 55.752)\n## 2                  Иркутск        1661        620 POINT (104.296 52.298)\n## 3 Петропавловск-Камчатский        1740        180 POINT (158.651 53.044)\n\n\n\n9.3.7.4 Точки по координатам\nДостаточно распространенной является следующая задача: имеются координаты точек в табличной форме, необходимо создать на их основе набор пространственных объектов. Для решения этой задачи можно воспользоваться функцией st_as_sf(). Рассмотрим задачу на примере файла координат станций из базы метеорологических данных ВНИИГМИ-МЦД:\n\n(stations = read_fwf('data/vniigmi/stations.txt', \n                    col_positions = fwf_widths(diff(c(1, 7, 42, 47, 53, 59, 67, 71)), \n                                               col_names = c('id', 'name', 'lat', 't1', 'lon', 't2', 'z')),\n                    locale = locale(encoding = 'CP1251')))\n## # A tibble: 1,124 × 7\n##       id name                  lat t1      lon t2        z\n##    &lt;dbl&gt; &lt;chr&gt;               &lt;dbl&gt; &lt;chr&gt; &lt;dbl&gt; &lt;chr&gt; &lt;dbl&gt;\n##  1 20046 Им.Э.Т.Кренкеля,ГМО  80.6 с.ш.   58   в.д.     21\n##  2 20069 Остров_Визе          79.5 с.ш.   77.0 в.д.     10\n##  3 20087 Голомянный           79.6 с.ш.   90.6 в.д.      7\n##  4 20107 Баренцбург           78.1 с.ш.   14.2 в.д.     73\n##  5 20289 Русский              77.2 с.ш.   96.4 в.д.      9\n##  6 20292 Им.Е.К.Федорова,ГМО  77.7 с.ш.  104.  в.д.     12\n##  7 20353 мыс_Желания          77.0 с.ш.   68.6 в.д.      9\n##  8 20476 Стерлегова           75.4 с.ш.   88.9 в.д.     10\n##  9 20667 Им.М.В.Попова        73.3 с.ш.   70.0 в.д.      4\n## 10 20674 Остров_Диксон        73.5 с.ш.   80.4 в.д.     42\n## # ℹ 1,114 more rows\n\nТеперь создадим пространственные точки на основе этой таблицы, взяв координаты из столбцов lat и lon соответственно и указав код системы координат:\n\nsf_stations = st_as_sf(stations, coords = c(\"lon\", \"lat\"), crs = 4326)\n\nplot(st_geometry(sf_stations), pch = 19, col = 'red', cex = 0.25)\nplot(st_geometry(countries), border = 'grey', add = TRUE)\nbox()\n\n\n\n\n\n\n\n\n\n\n9.3.7.5 Преобразование типов геометрии\nДля преобразования типов геометрии существует функция st_cast(). Функция принимает объекты классов sfg, sfc или sf, а также название типа геометрии, к которому необходимо привести входные объекты. Довольно часто возникает задача конвертации площадного объекта в линейный и обратно, а также задача получения координат вершин линейного или площадного объекта в виде точек. Примеры преобразований:\n\nitaly.borders = st_cast(italy, 'MULTILINESTRING')\nclass(st_geometry(italy.borders))\n## [1] \"sfc_MULTILINESTRING\" \"sfc\"\n\nitaly.regions = st_cast(italy.borders, 'MULTIPOLYGON')\nclass(st_geometry(italy.regions))\n## [1] \"sfc_MULTIPOLYGON\" \"sfc\"\n\nitaly.points = st_cast(italy.borders, 'POINT')\nclass(st_geometry(italy.points))\n## [1] \"sfc_POINT\" \"sfc\"\n\nplot(st_geometry(italy.regions), lwd = 0.5)\nplot(italy.points, pch = 20, add = TRUE)\n\n\n\n\n\n\n\n\n\n\n9.3.7.6 Полигонизация и разбиение линий\nПолигонизация — это процесс преобразования линии или мультилинии в полигон(ы). Полигон может быть образован последовательностью из одной и более линий, для которых выполняются следующие условия:\n\nКаждая линия является простой (не имеет самопересечений)\nЛинии касаются только своими начальными и конечными точками\nЛинии образуют замкнутую последовательность (т.е. выйдя из любой конечной точки и двигаясь вдоль множества линий, можно вернуться в ту же точку.)\n\nПолигонизация может применяться только к одному геометрическому объекту (simple feature geometry). Соответственно, это должна быть либо просто замкнутая линия, либо мультилиния, компоненты которой образуют замкнутую последовательность.\nРассмотрим операции полигонизации и добавления узлов на простом примере трех пересекающихся отрезков:\n\n# Создадим три линии\ncoords1 = rbind(c(0, 0), c(0, 6))\nline1 = st_linestring(coords1)\n\ncoords2 = rbind(c(-1,1), c(5,1))\nline2 = st_linestring(coords2)\n\ncoords3 = rbind(c(-1,5), c(4,0))\nline3 = st_linestring(coords3)\n\n# Создадим мультилинию\nmls = st_multilinestring(list(line1, line2, line3))\nplot(mls)\n\n# Посмотрим на ее точки\npoints = st_cast(mls, 'MULTIPOINT')\nplot(points, pch = 20, add = TRUE)\n\n\n\n\n\n\n\n\nИз рисунка видно, что линии образуют треугольную замкнутую область. Также рисунок показывает, что у компонент мультилинии нет вершин в точках пересечения. Мы можем попытаться найти замкнутые области и превратить их в полигоны, используя st_polygonize():\n\nst_polygonize(mls)\n\nОперация завершилась возвратом пустой геометрической коллекции, то есть программа не смогла выделить замкнутые области. Это произошло по причине того, что линии не разбиты в точках пересечения. Разбить их на компоненты можно, используя функцию st_node():\n\nmls2 = st_node(mls)\npoly2 = st_polygonize(mls2)\npoints2 = st_cast(mls2, 'MULTIPOINT')\n\nplot(mls2)\nplot(poly2, col = 'grey', add = TRUE)\nplot(points2, pch = 20, add = TRUE)\n\n\n\n\n\n\n\n\nТаким образом, после разбиения линий на куски в точках пересечения стала возможной операция полигонизации.\n\n\n\n9.3.8 Геометрические атрибуты\nК описательным характеристикам геометрии относятся ограничивающий прямоугольник, периметр (для линий и полигонов), площадь (для полигонов), центроид и список координат, которые можно получить с помощью функций st_bbox(), st_length(), st_area(), st_centroid() и st_coordinates() соответственно. Функции корректно работают для простых объектов, мультиобъектов, списков геометрий и пространственных объектов. Применительно к полигону Италии эти параметры будут учитывать части геометрии, занимаемые островами:\n\nst_bbox(italy)        # Координаты органичивающего прямоугольника\n##      xmin      ymin      xmax      ymax \n##  6.749955 36.619987 18.480247 47.115393\nst_area(italy)        # Площадь\n## 314577521836 [m^2]\nst_length(italy)      # Периметр\n## 0 [m]\nst_centroid(italy) |&gt; st_geometry()    # Центроид (может быть не внутри для невыпуклых фигур)\n## Geometry set for 1 feature \n## Geometry type: POINT\n## Dimension:     XY\n## Bounding box:  xmin: 12.2687 ymin: 42.67074 xmax: 12.2687 ymax: 42.67074\n## Geodetic CRS:  WGS 84\nst_point_on_surface(italy) |&gt; st_geometry() # Точка гарантированно внутри, но не обязательно в центре\n## Geometry set for 1 feature \n## Geometry type: POINT\n## Dimension:     XY\n## Bounding box:  xmin: 12.63118 ymin: 42.55822 xmax: 12.63118 ymax: 42.55822\n## Geodetic CRS:  WGS 84\nst_coordinates(italy) |&gt; head() # Список координат\n##             X        Y L1 L2 L3\n## [1,] 10.44270 46.89355  1  1  1\n## [2,] 11.04856 46.75136  1  1  1\n## [3,] 11.16483 46.94158  1  1  1\n## [4,] 12.15309 47.11539  1  1  1\n## [5,] 12.37649 46.76756  1  1  1\n## [6,] 13.80648 46.50931  1  1  1\n\nОбратите внимание на то, что площадь и периметр выводятся с указанием единиц измерений! Это возможно благодаря тому, что объекты типа sf поддерживают единицы измерений на основе пакета units.\n\nЕсли данные находятся в плоской прямоугольной системе координат, то единицы измерения как правило указываются в параметрах проекции — следовательно, они могут быть использованы при вычислении геометрических параметров объектов. Если же данные хранятся в широтах и долготах, то вычисление геометрических параметров осуществляется пакетом sf по формулам сферической тригонометрии через пакет geosphere. Это позволяет выводить результат в плоских единицах измерения.\n\nОграничивающий прямоугольник можно быстро преобразовать в полигон и нанести на карту, применив функцию st_as_sfc():\n\nbox = st_as_sfc(st_bbox(italy)) # Ограничивающий прямоугольник\n\nplot(italy |&gt; st_geometry(), \n     col = 'lightgrey')\nplot(box, \n     border = 'orangered', \n     add = TRUE)\nplot(st_centroid(italy), \n     col = 'darkgreen', \n     pch = 19,\n     add = TRUE)\nplot(st_point_on_surface(italy), \n     col = 'steelblue4', \n     pch = 19,\n     add = TRUE)\n\n\n\n\n\n\n\n\nКак видно, в данном случае центроид и характерная точка расположились относительно рядом. Однако так бывает далеко не всегда. Выполним аналогичные вычисления для Индонезии:\n\nindonesia = countries |&gt; filter(sovereignt == 'Indonesia')\n\nbox = st_as_sfc(st_bbox(indonesia))\n\nplot(indonesia |&gt; st_geometry(), \n     col = 'lightgrey')\nplot(box, \n     border = 'red', \n     add = TRUE)\nplot(st_centroid(indonesia), \n     col = 'darkgreen', \n     pch = 19,\n     add = TRUE)\nplot(st_point_on_surface(indonesia), \n     col = 'steelblue4', \n     pch = 19,\n     add = TRUE)\n\n\n\n\n\n\n\n\nКак видно, в данном случае центроид мультиполигона оказался за пределами какой-либо из его полигональных компонент, в то время как характерная точка находится внутри одного из полигонов. Таким образом, если необходимо получить точку, находящуюся гарантированно в пределах исходного множества, следует использовать st_point_on_surface(). При этом следует помнить, что характерная точка, в отличие от центроида, может не располагаться в визуальном центре тяжести множества объектов, и выбор между этими способами описания геометрии остается за разработчиком.\n\n\n9.3.9 Экспорт\nДля экспорта векторных пространственных данных можно воспользоваться функцией st_write(), которая определит формат выходного файла по указанному вами расширению:\n\nst_write(cites.sf, 'data/mycities.shp') # Шейп-файл",
    "crumbs": [
      "Пространственные данные и карты",
      "<span class='chapter-number'>9</span>  <span class='chapter-title'>Пространственные данные</span>"
    ]
  },
  {
    "objectID": "09-SpatialData.html#raster_data_r",
    "href": "09-SpatialData.html#raster_data_r",
    "title": "9  Пространственные данные",
    "section": "9.4 Растровые данные",
    "text": "9.4 Растровые данные\nРабота с растровыми данными в целом гораздо проще, чем работа с векторными объектами. Это обусловлено в том числе жесткой сеточной структурой данных, которая предоставляет не так много свободы в различных сценариях обработки данных. В то же время, эта структура позволяет сделать растровые алгоритмы универсальными и робастными, многие задачи решаются в растровом виде быстрее и проще, чем в векторном.\n\n9.4.1 Теоретические сведения\nРастр представляет из себя матрицу значений. Каждой ячейке матрицы соответствует прямоугольная пространственная область фиксированного размера, которая называется пикселом. Различают растры непрерывные и категориальные (классифицированные). Также необходимо разделять одноканальные и многоканальные растры. Примером одноканального растра является цифровая модель рельефа. В виде многоканальных растров часто представляют космические снимки.\nВ отличие от векторных данных, которые требуют указания координат для каждой вершины, регулярно-ячеистый характер растровой модели позволяет вычислять координаты пикселов на основе их индексов. Поэтому фактически растровые данные хранятся в виде линейно упорядоченного списка значений (raster values) и описания геометрии растра (raster geometry).\nГеометрия растра определяет, где именно располагаются в пространстве пикселы растра и может быть описана путем указания следующих компонент3:\n\n\n\nПараметр\nНазначение\n\n\n\n\nNCOLS\nКоличество столбцов\n\n\nNROWS\nКоличество строк\n\n\nXLLCENTER\nКоордината \\(X\\) центра левой нижней ячейки растра\n\n\nYLLCENTER\nКоордината \\(Y\\) центра левой нижней ячейки растра\n\n\nCELLSIZE\nРазмер ячейки\n\n\n\nИногда вместо параметров XLLCENTER/YLLCENTER указываются XLLCORNER/YLLCORNER, которые кодируют координаты левого нижнего угла, а не центра левой нижней ячейки растра. Выбор одного из двух этих вариантов определяет тип регистрации растра, а их значения указывают, в какое именно место необходимо “посадить” растр, чтобы его ячейки заняли соответствующие им области в системе координат. Если геометрия растра характеризуется анизотропией, то вместо одного значения CELLSIZE могут быть указаны разные размеры ячеек по осям координат CELLSIZEX и CELLSIZEY.\nВ отличие от векторной модели, которая позволяет хранить данные только о нужных географических локациях, растровая модель такой свободы не предоставляет. Матрица ячеек растра всегда покрывает область данных целиком, и за простоту растровой структуры приходится расплачиваться ее неэкономичностью. Поскольку часто данные имеются не на всю территорию, возникает необходимость кодирования ячеек, для которых данные не известны, специальным числом (назовем его условно NODATA_VALUE). Значение этого числа хранится в метаданных растра и позволяет интерпретировать соответствующие ячейки как пустые.\nВ настоящее время для работы с растровыми данными в R используются два пакета: stars и terra. terra является наследником пакета raster, который исторически был основным средством работы с растровыми данными и обладает широким спектром функций растрового анализа. stars — относительно новый, разработан с целью поддержки многомерных данных и более тесного взаимодействия с пакетом sf. В целом можно сказать, что пакеты terra и stars частично пересекаются по функциональности, но скорее дополняют друг друга, нежели дублируют.\nВ этой и ближайших лекциях мы будем работать с растрами в формате stars, поскольку он концептуально близок к пакету sf.\n\n\n9.4.2 Чтение\nДля чтения растров любой размерности можно использовать функцию read_stars():\n\ndem = read_stars('data/world/gebco.tif') # Цифровая модель рельефа\ndem\n## stars object with 2 dimensions and 1 attribute\n## attribute(s):\n##              Min. 1st Qu. Median      Mean 3rd Qu. Max.\n## gebco.tif  -10348   -4287  -2458 -1890.525     215 6581\n## dimension(s):\n##   from  to offset delta refsys point x/y\n## x    1 900   -180   0.4 WGS 84 FALSE [x]\n## y    1 450     90  -0.4 WGS 84 FALSE [y]\n\nimg = read_stars('data/world/BlueMarbleJuly.tif') # Цветной космический снимок (RGB)\nimg\n## stars object with 3 dimensions and 1 attribute\n## attribute(s):\n##                     Min. 1st Qu. Median     Mean 3rd Qu. Max.\n## BlueMarbleJuly.tif     1      13     33 63.13569      75  255\n## dimension(s):\n##      from  to offset delta refsys point x/y\n## x       1 720   -180   0.5 WGS 84 FALSE [x]\n## y       1 360     90  -0.5 WGS 84 FALSE [y]\n## band    1   3     NA    NA     NA    NA\n\n\n\n9.4.3 Внутренняя структура\nДля работы с данными типа stars необходимо понимать их внутреннюю структуру. Для начала можно взглянуть на нее посредством стандартной функции str():\n\nstr(img)\n## List of 1\n##  $ BlueMarbleJuly.tif: num [1:720, 1:360, 1:3] 6 4 7 7 7 7 7 8 8 8 ...\n##  - attr(*, \"dimensions\")=List of 3\n##   ..$ x   :List of 7\n##   .. ..$ from  : num 1\n##   .. ..$ to    : num 720\n##   .. ..$ offset: num -180\n##   .. ..$ delta : num 0.5\n##   .. ..$ refsys:List of 2\n##   .. .. ..$ input: chr \"WGS 84\"\n##   .. .. ..$ wkt  : chr \"GEOGCRS[\\\"WGS 84\\\",\\n    ENSEMBLE[\\\"World Geodetic System 1984 ensemble\\\",\\n        MEMBER[\\\"World Geodetic Sys\"| __truncated__\n##   .. .. ..- attr(*, \"class\")= chr \"crs\"\n##   .. ..$ point : logi FALSE\n##   .. ..$ values: NULL\n##   .. ..- attr(*, \"class\")= chr \"dimension\"\n##   ..$ y   :List of 7\n##   .. ..$ from  : num 1\n##   .. ..$ to    : num 360\n##   .. ..$ offset: num 90\n##   .. ..$ delta : num -0.5\n##   .. ..$ refsys:List of 2\n##   .. .. ..$ input: chr \"WGS 84\"\n##   .. .. ..$ wkt  : chr \"GEOGCRS[\\\"WGS 84\\\",\\n    ENSEMBLE[\\\"World Geodetic System 1984 ensemble\\\",\\n        MEMBER[\\\"World Geodetic Sys\"| __truncated__\n##   .. .. ..- attr(*, \"class\")= chr \"crs\"\n##   .. ..$ point : logi FALSE\n##   .. ..$ values: NULL\n##   .. ..- attr(*, \"class\")= chr \"dimension\"\n##   ..$ band:List of 7\n##   .. ..$ from  : num 1\n##   .. ..$ to    : int 3\n##   .. ..$ offset: num NA\n##   .. ..$ delta : num NA\n##   .. ..$ refsys: chr NA\n##   .. ..$ point : logi NA\n##   .. ..$ values: NULL\n##   .. ..- attr(*, \"class\")= chr \"dimension\"\n##   ..- attr(*, \"raster\")=List of 4\n##   .. ..$ affine     : num [1:2] 0 0\n##   .. ..$ dimensions : chr [1:2] \"x\" \"y\"\n##   .. ..$ curvilinear: logi FALSE\n##   .. ..$ blocksizes : int [1:3, 1:2] 720 720 720 1 1 1\n##   .. .. ..- attr(*, \"dimnames\")=List of 2\n##   .. .. .. ..$ : NULL\n##   .. .. .. ..$ : chr [1:2] \"x\" \"y\"\n##   .. ..- attr(*, \"class\")= chr \"stars_raster\"\n##   ..- attr(*, \"class\")= chr \"dimensions\"\n##  - attr(*, \"class\")= chr \"stars\"\n\nВидно, что данный трёхканальный растр представляет собой список из единственного элемента с названием BlueMarbleJuly.tif — это имя было присвоено автоматически при чтении растра. Каждый такой элемент соответствует переменной данных. В данном случае переменная одна — это интенсивность цвета. Хранится она в виде трехмерного массива (array) размерностью \\(720 \\times 360 \\times 3\\):\n\nstr(img[[1]])\n##  num [1:720, 1:360, 1:3] 6 4 7 7 7 7 7 8 8 8 ...\nimg[[1]][100, 200, 2]\n## [1] 14\n\nКаждой оси этого массива соответствует измерение (dimension), которое определяет параметры отображения индексов массива на соответствующую систему координат (пространственную, временную, спектральную и т.д.). Например, чтобы понять, что ячейка растра с индексами [36, 18, ] имеет географические координаты (широту и долготу) (0, 0), нужно знать направления осей растра, размер ячейки и координаты одной из угловых ячеек растра. Необходимая информация находится в атрибуте dimensions объекта stars, т.е. является общей для всех переменных. При печати параметры измерений выводятся в удобном табличном виде:\n\nattr(img, 'dimensions')\n##      from  to offset delta refsys point x/y\n## x       1 720   -180   0.5 WGS 84 FALSE [x]\n## y       1 360     90  -0.5 WGS 84 FALSE [y]\n## band    1   3     NA    NA     NA    NA\n\nЭтот атрибут представляет собой список, длина которого равна количеству измерений в массиве данных переменной. Обычно измерения имеют имена, в данном случае это x, y и band. Описание каждого измерения выполнено по единому шаблону, который включает следующие параметры:\n\nfrom: начальный индекс (будет меняться при обрезке растра при постоянной точке отсчета индексов);\nto: конечный индекс (будет меняться при обрезке растра при постоянной точке отсчета индексов);\noffset: координата первого пиксела (точки отсчета);\ndelta: размер ячейки;\nrefsys: координатная (референцная) система: для систем счета координат, времени, высот и других измерений будет своя;\npoint: логическое значение, которое указывает, следует ли интерпретировать элементы растра по этой оси как измеренные в точке (мгновенные) или агрегированные по площади (за временной период);\nvalues: значения координат ячеек по данной оси\n\nNULL (используется в большинстве случаев, т.к. координаты могут быть вычислены на основе from, delta и индекса пиксела),\nвектор координат (используется для представления ректилинейных растров в переменным размром пиксела),\nобъект класса intervals (список из двух векторов — начал и концов интервалов), or\nматрица координат такой же размерности, что и пространственные измерения растра. В случае стекущего примера будет иметь размер \\(720 \\times 360\\). Используется для представления криволинейных растров.\n\n\nНапример, посмотрим параметры измерения x растра:\n\nattr(img, 'dimensions')[['x']]\n## $from\n## [1] 1\n## \n## $to\n## [1] 720\n## \n## $offset\n## [1] -180\n## \n## $delta\n## [1] 0.5\n## \n## $refsys\n## Coordinate Reference System:\n##   User input: WGS 84 \n##   wkt:\n## GEOGCRS[\"WGS 84\",\n##     ENSEMBLE[\"World Geodetic System 1984 ensemble\",\n##         MEMBER[\"World Geodetic System 1984 (Transit)\"],\n##         MEMBER[\"World Geodetic System 1984 (G730)\"],\n##         MEMBER[\"World Geodetic System 1984 (G873)\"],\n##         MEMBER[\"World Geodetic System 1984 (G1150)\"],\n##         MEMBER[\"World Geodetic System 1984 (G1674)\"],\n##         MEMBER[\"World Geodetic System 1984 (G1762)\"],\n##         MEMBER[\"World Geodetic System 1984 (G2139)\"],\n##         ELLIPSOID[\"WGS 84\",6378137,298.257223563,\n##             LENGTHUNIT[\"metre\",1]],\n##         ENSEMBLEACCURACY[2.0]],\n##     PRIMEM[\"Greenwich\",0,\n##         ANGLEUNIT[\"degree\",0.0174532925199433]],\n##     CS[ellipsoidal,2],\n##         AXIS[\"geodetic latitude (Lat)\",north,\n##             ORDER[1],\n##             ANGLEUNIT[\"degree\",0.0174532925199433]],\n##         AXIS[\"geodetic longitude (Lon)\",east,\n##             ORDER[2],\n##             ANGLEUNIT[\"degree\",0.0174532925199433]],\n##     USAGE[\n##         SCOPE[\"Horizontal component of 3D system.\"],\n##         AREA[\"World.\"],\n##         BBOX[-90,-180,90,180]],\n##     ID[\"EPSG\",4326]]\n## \n## $point\n## [1] FALSE\n## \n## $values\n## NULL\n## \n## attr(,\"class\")\n## [1] \"dimension\"\n\nНаконец, дополнительно к этому атрибут dimensions имеет свой собственный атрибут raster, который необходим для того чтобы определить какие именно измерения растра являются пространственными, а также установить преобразования, которые будут над ними производиться при анализе или визулизации:\n\nimg |&gt; attr('dimensions') |&gt; attr('raster') |&gt; str()\n## List of 4\n##  $ affine     : num [1:2] 0 0\n##  $ dimensions : chr [1:2] \"x\" \"y\"\n##  $ curvilinear: logi FALSE\n##  $ blocksizes : int [1:3, 1:2] 720 720 720 1 1 1\n##   ..- attr(*, \"dimnames\")=List of 2\n##   .. ..$ : NULL\n##   .. ..$ : chr [1:2] \"x\" \"y\"\n##  - attr(*, \"class\")= chr \"stars_raster\"\n\nВидно, что атрибут raster содержит 3 элемента:\n\ndimensions: названия измерений, которые являются пространственными\naffine: параметры аффинного преобразования, которое будет применяться к пространственным измерениям перед их отображением или применением в операциях пространственного анализа\ncurvilinear: логическое значение, которое устанавливает, является ли растр криволинейным (в этом случае в параметре values пространственных измерений должна быть матрица координат)\n\n\n\n9.4.4 Визуализация\n\n9.4.4.1 Статичные карты\nДля визуализации одноканальных растров используется функция plot(). В простейшем виде ей достаточно просто передать визуализируемый растр:\n\npar(mfrow = c(1,1))\nplot(dem)\n\n\n\n\n\n\n\n\nПоскольку растры часто используют в классифицированном виде, вы можете сформировать вектор граничных значений классов, вектор цветов классов, и передать их в параметры breaks и col функции plot() соответственно. Если параметр breaks не определять, то весь диапазон значений растра будет разбит на равные интервалы соответственно количеству цветов. Если не определять параметр col, то будет применена стандартная палитра terrain.colors. Вы также можете использовать одну из готовых палитр цветов или создать ее вручную (см. посвященную графической подсистеме R):\n\nbrks = c(-12000, -5000, -2500, -1000, -200, 0, 200, 500, 1000, 2000, 4000, 8000)\nclrs = c(\n  \"steelblue4\",\n  \"steelblue3\",\n  \"steelblue2\",\n  \"steelblue1\",\n  \"lightskyblue1\",\n  \"darkseagreen\",\n  \"lightgoldenrod1\",\n  \"darkgoldenrod1\",\n  \"darkorange\",\n  \"coral2\",\n  \"firebrick3\")\n\nplot(dem, breaks = brks, col = clrs)\n\n\n\n\n\n\n\n\nplot(dem, col = colorRampPalette(c(\"black\", \"white\"))(255))\n\n\n\n\n\n\n\n\nplot(dem, col = rainbow(10))\n\n\n\n\n\n\n\n\nДля синтезирования цветного изображения на основе многоканального растра необходимо объект stars предварительно подать в функцию st_rgb():\n\nplot(st_rgb(img))\n\n\n\n\n\n\n\n\nПоскольку при визуализации космических снимков часто используют различные варианты синтеза каналов (чтобы лучше дешифрировать те или иные категории объектов), функция st_rgb() предоставляет такую возможность. Достаточно перечислить последовательность каналов растрового стека (по умолчанию эти каналы будут подставлены в каналы R, G и B соответственно):\n\nst_rgb(img[,,,c(1, 2, 3)]) |&gt; plot()\n\n\n\n\n\n\n\nst_rgb(img[,,,c(1, 3, 2)]) |&gt; plot()\n\n\n\n\n\n\n\nst_rgb(img[,,,c(2, 1, 3)]) |&gt; plot()\n\n\n\n\n\n\n\nst_rgb(img[,,,c(2, 3, 1)]) |&gt; plot()\n\n\n\n\n\n\n\nst_rgb(img[,,,c(3, 1, 2)]) |&gt; plot()\n\n\n\n\n\n\n\nst_rgb(img[,,,c(3, 2, 1)]) |&gt; plot()\n\n\n\n\n\n\n\n\nВы можете совмещать на картах несколько растровых и векторных слоев точно так же как и при совмещении векторных данных (указав параметр add = TRUE при вызове функции plot()):\n\nplot(st_rgb(img), reset = FALSE)\nplot(outlines, border = rgb(1,1,1,0.5), lwd = 0.5, add = TRUE)\n\n\n\n\n\n\n\n\n\n\n9.4.4.2 Интерактивные карты\nОбъекты типа stars могут быть визуализированы аналогично векторным на интерактивных картах mapview:\n\nmapview(dem, at = brks, col = clrs)\n\n\n\n\n\n\n\n\n\n\n\n\n\n9.4.5 Обрезка\nОдна из распространенных задач при работе с растрами — это обрезка, то есть удаление растровых данных, находящихся за пределами указанной территории. Чаще всего обрезку делают либо ограничивающим прямоугольником, либо полигональным объектом. Рассмотрим оба варианта:\n\n# Обрезка по ограничивающему прямоугольнику\nbox = st_bbox(c(xmin = -80, xmax = -10, ymax = 85, ymin = 58), crs = st_crs(4326))\ndem_greenland = dem[box]\n\ndem_greenland\n## stars object with 2 dimensions and 1 attribute\n## attribute(s):\n##             Min. 1st Qu. Median     Mean 3rd Qu. Max.\n## gebco.tif  -4041    -811    -49 70.50328 1187.25 3228\n## dimension(s):\n##   from  to offset delta refsys point x/y\n## x  251 425   -180   0.4 WGS 84 FALSE [x]\n## y   13  80     90  -0.4 WGS 84 FALSE [y]\n\nplot(dem_greenland)\n\n\n\n\n\n\n\n\nАналогичным образом можено обрезать растр контуром выбранной страны:\n\ncountry = countries |&gt; \n  filter(name == 'Afghanistan')\ndem_country = dem[country]\ndem_country\n## stars object with 2 dimensions and 1 attribute\n## attribute(s):\n##            Min. 1st Qu. Median     Mean 3rd Qu. Max. NA's\n## gebco.tif   261   877.5   1628 1824.854    2635 5036  485\n## dimension(s):\n##   from  to offset delta refsys point x/y\n## x  602 638   -180   0.4 WGS 84 FALSE [x]\n## y  129 152     90  -0.4 WGS 84 FALSE [y]\nplot(dem_country)\n\n\n\n\n\n\n\n\n\n\n9.4.6 Индексирование\nОртогональная структура объектов типа stars позволяет выполнять по ним различные срезы, отсекая ненужные данные. Для этого используется привычный по работе с векторами оператор квадратной скобки [, который работает следующим образом:\n\nпервый аргумент выбирает атрибут\nвторой и последующий аргументы выбирают измерения.\n\nТаким образом, при работе с растрами, которые содержат один атрибут, вам необходимо указать 4 индекса: [var, x, y, band], где var - это название или порядковый номер атрибута, а x, y, band — порядковые номера двух координатных и одного семантического измерения.\nНапример:\n\n# выбрать 1 канал\nch1 = img[,,,1] \nch1\n## stars object with 3 dimensions and 1 attribute\n## attribute(s):\n##                     Min. 1st Qu. Median    Mean 3rd Qu. Max.\n## BlueMarbleJuly.tif     1       5     14 51.1141      47  255\n## dimension(s):\n##      from  to offset delta refsys point x/y\n## x       1 720   -180   0.5 WGS 84 FALSE [x]\n## y       1 360     90  -0.5 WGS 84 FALSE [y]\n## band    1   1     NA    NA     NA    NA\nplot(ch1)\n\n\n\n\n\n\n\n\n# выбрать диапазон ячеек растра\nfrag = img[, 320:470, 100:255, ] \nfrag\n## stars object with 3 dimensions and 1 attribute\n## attribute(s):\n##                     Min. 1st Qu. Median     Mean 3rd Qu. Max.\n## BlueMarbleJuly.tif     1      20     50 65.96065     106  221\n## dimension(s):\n##      from  to offset delta refsys point x/y\n## x     320 470   -180   0.5 WGS 84 FALSE [x]\n## y     100 255     90  -0.5 WGS 84 FALSE [y]\n## band    1   3     NA    NA     NA    NA\nplot(st_rgb(frag))\n\n\n\n\n\n\n\n\n\n\n9.4.7 Манипуляции\nОбъекты типа stars поддерживают манипуляции, аналогичные тем, что могут применяться к векторным данным. Посмотрим это на примере данных по высоте земной поверхности с учетом и без покровного оледенения:\n\netopo = read_stars(c('data/etopo1_bed.tif', 'data/etopo1_ice.tif'))\netopo\n## stars object with 2 dimensions and 2 attributes\n## attribute(s):\n##        Min. 1st Qu.  Median      Mean 3rd Qu. Max.\n## bed  -10632   -4287 -2451.5 -2113.199      86 6159\n## ice  -10632   -4287 -2451.5 -1892.726     215 6159\n## dimension(s):\n##   from  to offset delta refsys point x/y\n## x    1 720   -180   0.5 WGS 84 FALSE [x]\n## y    1 360     90  -0.5 WGS 84 FALSE [y]\n\nДля начала переименуем переменные:\n\netopo = etopo |&gt; setNames(c('bed', 'ice'))\netopo\n## stars object with 2 dimensions and 2 attributes\n## attribute(s):\n##        Min. 1st Qu.  Median      Mean 3rd Qu. Max.\n## bed  -10632   -4287 -2451.5 -2113.199      86 6159\n## ice  -10632   -4287 -2451.5 -1892.726     215 6159\n## dimension(s):\n##   from  to offset delta refsys point x/y\n## x    1 720   -180   0.5 WGS 84 FALSE [x]\n## y    1 360     90  -0.5 WGS 84 FALSE [y]\n\nПосле этого посчитаем, например, толщину покровного оледеления как разность ice и bed через мутирование:\n\netopo = etopo |&gt;\n  mutate(depth = ice - bed)\n\nplot(etopo['depth'], \n     col = cm.colors(5),\n     breaks = c(0, 500, 1000, 2000, 3000, 4000),\n     main = 'Мощность покровного оледенения',\n     reset = FALSE)\nplot(oceans, col = 'steelblue', add = TRUE)\n\n\n\n\n\n\n\n\nФильтрация происходит по измерениям, но применяется не к индексам ячеек, а к соответствующим величинам измерений:\n\ngreenland = etopo |&gt; \n  filter(x &gt; -80, x &lt; -10, y &gt; 58, y &lt; 85)\n\nplot(greenland)\n\n\n\n\n\n\n\n\nВыбор переменной позволяет оставить только ее:\n\nicedepth = etopo |&gt; \n  select(depth)\n\nicedepth\n## stars object with 2 dimensions and 1 attribute\n## attribute(s):\n##        Min. 1st Qu. Median     Mean 3rd Qu. Max.\n## depth  -198       0      0 220.4736       0 4286\n## dimension(s):\n##   from  to offset delta refsys point x/y\n## x    1 720   -180   0.5 WGS 84 FALSE [x]\n## y    1 360     90  -0.5 WGS 84 FALSE [y]\n\n\n\n9.4.8 Экспорт\nЧтобы экспортировать (сохранить в файл) любой растр, можно воспользоваться функцией write_stars(), указав имя выходного файла:\n\nwrite_stars(greenland, 'data/world/greenland.tif')",
    "crumbs": [
      "Пространственные данные и карты",
      "<span class='chapter-number'>9</span>  <span class='chapter-title'>Пространственные данные</span>"
    ]
  },
  {
    "objectID": "09-SpatialData.html#spatref",
    "href": "09-SpatialData.html#spatref",
    "title": "9  Пространственные данные",
    "section": "9.5 Пространственная привязка",
    "text": "9.5 Пространственная привязка\n\n9.5.1 Компоненты пространственной привязки\nПространственная привязка (spatial reference или georeference) — важнейшая составляющая пространственных данных, которая говорит нам о том, как правильно интерпретировать координаты объектов. Пространственная привязка в простейшем случае включает несколько фундаментальных компонент:\n\nЭллипсоид вращения — тело, по отношению к которому вычисляются геодезические координаты точек (широты и долготы)\nИсходные геодезические даты (датум) — параметры положения эллипсоида в теле Земли\nГеографическая система координат — включает датум, положение начального меридиана и единицы измерения широт и долгот\nПроекция — математический способ перехода от географических координат на эллипсоиде к плоским прямоугольным координатам карты.\nПлоская прямоугольная система координат — включает проекцию, ее параметры и единицы измерения координат.\n\nЕсли точки имеют также координаты \\(Z\\), то для их правильной интерпретации необходимы дополнительные компоненты пространственной привязки:\n\nСистема счета высот (геодезические, нормальные, ортометрические) - определяют содержательный смысл и порядок вычисления высот и глубин (координата Z)\nМодель геоида, квазигеоида или эллипсоида — определяет поверхность, относительно которой вычисляются высоты точек.\nВертикальная система координат — фактическая реализация системы счета высот относительно конкретной поверхности относимости с заданным положением нулевого уровня. Например, в России это Балтийская система нормальных высот с нулем в г. Кронштадт.\n\nАналогичным образом требуется введение системы счета дополнительных координат \\(M\\), если они используются в представлении координат.\n\n\n9.5.2 Форматы описания пространственной привязки\nСуществует три распространенных способа задания (хранения) пространственной привязки:\n\nPROJ.4 String — представление в виде строки.\nWKT (Well-Known Text) — представление в виде иерархического списка. Это наиболее полный формат описания пространственной привязки, который рекомендуется к использованию для избежания неоднозначностей.\nEPSG (European Petroleum Survey Group) — представление в виде числового кода.\n\nДля поиска проекций в перечисленных форматах представления удобно воспользоваться порталом spatialreference.org.\nPROJ.4 String — строковый формат представления информации о пространственной привязки, используемый в библиотеке PROJ. Данная библиотека лежит в основе координатных систем пространственных данных, используется в R, Python, QGIS и прочих средах. Основные параметры строки:\n+datum     Datum name (see `proj -ld`)\n+ellps     Ellipsoid name (see `proj -le`)\n+lat_0     Latitude of origin\n+lat_1     Latitude of first standard parallel\n+lat_2     Latitude of second standard parallel\n+lat_ts    Latitude of true scale\n+lon_0     Central meridian\n+proj      Projection name (see `proj -l`)\n+units     meters, US survey feet, etc.\n+vunits    vertical units.\n+x_0       False easting\n+y_0       False northing\n+zone      UTM zone\nПримеры записи координат в формате PROJ.4:\n\nГеографические координаты в WGS84 (без проекции):\n\n\nКоординаты в проекции Web Mercator (проекция Google Maps, Яндекс.Карт и т.д.):\n\n\nКоординаты в конической равнопромежуточной проекции:\n\n\nКоординаты в проекции UTM, зона 37:\n\nWKT предполагает представление вышеуказанных компонент пространственной привязки к виде иерархического списка. Например, так будет выглядеть информация о полярной стереографической проекции для карт России:\nPROJCS[\"WGS 84 / EPSG Russia Polar Stereographic\",\n    GEOGCS[\"WGS 84\",\n        DATUM[\"WGS_1984\",\n            SPHEROID[\"WGS 84\",6378137,298.257223563,\n                AUTHORITY[\"EPSG\",\"7030\"]],\n            AUTHORITY[\"EPSG\",\"6326\"]],\n        PRIMEM[\"Greenwich\",0,\n            AUTHORITY[\"EPSG\",\"8901\"]],\n        UNIT[\"degree\",0.0174532925199433,\n            AUTHORITY[\"EPSG\",\"9122\"]],\n        AUTHORITY[\"EPSG\",\"4326\"]],\n    PROJECTION[\"Polar_Stereographic\"],\n    PARAMETER[\"latitude_of_origin\",90],\n    PARAMETER[\"central_meridian\",105],\n    PARAMETER[\"scale_factor\",0.994],\n    PARAMETER[\"false_easting\",2000000],\n    PARAMETER[\"false_northing\",2000000],\n    UNIT[\"metre\",1,\n        AUTHORITY[\"EPSG\",\"9001\"]],\n    AXIS[\"X\",EAST],\n    AXIS[\"Y\",NORTH],\n    AUTHORITY[\"EPSG\",\"5940\"]]\nEPSG (European Petroleum Survey Group) — европейская рабочая группа нефтегазовой области, которая ведет реестр систем координат с уникальными цифровыми кодами вида EPSG:xxxxxx. Коды EPSG оказались настолько удобны, что используются повсеместно для быстрой инициализации проекций со стандартными параметрами. Например, вышеприведенные проекции имеют следующие коды EPSG:\n\nWGS84: EPSG:4326\nWeb Mercator: EPSG:3857\nUTM: EPSG:326.. , например для UTM 37N: EPSG:32637\n\n\n\n9.5.3 Преобразование координат\nПреобразование координат включает три различных операции:\n\nТрансформирование — пересчет географических координат с одного датума на другой\nПроецирование — переход от географических координат к плоским прямоугольным\nОбратное проецирование — переход от плоских координат к географическим.\n\nНапример, чтобы пересчитать координаты UTM в проекцию Гаусса-Крюгера, необходимо:\n\nОбратно проецировать координаты в географические WGS84\nТрансформировать географические координаты c WGS84 в ГСК-2011\nПроецировать координаты ГСК-2011 в проекцию Гаусса-Крюгера\n\nНесоответствие датумов часто является причиной того, что данные из разных наборов плохо совмещаются друг с другом\n\n\n9.5.4 Работа с пространственной привязкой в R\nРабота с пространственной привязкой данных в R состоит в основном из четырех операций:\n\nчтение информации о системе координат\nсоздание информации о системе координат\nзамена информации о системе координат\nизменение системы координат (проецирование)\n\nПервые три операции (чтение, создание, замена) осуществляются функцией st_crs(). Чтобы прочитать информацию о проекции, достаточно передать в качестве параметра объект типа sf:\n\nst_crs(countries)    # Координатная система\n## Coordinate Reference System:\n##   User input: WGS 84 \n##   wkt:\n## GEOGCRS[\"WGS 84\",\n##     ENSEMBLE[\"World Geodetic System 1984 ensemble\",\n##         MEMBER[\"World Geodetic System 1984 (Transit)\"],\n##         MEMBER[\"World Geodetic System 1984 (G730)\"],\n##         MEMBER[\"World Geodetic System 1984 (G873)\"],\n##         MEMBER[\"World Geodetic System 1984 (G1150)\"],\n##         MEMBER[\"World Geodetic System 1984 (G1674)\"],\n##         MEMBER[\"World Geodetic System 1984 (G1762)\"],\n##         MEMBER[\"World Geodetic System 1984 (G2139)\"],\n##         ELLIPSOID[\"WGS 84\",6378137,298.257223563,\n##             LENGTHUNIT[\"metre\",1]],\n##         ENSEMBLEACCURACY[2.0]],\n##     PRIMEM[\"Greenwich\",0,\n##         ANGLEUNIT[\"degree\",0.0174532925199433]],\n##     CS[ellipsoidal,2],\n##         AXIS[\"geodetic latitude (Lat)\",north,\n##             ORDER[1],\n##             ANGLEUNIT[\"degree\",0.0174532925199433]],\n##         AXIS[\"geodetic longitude (Lon)\",east,\n##             ORDER[2],\n##             ANGLEUNIT[\"degree\",0.0174532925199433]],\n##     USAGE[\n##         SCOPE[\"Horizontal component of 3D system.\"],\n##         AREA[\"World.\"],\n##         BBOX[-90,-180,90,180]],\n##     ID[\"EPSG\",4326]]\n\nЭта же функция позволяет создать новую координатную систему, путем передачи ей кода EPSG или строки PROJ.4:\n\nst_crs(3857) # Проекция Меркатора для карт мира\n## Coordinate Reference System:\n##   User input: EPSG:3857 \n##   wkt:\n## PROJCRS[\"WGS 84 / Pseudo-Mercator\",\n##     BASEGEOGCRS[\"WGS 84\",\n##         ENSEMBLE[\"World Geodetic System 1984 ensemble\",\n##             MEMBER[\"World Geodetic System 1984 (Transit)\"],\n##             MEMBER[\"World Geodetic System 1984 (G730)\"],\n##             MEMBER[\"World Geodetic System 1984 (G873)\"],\n##             MEMBER[\"World Geodetic System 1984 (G1150)\"],\n##             MEMBER[\"World Geodetic System 1984 (G1674)\"],\n##             MEMBER[\"World Geodetic System 1984 (G1762)\"],\n##             MEMBER[\"World Geodetic System 1984 (G2139)\"],\n##             ELLIPSOID[\"WGS 84\",6378137,298.257223563,\n##                 LENGTHUNIT[\"metre\",1]],\n##             ENSEMBLEACCURACY[2.0]],\n##         PRIMEM[\"Greenwich\",0,\n##             ANGLEUNIT[\"degree\",0.0174532925199433]],\n##         ID[\"EPSG\",4326]],\n##     CONVERSION[\"Popular Visualisation Pseudo-Mercator\",\n##         METHOD[\"Popular Visualisation Pseudo Mercator\",\n##             ID[\"EPSG\",1024]],\n##         PARAMETER[\"Latitude of natural origin\",0,\n##             ANGLEUNIT[\"degree\",0.0174532925199433],\n##             ID[\"EPSG\",8801]],\n##         PARAMETER[\"Longitude of natural origin\",0,\n##             ANGLEUNIT[\"degree\",0.0174532925199433],\n##             ID[\"EPSG\",8802]],\n##         PARAMETER[\"False easting\",0,\n##             LENGTHUNIT[\"metre\",1],\n##             ID[\"EPSG\",8806]],\n##         PARAMETER[\"False northing\",0,\n##             LENGTHUNIT[\"metre\",1],\n##             ID[\"EPSG\",8807]]],\n##     CS[Cartesian,2],\n##         AXIS[\"easting (X)\",east,\n##             ORDER[1],\n##             LENGTHUNIT[\"metre\",1]],\n##         AXIS[\"northing (Y)\",north,\n##             ORDER[2],\n##             LENGTHUNIT[\"metre\",1]],\n##     USAGE[\n##         SCOPE[\"Web mapping and visualisation.\"],\n##         AREA[\"World between 85.06°S and 85.06°N.\"],\n##         BBOX[-85.06,-180,85.06,180]],\n##     ID[\"EPSG\",3857]]\nst_crs('+proj=robin') # Проекция Робинсона для карт мира\n## Coordinate Reference System:\n##   User input: +proj=robin \n##   wkt:\n## PROJCRS[\"unknown\",\n##     BASEGEOGCRS[\"unknown\",\n##         DATUM[\"World Geodetic System 1984\",\n##             ELLIPSOID[\"WGS 84\",6378137,298.257223563,\n##                 LENGTHUNIT[\"metre\",1]],\n##             ID[\"EPSG\",6326]],\n##         PRIMEM[\"Greenwich\",0,\n##             ANGLEUNIT[\"degree\",0.0174532925199433],\n##             ID[\"EPSG\",8901]]],\n##     CONVERSION[\"unknown\",\n##         METHOD[\"Robinson\"],\n##         PARAMETER[\"Longitude of natural origin\",0,\n##             ANGLEUNIT[\"degree\",0.0174532925199433],\n##             ID[\"EPSG\",8802]],\n##         PARAMETER[\"False easting\",0,\n##             LENGTHUNIT[\"metre\",1],\n##             ID[\"EPSG\",8806]],\n##         PARAMETER[\"False northing\",0,\n##             LENGTHUNIT[\"metre\",1],\n##             ID[\"EPSG\",8807]]],\n##     CS[Cartesian,2],\n##         AXIS[\"(E)\",east,\n##             ORDER[1],\n##             LENGTHUNIT[\"metre\",1,\n##                 ID[\"EPSG\",9001]]],\n##         AXIS[\"(N)\",north,\n##             ORDER[2],\n##             LENGTHUNIT[\"metre\",1,\n##                 ID[\"EPSG\",9001]]]]\n\n# Проекция UTM, зона 37.\nst_crs('+proj=utm +zone=37 +datum=WGS84 +units=m')\n## Coordinate Reference System:\n##   User input: +proj=utm +zone=37 +datum=WGS84 +units=m \n##   wkt:\n## PROJCRS[\"unknown\",\n##     BASEGEOGCRS[\"unknown\",\n##         DATUM[\"World Geodetic System 1984\",\n##             ELLIPSOID[\"WGS 84\",6378137,298.257223563,\n##                 LENGTHUNIT[\"metre\",1]],\n##             ID[\"EPSG\",6326]],\n##         PRIMEM[\"Greenwich\",0,\n##             ANGLEUNIT[\"degree\",0.0174532925199433],\n##             ID[\"EPSG\",8901]]],\n##     CONVERSION[\"UTM zone 37N\",\n##         METHOD[\"Transverse Mercator\",\n##             ID[\"EPSG\",9807]],\n##         PARAMETER[\"Latitude of natural origin\",0,\n##             ANGLEUNIT[\"degree\",0.0174532925199433],\n##             ID[\"EPSG\",8801]],\n##         PARAMETER[\"Longitude of natural origin\",39,\n##             ANGLEUNIT[\"degree\",0.0174532925199433],\n##             ID[\"EPSG\",8802]],\n##         PARAMETER[\"Scale factor at natural origin\",0.9996,\n##             SCALEUNIT[\"unity\",1],\n##             ID[\"EPSG\",8805]],\n##         PARAMETER[\"False easting\",500000,\n##             LENGTHUNIT[\"metre\",1],\n##             ID[\"EPSG\",8806]],\n##         PARAMETER[\"False northing\",0,\n##             LENGTHUNIT[\"metre\",1],\n##             ID[\"EPSG\",8807]],\n##         ID[\"EPSG\",16037]],\n##     CS[Cartesian,2],\n##         AXIS[\"(E)\",east,\n##             ORDER[1],\n##             LENGTHUNIT[\"metre\",1,\n##                 ID[\"EPSG\",9001]]],\n##         AXIS[\"(N)\",north,\n##             ORDER[2],\n##             LENGTHUNIT[\"metre\",1,\n##                 ID[\"EPSG\",9001]]]]\n\nЗамена координатной системы требуется в тех случаях, когда слой не имеет пространственной привязки, или же она задана некорректно. В этом случае необходимо вызвать для слоя функцию st_crs() и перезаписать результат.\n\nst_crs(countries) = NA\nst_crs(countries) \n## Coordinate Reference System: NA\n\nst_crs(countries) = st_crs(4326)\nst_crs(countries)\n## Coordinate Reference System:\n##   User input: EPSG:4326 \n##   wkt:\n## GEOGCRS[\"WGS 84\",\n##     ENSEMBLE[\"World Geodetic System 1984 ensemble\",\n##         MEMBER[\"World Geodetic System 1984 (Transit)\"],\n##         MEMBER[\"World Geodetic System 1984 (G730)\"],\n##         MEMBER[\"World Geodetic System 1984 (G873)\"],\n##         MEMBER[\"World Geodetic System 1984 (G1150)\"],\n##         MEMBER[\"World Geodetic System 1984 (G1674)\"],\n##         MEMBER[\"World Geodetic System 1984 (G1762)\"],\n##         MEMBER[\"World Geodetic System 1984 (G2139)\"],\n##         ELLIPSOID[\"WGS 84\",6378137,298.257223563,\n##             LENGTHUNIT[\"metre\",1]],\n##         ENSEMBLEACCURACY[2.0]],\n##     PRIMEM[\"Greenwich\",0,\n##         ANGLEUNIT[\"degree\",0.0174532925199433]],\n##     CS[ellipsoidal,2],\n##         AXIS[\"geodetic latitude (Lat)\",north,\n##             ORDER[1],\n##             ANGLEUNIT[\"degree\",0.0174532925199433]],\n##         AXIS[\"geodetic longitude (Lon)\",east,\n##             ORDER[2],\n##             ANGLEUNIT[\"degree\",0.0174532925199433]],\n##     USAGE[\n##         SCOPE[\"Horizontal component of 3D system.\"],\n##         AREA[\"World.\"],\n##         BBOX[-90,-180,90,180]],\n##     ID[\"EPSG\",4326]]\n\n\nВнимание: замена координатной системы не осуществляет перепроецирования данных и не меняет координаты точек. Она лишь влияет на то, как эти координаты будут интерпретироваться. Если вместо проецирования выполнить замену информации о координатной системе, данные будут позиционироваться в неправильном месте.\n\nДля проецирования данных в другую систему координат следует использовать функцию st_tranform(x, crs). Данная функция принимает в качестве параметров класс объектов sf и координатную систему, в которую необходимо проецировать данные.\n\n# Проекция Меркатора\ncountries_merc = st_transform(countries, 3857)\npar(mar = c(2,16,2,16))\nplot(st_geometry(countries_merc), \n     col = 'lightgray',\n     lwd = 0.5,\n     graticule = TRUE, \n     axes = TRUE)\n\n\n\n\n\n\n\n\n\n# Проекция Мольвейде (используем dplyr)\ncountries_moll = countries |&gt; st_transform('+proj=moll')\nplot(st_geometry(countries_moll), \n     col = 'lightgray',\n     lwd = 0.5,\n     graticule = TRUE, \n     axes = TRUE)\n\n\n\n\n\n\n\n\n\n# Зарубежная Европа в Конической равнопромежуточной проекции. \n# Задаем только необходимые параметры проекции\ncountries_eqdc = countries |&gt; \n  filter(continent == 'Europe' & sovereignt != 'Russia') |&gt; \n  st_transform('+proj=eqdc +lon_0=10 +lat_1=30 +lat_2=60 +datum=WGS84 +units=m')\n\nplot(st_geometry(countries_eqdc), \n     col = 'lightgray',\n     lwd = 0.5,\n     graticule = TRUE, \n     axes = TRUE)\n\n\n\n\n\n\n\n\nРабота с проекцией растровых данных также предполагает четыре возможных процедуры: чтение, создание, замена и проецирование:\n\nst_crs(dem) # читаем систему координат\n## Coordinate Reference System:\n##   User input: WGS 84 \n##   wkt:\n## GEOGCRS[\"WGS 84\",\n##     ENSEMBLE[\"World Geodetic System 1984 ensemble\",\n##         MEMBER[\"World Geodetic System 1984 (Transit)\"],\n##         MEMBER[\"World Geodetic System 1984 (G730)\"],\n##         MEMBER[\"World Geodetic System 1984 (G873)\"],\n##         MEMBER[\"World Geodetic System 1984 (G1150)\"],\n##         MEMBER[\"World Geodetic System 1984 (G1674)\"],\n##         MEMBER[\"World Geodetic System 1984 (G1762)\"],\n##         MEMBER[\"World Geodetic System 1984 (G2139)\"],\n##         ELLIPSOID[\"WGS 84\",6378137,298.257223563,\n##             LENGTHUNIT[\"metre\",1]],\n##         ENSEMBLEACCURACY[2.0]],\n##     PRIMEM[\"Greenwich\",0,\n##         ANGLEUNIT[\"degree\",0.0174532925199433]],\n##     CS[ellipsoidal,2],\n##         AXIS[\"geodetic latitude (Lat)\",north,\n##             ORDER[1],\n##             ANGLEUNIT[\"degree\",0.0174532925199433]],\n##         AXIS[\"geodetic longitude (Lon)\",east,\n##             ORDER[2],\n##             ANGLEUNIT[\"degree\",0.0174532925199433]],\n##     USAGE[\n##         SCOPE[\"Horizontal component of 3D system.\"],\n##         AREA[\"World.\"],\n##         BBOX[-90,-180,90,180]],\n##     ID[\"EPSG\",4326]]\nst_crs(dem) = NA # очищаем систему координат\nst_crs(dem)\n## Coordinate Reference System: NA\nst_crs(dem) = st_crs(4326) # создаем систему координат\nst_crs(dem)\n## Coordinate Reference System:\n##   User input: EPSG:4326 \n##   wkt:\n## GEOGCRS[\"WGS 84\",\n##     ENSEMBLE[\"World Geodetic System 1984 ensemble\",\n##         MEMBER[\"World Geodetic System 1984 (Transit)\"],\n##         MEMBER[\"World Geodetic System 1984 (G730)\"],\n##         MEMBER[\"World Geodetic System 1984 (G873)\"],\n##         MEMBER[\"World Geodetic System 1984 (G1150)\"],\n##         MEMBER[\"World Geodetic System 1984 (G1674)\"],\n##         MEMBER[\"World Geodetic System 1984 (G1762)\"],\n##         MEMBER[\"World Geodetic System 1984 (G2139)\"],\n##         ELLIPSOID[\"WGS 84\",6378137,298.257223563,\n##             LENGTHUNIT[\"metre\",1]],\n##         ENSEMBLEACCURACY[2.0]],\n##     PRIMEM[\"Greenwich\",0,\n##         ANGLEUNIT[\"degree\",0.0174532925199433]],\n##     CS[ellipsoidal,2],\n##         AXIS[\"geodetic latitude (Lat)\",north,\n##             ORDER[1],\n##             ANGLEUNIT[\"degree\",0.0174532925199433]],\n##         AXIS[\"geodetic longitude (Lon)\",east,\n##             ORDER[2],\n##             ANGLEUNIT[\"degree\",0.0174532925199433]],\n##     USAGE[\n##         SCOPE[\"Horizontal component of 3D system.\"],\n##         AREA[\"World.\"],\n##         BBOX[-90,-180,90,180]],\n##     ID[\"EPSG\",4326]]\n\nДля проецирования растра в новую систему координат необходимо использовать функцию st_warp() Приведем несколько примеров проецирования.\nПроекция Меркатора:\n\nimg_merc = st_warp(img, crs = 3857)\n\nplot(st_rgb(img_merc), main = NULL, reset = FALSE)\nplot(st_geometry(countries_merc), \n     border = rgb(1,1,1,0.5), lwd = 0.25, add = TRUE)\n\n\n\n\n\n\n\n\nПроекция Мольвейде:\n\nimg_moll = st_warp(img, crs = st_crs('+proj=moll'), use_gdal = TRUE)\nplot(st_rgb(img_moll, probs = c(0.01, 0.99),\n       stretch = \"percent\"), main = NULL, reset = FALSE)\nplot(st_geometry(countries_moll), \n     border = rgb(1,1,1,0.5), lwd = 0.5, add = TRUE)\n\n\n\n\n\n\n\n\nПроекция коническая равнопромежуточная:\n\nprj = '+proj=eqdc +lon_0=10 +lat_1=30 +lat_2=60 +datum=WGS84 +units=m'\n\nimg_eqdc = st_warp(\n  img, \n  crs = st_crs(prj)\n)\n\nimg_eqdc_euro = img_eqdc[st_bbox(countries_eqdc)]\n\nplot(st_rgb(img_eqdc_euro), main = NULL, reset = FALSE)\nplot(st_geometry(countries_eqdc), \n     border = rgb(1,1,1,0.5), lwd = 0.5, add = TRUE)\n\n\n\n\n\n\n\n\nБолее подробно вопросы выбора проекций и построения сеток координат рассматриваются в следующей главе.",
    "crumbs": [
      "Пространственные данные и карты",
      "<span class='chapter-number'>9</span>  <span class='chapter-title'>Пространственные данные</span>"
    ]
  },
  {
    "objectID": "09-SpatialData.html#temporal_review",
    "href": "09-SpatialData.html#temporal_review",
    "title": "9  Пространственные данные",
    "section": "9.6 Краткий обзор",
    "text": "9.6 Краткий обзор\nДля просмотра презентации щелкните на ней один раз левой кнопкой мыши и листайте, используя кнопки на клавиатуре:\n\n\n\n\n\nПрезентацию можно открыть в отдельном окне или вкладке браузере. Для этого щелкните по ней правой кнопкой мыши и выберите соответствующую команду.",
    "crumbs": [
      "Пространственные данные и карты",
      "<span class='chapter-number'>9</span>  <span class='chapter-title'>Пространственные данные</span>"
    ]
  },
  {
    "objectID": "09-SpatialData.html#questions_tasks_spatial",
    "href": "09-SpatialData.html#questions_tasks_spatial",
    "title": "9  Пространственные данные",
    "section": "9.7 Контрольные вопросы и упражнения",
    "text": "9.7 Контрольные вопросы и упражнения\n\n9.7.1 Вопросы\n\nЧто такое пространственные данные и какие модели пространственных данных существуют?\nНазовите номер стандарта ISO, в котором описана модель Simple Features.\nПеречислите основные принципы представления объектов в рамках стандарта Simple Features.\nКакие размерности координат допустимы в объектах Simple Features?\nПеречислите основные 7 типов геометрий. Сколько всего их описано в стандарте Simple Features?\nКак называются основные два формата представления объектов Simple Features?\nПеречислите основные компоненты пространственной привязки.\nПеречислите основные форматы описания пространственной привязки.\nДайте расшифровку основных параметров строки PROJ.4.\nКакой номер EPSG имеет географическая система координат WGS84?\nВ чем отличие трансформирования координат и проецирования?\nКакие три программных библиотеки составляют основу функциональности пакета sf? Каково их назначение?\nВ чем отличие объектов типа sp от sf?\nЧто означает префикс st_, используемый в названиях функций пакета sf?\nКакая функция используется для чтения данных средствами пакета sf?\nПеречислите три класса, слагающих иерархию представления пространственных объектов, реализуемую пакетом sf.\nКакой тип данных имеет колонка с геометрией объекта sf?\nКакая функция позволяет извлечь геометрическую колонку из объекта sf?\nС помощью какой структуры данных фактически реализован класс объектов sfg?\nСколько карт будет построено функцией plot() применительно к объекту sf?\nКак с помощью функции plot() нарисовать только геометрию объектов, не отображая атрибутивные характеристики?\nКакой параметр функции plot() отвечает за отображение/не отображение градусной сетки координат?\nКаким способом можно узнать и задать систему координат объекта sf?\nКакая функция позволяет осуществить проецирование данных?\nМожно ли применять к объектам типа sf стандартные манипуляции dplyr?\nЧто произойдет с геометрией пространственных объектов при выполнении агрегирования данных по группам значений заданных атрибутов?\nПеречислите функции, с помощью которых создаются объекты типа sfg, и структуры данных с координатами, которые должны быть поданы на вход этих функций.\nНазовите три правила, которым подчиняется формат представления координат вершин полигональных объектов.\nМожет ли обычный полигон sf содержать дырку, или же для этого требуется создание мультиполигона?\nКак можно быстро собрать слой точечных объектов по их координатам, не собирая объекты вручную?\nКакая функция позволяет осуществлять преобразование типа геометрии sf?\nПеречислите требования, которым должно удовлетворять множество линейных объектов для того, чтобы к нему была применима операция полигонизации?\nНазовите функции sf, реализующие операцию добавления вершин в точках пересечения линий и операцию полигонизации линий.\nПеречислите названия функций sf, позволяющих получать ограничивающий прямоугольник, периметр, площадь, центроид, характерную точку и координаты объекта.\nС помощью какой функции осуществляется запись (экспорт) sf в файлы пространственных данных?\nНазовите основные параметры, определяющие геометрию растра.\nКакие пакеты отвечают за поддержку растровых данных в R?\nКак можно прочитать одноканальный и многоканальный растры в R?\nКакие функции можно использовать для визуализации одноканальных и многоканальных растров?\nМожно ли совмещать растровые и векторные слои на одном изображении? Если да, то как эта возможность реализуется?\nКаким образом можно узнать и задать пространственную привязку растрового набора данных?\nКакая функция отвечает за проецирование растровых данных? Перечислите ее параметры и их назначение.\nОбъясните систему индексирования объектов типа stars.\nКак вычислить новую переменную объекта типа stars?\nКак осуществить экспорт растра в файл?\n\n\n\n9.7.2 Упражнения\n\nПреобразуйте точки землетрясений из набора данных quakes в пространственные объекты и отобразите их сначала средствами стандартной графической подсистемы, а затем на интерактивной карте средствами пакета mapview. Передайте магнитуду землетрясения в параметр zcol функции mapview(), чтобы дифференцировать точки цветом по этому параметру.\nТаблица storms из пакета dplyr содержит данные трекинга тропических циклонов c 1975 по 2015 год. Выберите любой циклон и постройте для него линию трека прохождения и точки прохождения. Отобразите эти данные средствами стандартной графической подсистемы, а затем на интерактивной карте средствами mapview. Напишите программу таким образом, чтобы можно было выбирать имя циклона и программа отображала его трек на интерактивной карте.\nСкачайте базу данных и цифровую модель рельефа на территорию Сатинского полигона МГУ. Изучите содержимое базы данных и постройте на основе этих данных общегеографическую карту средствами стандартной графической подсистемы.\n\n\n\n\nСамсонов Т.Е. Визуализация и анализ географических данных на языке R. М.: Географический факультет МГУ, 2023. DOI: 10.5281/zenodo.901911",
    "crumbs": [
      "Пространственные данные и карты",
      "<span class='chapter-number'>9</span>  <span class='chapter-title'>Пространственные данные</span>"
    ]
  },
  {
    "objectID": "10-Maps.html#maps_prerequisites",
    "href": "10-Maps.html#maps_prerequisites",
    "title": "10  Основы картографии",
    "section": "10.1 Предварительные требования",
    "text": "10.1 Предварительные требования\nНеобходимые для работы пакеты:\n\nlibrary(sf)\nlibrary(stars)\nlibrary(dplyr)\nlibrary(ggplot2)\nlibrary(ggrepel)\nlibrary(ggnewscale)\nlibrary(rnaturalearth)\nlibrary(rmapshaper)\nlibrary(RColorBrewer)\nlibrary(ggspatial)",
    "crumbs": [
      "Пространственные данные и карты",
      "<span class='chapter-number'>10</span>  <span class='chapter-title'>Основы картографии</span>"
    ]
  },
  {
    "objectID": "10-Maps.html#maps_intro",
    "href": "10-Maps.html#maps_intro",
    "title": "10  Основы картографии",
    "section": "10.2 Введение",
    "text": "10.2 Введение\nВ настоящей главе рассматриваются общие принципы автоматизированного построения карт. Картографическая визуализация базируется на комплексе аспектов, таких как:\n\nсодержание карты;\nохват и масштаб/размер карты;\nкартографическая основа;\nгенерализация;\nпроекция;\nградусная сетка;\nоформление данных;\nлегенда;\nкомпоновка.\n\nПри этом многие компоненты неразрывно связаны друг с другом. Например, картографическая основа должна обладать оптимальной детализацией. То есть не быть излишне подробной или, наоборот, генерализованной для выбранного масштаба картографирования. Проекция, в свою очередь, влияет не величину масштаба при фиксированном размере карты, а легенда должны отражать выбранное содержание карты.\nВ настоящей теме кратко рассмотрены все перечисленные аспекты. В качестве библиотеки для визуализации используется ggplot2. Как и в случае с построением обычных графиков, использование данной библиотеки позволяет достичь гораздо лучшего по сравнению с базовой графикой R контроля над внешним видом изображения. Что позволяет в свою очередь достичь выского качества карт.",
    "crumbs": [
      "Пространственные данные и карты",
      "<span class='chapter-number'>10</span>  <span class='chapter-title'>Основы картографии</span>"
    ]
  },
  {
    "objectID": "10-Maps.html#spatial_natural",
    "href": "10-Maps.html#spatial_natural",
    "title": "10  Основы картографии",
    "section": "10.3 Данные Natural Earth",
    "text": "10.3 Данные Natural Earth\nВ качестве источника открытых данных мы будем использовать Natural Earth и WorldClim.\nNatural Earth — это открытые мелкомасштабные картографические данные высокого качества. Данные доступны для трех масштабов: 1:10М, 1:50М и 1:110М. Для доступа к этим данным из среды R без загрузки исходных файлов можно использовать пакет rnaturalearth. Пакет позволяет выгружать данные из внешнего репозитория, а также содержит три предзакачанных слоя:\n\nne_countries() границы стран\nne_states() границы единиц АТД 1 порядка\nne_coastline() береговая линия\n\nДля загрузки других слоев необходимо использовать функцию ne_download(), передав ей масштаб, название слоя и его категорию. Для начала мы поработаем с данными масштаба 110 млн:\n\ncountries = ne_countries(scale = 110, returnclass = 'sf')\ncoast = ne_coastline(scale = 110, returnclass = 'sf')\n\nocean = ne_download(scale = 110,\n                    type = 'ocean',\n                    category = 'physical',\n                    returnclass = 'sf')\n\ncities = ne_download(scale = 110,\n                     type = 'populated_places',\n                     category = 'cultural',\n                     returnclass = 'sf')\n\nВ то же время, каждый раз выкачивать данные для работы бывает неэффективно. Поэтому вы можете скачать себе полную базу данных Natural Earth в формате GeoPackage (GPKG) по ссылке https://www.naturalearthdata.com/downloads/ и положить ее в любую удобную локацию. В этом случае общение с интернетом в процессе построения карт не потребуется:\n\nne = '/Volumes/Data/Spatial/Natural Earth/natural_earth_vector.gpkg'\nrivers = st_read(ne, 'ne_110m_rivers_lake_centerlines', quiet = T)\nlakes = st_read(ne, 'ne_110m_lakes', quiet = T)\nland = st_read(ne, 'ne_110m_land', quiet = T)\nborders = st_read(ne, 'ne_110m_admin_0_boundary_lines_land', quiet = T)\n\nВ дальнейшем нам понадобятся данные другой детализации, поэтому объединим текущие данные в список, соответствующий масштабу 110М. Для этого используем функцию lst из пакета tibble, которая элементам списка дает такие же имена как объединяемым элементам:\n\nlyr110 = lst(ocean, land, coast, countries, \n             rivers, lakes, cities, borders)",
    "crumbs": [
      "Пространственные данные и карты",
      "<span class='chapter-number'>10</span>  <span class='chapter-title'>Основы картографии</span>"
    ]
  },
  {
    "objectID": "10-Maps.html#spatial_ggplot2",
    "href": "10-Maps.html#spatial_ggplot2",
    "title": "10  Основы картографии",
    "section": "10.4 Визуализация средствами ggplot2",
    "text": "10.4 Визуализация средствами ggplot2\nПространственные данные поддерживаются в графической подсистеме ggplot2. Для этого существует несколько специализированных функций:\n\ngeom_sf() вызывает stat_sf() и coord_sf() чтобы отобразить объекты типа sf в нужной системе координат;\ngeom_stars() отображает объекты типа stars;\ncoord_sf() обеспечивает поддержку картографических проекций и позволяет отображать данные в нужной системе координат на лету;\nstat_sf() отвечает за отображение переменных данных на графические переменные для пространственных данных;\ngeom_sf_label() позволяет отображать подписи объектов на плашке;\ngeom_sf_text() позволяет размещать подписи объектов без плашки.\n\nСоздадим на основе прочитанных данных простую карту мира. Будем конструировать карту последовательно, обсуждая что необходимо в ней поменять, чтобы она стала лучше. Для начала просто покажем страны:\n\nggplot() +\n  geom_sf(data = lyr110$countries) +\n  theme_void()\n\n\n\n\n\n\n\n\nМожно обратить внимание на то, что когда вы отображаете страны полигонами с заливкой, на карте появляются несуществующие границы: на южном полюсе (Антарктида) и вдоль 180-го меридана (на Чукотке). Чтобы такого не происходило, страны всегда визуализируют в 2 слоя: полигонами без обводки и линейными границами поверх:\n\nggplot() +\n  geom_sf(data = lyr110$countries, color = NA) +\n  geom_sf(data = lyr110$borders, linewidth = 0.2) +\n  theme_void()\n\n\n\n\n\n\n\n\nУбрав обводку стран, мы потеряли береговую линию. Будет логично добавить на карту океан. Однако если отобразить его полигоном с обводкой, как мы попытались изначально поступить при визуализации стран, по границе карты возникнут несуществующие береговые линии:\n\nggplot() +\n  geom_sf(data = lyr110$countries, color = NA) +\n  geom_sf(data = lyr110$borders, linewidth = 0.2) +\n  geom_sf(data = lyr110$ocean, linewidth = 0.4, \n          fill = 'azure', color = 'steelblue') +\n  theme_void()\n\n\n\n\n\n\n\n\nЭто означает, что для отображения морских акваторий следует использовать аналогичный прием совмещения полигональных объектов без обводки и их линейной границы:\n\nggplot() +\n  geom_sf(data = lyr110$countries, color = NA) +\n  geom_sf(data = lyr110$borders, linewidth = 0.2) +\n  geom_sf(data = lyr110$ocean, \n          fill = 'azure', color = NA) +\n  geom_sf(data = lyr110$coast, \n          size = 0.4, color = 'steelblue') +\n  theme_void()\n\n\n\n\n\n\n\n\nДобавим раскраску стран по их политической принадлежности. При отображении пространственных данных действуют принципы задания графических переменных, аналогичные построению обычных графиков: через mapping = aes(...). Воспользуемся готовым атрибутивным полем в таблице данных для создания политико-административной раскраски:\n\nggplot() +\n  geom_sf(data = lyr110$countries, color = NA, \n          mapping = aes(fill = as.factor(mapcolor7)), show.legend = FALSE) +\n  scale_fill_manual(values = brewer.pal(7, 'Set2')) +\n  geom_sf(data = lyr110$borders, linewidth = 0.2) +\n  geom_sf(data = lyr110$ocean, fill = 'azure', color = NA) +\n  geom_sf(data = lyr110$coast, linewidth = 0.4, color = 'steelblue4') +\n  theme_void()\n\n\n\n\n\n\n\n\nНанесем на карту точки и подписи крупнейших столиц. Для нанесения подписей используем geom_sf_text() с параметром nudge_y, чтобы сдвинуть подписи вверх относительно пунсонов. Помимо этого, чтобы понизить многословность кода, для дальнейших экспериментов перенесем посторяющиеся слои вы список:\n\nlyr110$megacities = lyr110$cities |&gt; \n  filter(SCALERANK == 0, \n         ! NAME %in% c('Washington, D.C.', 'Paris', 'Riyadh', 'Rome', 'São Paulo', 'Kolkata'))\n\nbasemap = list(\n  geom_sf(data = lyr110$countries, color = NA, \n          mapping = aes(fill = as.factor(mapcolor7)), show.legend = FALSE),\n  scale_fill_manual(values = brewer.pal(7, 'Set2')),\n  geom_sf(data = lyr110$borders, linewidth = 0.2),\n  geom_sf(data = lyr110$ocean, fill = 'azure', color = NA),\n  geom_sf(data = lyr110$coast, linewidth = 0.4, color = 'steelblue4'),\n  geom_sf(data = lyr110$megacities, shape = 21, fill = 'white', stroke = 0.75, linewidth = 2)\n)\n\nggplot() +\n  basemap +\n  geom_sf_text(data = lyr110$megacities, mapping = aes(label = NAME),\n               size = 3, nudge_y = 5, family = 'Open Sans', fontface = 'bold') +\n  theme_void()\n\n\n\n\n\n\n\n\nС подписями точечных объектов, однако, более удобно работать с применением пакета ggrepel, который расставляет их автоматически вокруг точек:\n\nggplot() +\n  basemap +\n  geom_text_repel(data = lyr110$megacities, stat = \"sf_coordinates\",\n                  size = 3, aes(label = NAME, geometry = geometry), \n                  family = 'Open Sans', fontface = 'bold') +\n  theme_void()\n\n\n\n\n\n\n\n\nВ данном случае все неплохо, но подписи читаются недостаточно хорошо из-за контраста с фоном и береговой линией. Для улучшения читаемости можно сделать заливку стран менее насыщенной, увеличив прозрачность. При этом надо и обводку для точек сделать менее контрастной, чтобы она не выделялась на фоне стран — все-таки, на общегеографических и политико-административных картах равнозначны:\n\nbasemap0 = list(\n  geom_sf(data = lyr110$countries, color = NA, \n          alpha = 0.5,\n          mapping = aes(fill = as.factor(mapcolor7)), show.legend = FALSE),\n  scale_fill_manual(values = brewer.pal(7, 'Set2')),\n  geom_sf(data = lyr110$borders, alpha = 0.5, linewidth = 0.2),\n  geom_sf(data = lyr110$ocean, fill = 'azure', color = NA),\n  geom_sf(data = lyr110$coast, alpha = 0.5, linewidth = 0.4, color = 'steelblue4'),\n  geom_sf(data = lyr110$megacities, shape = 21, fill = 'white', stroke = 0.75, linewidth = 2)\n)\n\nggplot() +\n  basemap0 +\n  geom_text_repel(data = lyr110$megacities, stat = \"sf_coordinates\",\n                  size = 3, aes(label = NAME, geometry = geometry), \n                  family = 'Open Sans', fontface = 'bold') +\n  theme_void()\n\n\n\n\n\n\n\n\nВ качестве альтернативного решения можно добавить лекий полупрозрачный фон под подписями городов. Для этого нужно изменить геометрию с geom_text_repel на geom_label_repel и определить цвет заливки фона:\n\nggplot() +\n  basemap +\n  geom_label_repel(data = lyr110$megacities, stat = \"sf_coordinates\",\n                  aes(label = NAME, geometry = geometry), \n                  size = 3, \n                  label.size = NA, \n                  label.padding=.1, \n                  fill = alpha(\"white\", 0.7), \n                  family = 'Open Sans', fontface = 'bold') +\n  theme_void()",
    "crumbs": [
      "Пространственные данные и карты",
      "<span class='chapter-number'>10</span>  <span class='chapter-title'>Основы картографии</span>"
    ]
  },
  {
    "objectID": "10-Maps.html#проекции-и-градусные-сетки",
    "href": "10-Maps.html#проекции-и-градусные-сетки",
    "title": "10  Основы картографии",
    "section": "10.5 Проекции и градусные сетки",
    "text": "10.5 Проекции и градусные сетки\nКогда вы отображаете данные в градусах, не определяя проекцию, они визуализируются в цилиндрической равнопромежуточной проекции. Такая проекция не очень удобна для визуализации земного шара. Запишем исходную карту без проекции в отдельную переменную и визуализируем ее с помощью разных проекций:\n\nmap = ggplot() +\n  geom_sf(data = lyr110$countries, color = NA,\n          mapping = aes(fill = as.factor(mapcolor7)), show.legend = FALSE) +\n  scale_fill_manual(values = brewer.pal(7, 'Set2')) +\n  geom_sf(data = lyr110$borders, linewidth = 0.2) +\n  geom_sf(data = lyr110$ocean, fill = 'azure', color = NA) +\n  geom_sf(data = st_wrap_dateline(lyr110$coast), linewidth = 0.4, color = 'steelblue4') +\n  geom_sf(data = lyr110$megacities, shape = 21, fill = 'white', stroke = 0.75, size = 2) +\n  geom_label_repel(\n    data = lyr110$megacities, stat = \"sf_coordinates\",\n    aes(label = NAME, geometry = geometry),\n    size = 3,\n    label.size = NA,\n    label.padding=.1,\n    fill = alpha(\"white\", 0.7),\n    family = 'Open Sans', fontface = 'bold'\n  ) +\n  labs(x = NULL, y = NULL) +\n  theme_minimal()\n\nmap + coord_sf(crs = \"+proj=moll\")\n\n\n\n\n\n\n\nmap + coord_sf(crs = \"+proj=eck3\")\n\n\n\n\n\n\n\nmap + coord_sf(crs = \"+proj=eqearth\")\n\n\n\n\n\n\n\nmap + coord_sf(crs = \"+proj=times\")\n\n\n\n\n\n\n\nmap + coord_sf(crs = \"+proj=mill\")\n\n\n\n\n\n\n\n\nДобавим теперь линии градусной сетки:\n\nlons = seq(-180, 180, by = 30)\nlats = seq(-90, 90, by = 30)\n\ngrat = st_graticule(lon = lons, lat = lats)\n\nbox = st_bbox(c(xmin = -180, xmax = 180, \n                ymax = 90,   ymin = -90), \n              crs = st_crs(4326)) |&gt; \n  st_as_sfc() |&gt; \n  smoothr::densify(max_distance = 1) \n\ndegree_labels = function(grat, vjust, hjust, size, lon = T, lat = T) {\n  pts = grat |&gt;  \n    st_cast('POINT') |&gt; \n    group_by(degree, type, degree_label) |&gt; \n    filter(row_number() == 1)\n    \n  list(\n    if (lon) geom_sf_text(data = filter(pts, type == 'E'), vjust = vjust, size = size,\n                 mapping = aes(label = degree_label), parse = TRUE),\n    if (lat) geom_sf_text(data = filter(pts, type == 'N'), hjust = hjust, size = size,\n                 mapping = aes(label = degree_label), parse = TRUE)\n  )  \n}\n\nmap + \n  geom_sf(data = grat, linewidth = 0.1) +\n  geom_sf(data = box, linewidth = 0.5, fill = NA) +\n  coord_sf(crs = \"+proj=moll\") +\n  degree_labels(grat, vjust = +1.5, hjust = +1.5, size = 3, lon = F)\n\n\n\n\n\n\n\n\nmap + \n  geom_sf(data = grat, linewidth = 0.1) +\n  geom_sf(data = box, linewidth = 0.5, fill = NA) +\n  coord_sf(crs = \"+proj=eck3\") +\n  degree_labels(grat, vjust = +1.5, hjust = +1.5, size = 3)\n\n\n\n\n\n\n\n\nmap + \n  geom_sf(data = grat, linewidth = 0.1) +\n  geom_sf(data = box, linewidth = 0.5, fill = NA) +\n  coord_sf(crs = \"+proj=eqearth\") +\n  degree_labels(grat, vjust = +1.5, hjust = +1.5, size = 3)\n\n\n\n\n\n\n\n\nmap + \n  geom_sf(data = grat, linewidth = 0.1) +\n  geom_sf(data = box, linewidth = 0.5, fill = NA) +\n  coord_sf(crs = \"+proj=times\") +\n  degree_labels(grat, vjust = +1.5, hjust = +1.5, size = 3)\n\n\n\n\n\n\n\n\n\n10.5.1 Отображение растровых данных\nНа общегеографических картах довольно часто присутствует изображение рельефа. Чтобы добавить его на карту, можно использовать специальный тип геометрии geom_stars:\n\ndem = read_stars('data/world/gebco.tif') # Цифровая модель рельефа\n\nggplot() +\n  geom_stars(data = dem) +\n  geom_sf(data = lyr110$coast, linewidth = 0.4, color = 'white') +\n  coord_sf() +\n  theme_void()\n\n\n\n\n\n\n\n\nДля начала попробуем раскрасить рельеф в традиционной цветовой шкале, и посмотреть как это будет выглядеть:\n\npal = c('navyblue', 'steelblue', 'azure', 'darkslategray', 'olivedrab', 'lightyellow', 'firebrick', 'pink', 'white')\n\n# Вынесем повторяющиемя слои в отдельный список\nhydro_lyrs = list(\n  geom_sf(data = lyr110$coast, linewidth = 0.4, color = 'steelblue4'),\n  geom_sf(data = lyr110$rivers, linewidth = 0.3, color = 'steelblue4'),\n  geom_sf(data = lyr110$lakes, linewidth = 0.3, color = 'steelblue4', fill = 'azure')\n)\n\nggplot() +\n  geom_stars(data = dem) +\n  scale_fill_gradientn(colours = pal) +\n  hydro_lyrs +\n  coord_sf() +\n  theme_void()\n\n\n\n\n\n\n\n\nВидно, что по умолчаню цвета распределяются равномерно вдоль шкалы. Нам же необходимо ассоциировать их с конкретными высотами. Это можно сделать, определив в функции scale_fill_gradientn параметр values. Он принимает значения от 0 до 1 и указывает позицию цвета между минимумом и максимум. Чтобы сформировать такие позиции, необходимо сначала сделать гипсометрическую шкалу в метрах, а затем отмасштабировать ее на дипазон \\([0, 1]\\) посредством функции rescale из пакета scales:\n\nval = c(min(dem[[1]]), -4000, -200, 0, 100, 300, 1000, 2500, max(dem[[1]])) |&gt; \n  scales::rescale()\n\nggplot() +\n  geom_stars(data = dem) +\n  scale_fill_gradientn(colours = pal, values = val) +\n  hydro_lyrs +\n  coord_sf() +\n  theme_void()\n\n\n\n\n\n\n\n\nНа первый взгляд может показаться, что все в порядке, но есть 2 проблемы: - отрицательные высоты на суше закрашиваются таким же цветом, как и отрицательные высота на море - нет резкого перехода через отметку 0, при котором цвет должен меняться с голубого на темно-зеленый.\nЧтобы убедиться в этом рассмотрим фрагмент карты подробнее, обратив внимание на Персидский залив, Каспийское и Черное моря:\n\nanno = list(\n  annotate(\"rect\", xmin = 45, xmax = 60, ymin = 22, ymax = 32, \n           color = 'white', linewidth = 2, fill = NA),\n  annotate(\"rect\", xmin = 45, xmax = 57, ymin = 35, ymax = 48, \n           color = 'white', linewidth = 2, fill = NA),\n  annotate(\"rect\", xmin = 26, xmax = 43, ymin = 40, ymax = 48, \n           color = 'white', linewidth = 2, fill = NA)\n)\n\nggplot() +\n  geom_stars(data = dem) +\n  scale_fill_gradientn(colours = pal, values = val) +\n  hydro_lyrs +\n  anno +\n  coord_sf(xlim = c(10, 75), ylim = c(20, 50)) +\n  theme_void()\n\n\n\n\n\n\n\n\nЧтобы не возникало такого эффекта, необходимо разделить цифровую модель рельефа на ldt: одна для суши, вторая для мора. Для этого используем стандартный синтаксис вида stars[sf], который позволяет обрезать объект типа stars заданным объектом типа sf:\n\nsf_use_s2(FALSE)\ndem_land = dem[lyr110$land]\ndem_ocean = dem[lyr110$ocean]\n\nmap = ggplot() +\n  geom_stars(data = dem_ocean) +\n  scale_fill_gradientn(\n    colours = c('navyblue', 'steelblue4', 'skyblue2', 'azure', 'azure'),\n    values = scales::rescale(\n      c(min(dem_ocean[[1]], na.rm = T), \n        -4000, -200, 0, \n        max(dem_ocean[[1]], na.rm = T))\n    ),\n    na.value = NA\n  ) +\n  new_scale_fill() +\n  geom_stars(data = dem_land) +\n  scale_fill_gradientn(\n    colours = c('darkslategray', 'darkslategray', 'olivedrab', \n                'lightyellow', 'firebrick', 'pink', 'white'), \n    values = scales::rescale(\n      c(min(dem_land[[1]], na.rm = T), \n        -50, 100, 300, 1500, 3500, \n        max(dem_land[[1]], na.rm = T)\n      )\n    ), \n    na.value = NA\n  ) +\n  hydro_lyrs +\n  coord_sf() +\n  theme_void()\n\nmap\n\n\n\n\n\n\n\n\nПроверим ранее указанную область:\n\nmap +\n  coord_sf(xlim = c(10, 75), ylim = c(20, 50)) +\n  anno\n\n\n\n\n\n\n\n\n\n\n10.5.2 Проецирование растровых данных\nВ отличие от векторных данных, растровые необходимо трансформировать заранее в нужную проекцию. Для этого воспользуемся функцией st_warp:\n\nhydro_lyrs = list(\n  geom_sf(data = st_wrap_dateline(lyr110$coast), linewidth = 0.4, color = 'steelblue4'),\n  geom_sf(data = st_wrap_dateline(lyr110$rivers), linewidth = 0.3, color = 'steelblue4'),\n  geom_sf(data = st_wrap_dateline(lyr110$lakes), linewidth = 0.3, color = 'steelblue4', fill = 'azure')\n)\n\nprj = '+proj=eck3'\n\nscale_ocean = scale_fill_gradientn(\n    colours = c('navyblue', 'steelblue4', 'skyblue2', 'azure', 'azure'),\n    values = scales::rescale(\n      c(min(dem_ocean[[1]], na.rm = T), \n        -4000, -200, 0, \n        max(dem_ocean[[1]], na.rm = T))\n    ),\n    na.value = NA\n  )\n\nscale_land = scale_fill_gradientn(\n    colours = c('darkslategray', 'darkslategray', 'olivedrab', \n                'lightyellow', 'firebrick', 'pink', 'white'), \n    values = scales::rescale(\n      c(min(dem_land[[1]], na.rm = T), \n        -50, 100, 300, 1500, 3500, \n        max(dem_land[[1]], na.rm = T)\n      )\n    ), \n    na.value = NA\n  )\n\nggplot() +\n  geom_stars(data = st_warp(dem_ocean, crs = prj)) +\n  scale_ocean +\n  new_scale_fill() +\n  geom_stars(data = st_warp(dem_land, crs = prj)) +\n  scale_land +\n  hydro_lyrs +\n  coord_sf(crs = prj) +\n  theme_void()\n\n\n\n\n\n\n\n\nОбратим внимание, что растр проецируется немного не так, как векторные данные, его область остается прямоугольной. Поэтому при построении карт мира необходимо растры после проецирования обрезать прямоугольником, охватывающим весь мир:\n\nprjs = c(\"+proj=moll\", \"+proj=eck3\", \"+proj=eqearth\", \"+proj=times\")\nlon_labs = c(F,T,T,T)\n\nfor (i in seq_along(prjs)) {\n  pbox = st_transform(box, prjs[i])\n\n  map = ggplot() +\n    geom_stars(data = st_warp(dem_ocean, crs = prjs[i], use_gdal = TRUE)[pbox]) +\n    scale_ocean +\n    new_scale_fill() +\n    geom_stars(data = st_warp(dem_land, crs = prjs[i], use_gdal = TRUE)[pbox]) +\n    scale_land +\n    hydro_lyrs +\n    geom_sf(data = grat, linewidth = 0.1) +\n    geom_sf(data = box, linewidth = 0.5, fill = NA) +\n    coord_sf(crs = prjs[i]) +\n    degree_labels(grat, vjust = +1.5, hjust = +1.5, size = 3, lon = lon_labs[i]) +\n    ggtitle(prjs[i]) +\n    theme_void()\n  \n  print(map)\n}",
    "crumbs": [
      "Пространственные данные и карты",
      "<span class='chapter-number'>10</span>  <span class='chapter-title'>Основы картографии</span>"
    ]
  },
  {
    "objectID": "10-Maps.html#детализация-данных",
    "href": "10-Maps.html#детализация-данных",
    "title": "10  Основы картографии",
    "section": "10.6 Детализация данных",
    "text": "10.6 Детализация данных\n\n10.6.1 Выбор картографической основы\nОдин из обязательных признаков хорошей карты — это использование пространственных данных подходящей детализации. Избыточная детализация приводит к тому, что карта становится неопрятной, пестрит трудно воспринимаемыми деталями, производит непрофессиональное впечатление. Помимо этого, избыточная детализация данных приводит к тому, что карта будет медленно прорисовываться. Это справедливо как для карт, создаваемых программным путём, так и для карт, которые составляются в ГИС-пакетах. В некоторых случаях можно столкнуться с обратной ситуацией, когда данные менее детальны, чем это требуется для карты. В этом случае у пользователя карты будет складываться впечатление, что карта недостаточно точна и информативна.\nПроблема детализации касается в основном картографической основы, поскольку подбирается она прежде всего в соответствии с охватом исследуемой территории и физическим размером итогового изображения. В случае если предполагается совмещение картографической основы и тематических данных, важным фактором будет также детализация самих тематических данных.\nВ качестве примера для выбора подходящей основы рассмотрим задачу построения карты Европы, которая бы вписывалась в размер страницы данной книги. База данных Natural Earth содержит 3 уровня детализации, из которых надо выбрать подходящий. Сравним их:\n\ncnt010 = st_read(ne, 'ne_10m_admin_0_countries', quiet = T)\ncnt050 = st_read(ne, 'ne_50m_admin_0_countries', quiet = T)\ncnt110 = st_read(ne, 'ne_110m_admin_0_countries', quiet = T)\n\nprj = '+proj=laea +lat_0=50 +lon_0=10'\n\nbox = st_bbox(c(xmin = -10, xmax = 33, \n                ymin = 33, ymax = 60),\n              crs = st_crs(4326)) |&gt; \n  st_as_sfc() |&gt; \n  st_transform(prj) |&gt; \n  st_bbox()\n\ncnts = list(cnt010, cnt050, cnt110)\nscales = c(10, 50, 110)\n\nfor (i in seq_along(cnts)) {\n  print(\n      ggplot() +\n        geom_sf(data = cnts[[i]], linewidth = 0.25,\n                mapping = aes(fill = as.factor(MAPCOLOR7)),\n                show.legend = FALSE) +\n        scale_fill_manual(values = brewer.pal(7, 'Set2')) +\n        coord_sf(crs = prj, \n                 xlim = c(box[1], box[3]),\n                 ylim = c(box[2], box[4])) +\n        theme_bw() +\n        theme(panel.background = element_rect(fill = 'azure')) +\n        ggtitle(glue::glue('Уровень детализации {scales[i]}M'))\n  )\n}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nОчевидно, что в данном случае оптимальным является средний уровень детализации 50M. Два других уровня при выбранном охвате территории и размере карты являются либо избыточно (10M), либо недостаточно (110M) детальными.\n\n\n10.6.2 Генерализация картографической основы\nИногда не удается найти картографическую основу подходящей детализации. В этом случае вы можете провести генерализацию данных. Поскольку генерализация является достаточно ресурсоемкой процедурой, ее не следует проводить непосредственно в скрипте, который занимается построением карт. Вместо этого, необходимо вынести создание генерализованной картографической основы в отдельный скрипт. Наиболее часто в целях генерализации используются такие операции как геометрическое упрощение и отбор объектов. Следует, однако, помнить, что эти процедуры целесообразно выполнять после того как данные трансформированы в нужную проекцию. В противном случае генерализация может быть неравномерной по полю карты (один градус долготы соответствует меньшим расстояниям в близости полюсов). Помимо этого, будет сложно выполнять параметризацию алгоритмов генерализации.\n\n10.6.2.1 Геометрическое упрощение\nВ качестве примера рассмотрим геометрическое упрощение рек и полигонов государств. Визуализируем для начала исходные данные:\n\ncountries = cnt010 |&gt; \n  st_transform(prj) |&gt; \n  st_crop(box)\n\nggplot() +\n  geom_sf(data = countries, linewidth = 0.25) +\n  ggtitle('Исходные данные масштаба 10M') +\n  theme_minimal()\n\n\n\n\n\n\n\n\nНевооруженным взглядом видно, что их детализация избыточна. Для геометрического упрощения воспользуемся функцией ms_simplify() из пакета rmapshaper. В данной функции доступно два алгоритма геометрического упрощения: Дугласа-Пейкера и Висвалингам-Уайатта. Принципы работы этих алгоритмов разные, поэтому сопоставимая детализация достиагается в них при разном количестве точек:\n\ncountries_dp = ms_simplify(countries, \n                           method = 'dp', # алгоритм Дугласа-Пейкера\n                           keep = 0.04) # оставить 4% точек\n\ncountries_vw = ms_simplify(countries,  \n                           method = 'vis', # алгоритм Висвалингам-Уайатта\n                           keep = 0.06)  # оставить 6% точек\n\nggplot() +\n  geom_sf(data = countries_dp, linewidth = 0.25) +\n  ggtitle('Геометрическое упрощение алгоритмом Дугласа-Пейкера') +\n  theme_minimal()\n\n\n\n\n\n\n\n\nggplot() +\n  geom_sf(data = countries_vw, linewidth = 0.25) +\n  ggtitle('Геометрическое упрощение алгоритмом Висвалингам-Уайатта') +\n  theme_minimal()\n\n\n\n\n\n\n\n\nВидно, что результаты упрощения алгоритмом Дугласа-Пейкера довольно угловатые и неестественные. Но при этом он лучше сохраняет различные характерные точки в структуре линии типа вершин фьордов. Тем не менее для целей картографической генерализации алгоритм Висвалингам-Уайатта можно назвать предпочтительным.\nПомимо этого, при геометрическом упрощении возникаеют сложности топологического согласования с другими слоями. Обратим внимание на то, как речки согласуются с береговой линией:\n\nrivers = st_read(ne, 'ne_10m_rivers_lake_centerlines') |&gt; \n  st_transform(prj) |&gt; \n  st_crop(box) |&gt; \n  st_cast('MULTILINESTRING') |&gt; \n  st_cast('LINESTRING')\n## Reading layer `ne_10m_rivers_lake_centerlines' from data source \n##   `/Volumes/Data/Spatial/Natural Earth/natural_earth_vector.gpkg' \n##   using driver `GPKG'\n## Simple feature collection with 1473 features and 38 fields\n## Geometry type: MULTILINESTRING\n## Dimension:     XY\n## Bounding box:  xmin: -164.9035 ymin: -52.15775 xmax: 177.5204 ymax: 75.79348\n## Geodetic CRS:  WGS 84\n\nggplot() +\n  geom_sf(data = countries_vw, linewidth = 0.25) +\n  geom_sf(data = rivers, linewidth = 0.25, color = 'steelblue') +\n  ggtitle('Геометрическое упрощение алгоритмом Висвалингам-Уайатта') +\n  theme_minimal()\n\n\n\n\n\n\n\n\nЗдесь видно, что изза упрощения линий удалились эстуарии рек, и теперь речки не дотягивают до своих устьев. Чтобы такого эффекта не происходило, необходимо зафиксировать вершины эстуариев, запретив их удалять. Наиболее просто это сделать в линейном варианте, когда упрощению подвергаются береговые линии, а не полигоны стран:\n\ncoast = st_read(ne, 'ne_10m_coastline') |&gt; \n  st_transform(prj) |&gt; \n  st_crop(box) |&gt;\n  st_cast('MULTILINESTRING') |&gt; \n  st_cast('LINESTRING') \n## Reading layer `ne_10m_coastline' from data source \n##   `/Volumes/Data/Spatial/Natural Earth/natural_earth_vector.gpkg' \n##   using driver `GPKG'\n## Simple feature collection with 4133 features and 3 fields\n## Geometry type: LINESTRING\n## Dimension:     XY\n## Bounding box:  xmin: -180 ymin: -85.22194 xmax: 180 ymax: 83.6341\n## Geodetic CRS:  WGS 84\n\nmouths = rivers |&gt; \n  st_line_sample(ls, sample = c(1)) |&gt; \n  st_cast('POINT') |&gt; \n  st_snap(coast, tol = 1000) |&gt; \n  st_intersection(coast)\n\nggplot() +\n  geom_sf(data = coast, linewidth = 0.35, color = 'steelblue') +\n  geom_sf(data = rivers, linewidth = 0.25, color = 'steelblue') +\n  geom_sf(data = mouths, color = 'red') +\n  theme_minimal()\n\n\n\n\n\n\n\n\ncoast_split = lwgeom::st_split(coast, mouths) |&gt; \n  st_collection_extract('LINESTRING')\n\ncoast_vw = ms_simplify(coast_split,  \n                       method = 'vis', # алгоритм Висвалингам-Уайатта\n                       keep = 0.05)  # оставить 6% точек\n\nrivers_vw = ms_simplify(rivers,  \n                       method = 'vis', # алгоритм Висвалингам-Уайатта\n                       keep = 0.05)  # оставить 6% точек\n\n\nggplot() +\n  geom_sf(data = coast_vw, linewidth = 0.35, color = 'steelblue') +\n  geom_sf(data = rivers_vw, linewidth = 0.25, color = 'steelblue') +\n  ggtitle('Геометрическое упрощение алгоритмом Висвалингам-Уайатта') +\n  theme_minimal()\n\n\n\n\n\n\n\n\n\n\n10.6.2.2 Отбор\nОтбор применятся внутри множества пространственных объектов для того чтобы уменьшить их количество. Наиболее просто реализуется отбор для объектов, которые не состоят в пространственных отношениях. Как правило, это точечные объекты. Более сложна процедура отбора во множестве топологически связанных объектов. Например, прореживание транспортной или гидрографической сети. В данном разделе мы посмотрим как можно отбирать точечные объекты. Наиболее простой случай реализуется тогда, когда объекты можно отобрать по атрибутам, без использования пространственных отношений. К счастью, данные Natural Earth содержат атрибуты, которые можно использовать в качестве критериев отбора.\nДля начала попробуем нанести все населенные пункты:\n\ncities_eu = st_read(ne, 'ne_10m_populated_places') |&gt; \n  st_transform(prj) |&gt; \n  st_crop(box)\n## Reading layer `ne_10m_populated_places' from data source \n##   `/Volumes/Data/Spatial/Natural Earth/natural_earth_vector.gpkg' \n##   using driver `GPKG'\n## Simple feature collection with 7342 features and 137 fields\n## Geometry type: POINT\n## Dimension:     XY\n## Bounding box:  xmin: -179.59 ymin: -90 xmax: 179.3833 ymax: 82.48332\n## Geodetic CRS:  WGS 84\n\nggplot() +\n  geom_sf(data = countries_vw, linewidth = 0.25) +\n  geom_sf(data = cities_eu, size = 0.5, color = 'darkviolet') +\n  geom_sf_text(data = cities_eu, \n               mapping = aes(label = NAME),\n               size = 1.5, nudge_y = 30000) +\n  theme_bw()\n\n\n\n\n\n\n\n\nОчевидно, что при такой плотности нормальную карту составить не получится. Попробуем для начала остаить только столицы и разнести их через ggrepel:\n\ncapitals = filter(cities_eu, FEATURECLA == 'Admin-0 capital')\n\nggplot() +\n  geom_sf(data = countries_vw, linewidth = 0.25) +\n  geom_sf(data = capitals, size = 1.2, color = 'darkviolet') +\n  geom_text_repel(data = capitals, stat = \"sf_coordinates\",\n                size = 2.5, aes(label = NAME, geometry = geom), \n                fontface = 'bold') +\n  theme_bw()\n\n\n\n\n\n\n\n\nОчевидно, на данную схему можно также дополнительно нанести дополнительно крупные населенные пункты, отобрав их уже по численности населения. Оставим для примера те, в которых живет более \\(700 000\\) жителей:\n\nmajor_cities = cities_eu |&gt; \n  filter((FEATURECLA == 'Admin-0 capital') | (POP_MIN &gt;= 700000)) |&gt; \n  mutate(FEATURECLA = ordered(FEATURECLA, levels = unique(cities_eu$FEATURECLA)))\n\n\nggplot() +\n  geom_sf(data = countries_vw, linewidth = 0.25) +\n  geom_sf(data = major_cities, size = 1, color = 'darkviolet') +\n  geom_text_repel(data = major_cities, stat = \"sf_coordinates\",\n                size = 2, aes(label = NAME, geometry = geom), \n                box.padding = 0.15, fontface = 'bold') +\n  theme_bw()",
    "crumbs": [
      "Пространственные данные и карты",
      "<span class='chapter-number'>10</span>  <span class='chapter-title'>Основы картографии</span>"
    ]
  },
  {
    "objectID": "10-Maps.html#классификация-объектов-по-типам",
    "href": "10-Maps.html#классификация-объектов-по-типам",
    "title": "10  Основы картографии",
    "section": "10.7 Классификация объектов по типам",
    "text": "10.7 Классификация объектов по типам\nДля того чтобы подчеркнуть отличия между объектами разных типов и значимости, на картах применяется классификация. Более важные объекты показываются более заметными символами, при этом разнотипные, но равные по значимости объекты получают сходные по видимости, но разные по рисунку символы. Пример первого типа — это отображение населенных пунктов разной людности значками разного диаметра. Второй тип классификации на общегеографических картах соответствует, например, автомобильным и железным дорогам.\n\n10.7.1 Вычисляемые классы\nВ некоторых случаях удобнее не заготавливать классы заранее, а вычислить их непосредственно при отображении, используя заданное преобразование. В частности, такой способ уместен, когда количественный атрибут надо разбить на классы. Например, классифицировать населенные пункты по численности населения и затем назначить им кружки разного диаметра по следующим классам:\n\nменее 100 000 жителей,\nот 100 000 до 1 000 000 жителей,\nболее 1 000 000 жителей\n\nС помощью ggplot это делается путем определения эстетики size и назначения шкалы отображения scale_size_binned. Аналогичным образом варьируется размер шрифта подписи,\n\nbrks = c(100000, 1000000)\n\nggplot() +\n  geom_sf(data = countries_vw, size = 0.25) +\n  geom_sf(data = capitals, mapping = aes(size = POP_MAX), colour = \"black\",\n          fill = \"white\",  shape = 21, stroke = 0.5) +\n  scale_size_binned(breaks = brks, range = c(1, 3), \n                    name = 'Population, ppl', trans = 'sqrt') +\n  new_scale('size') +\n  geom_text_repel(data = capitals, stat = \"sf_coordinates\", force_pull = 1,\n                aes(label = NAME, geometry = geom, size = POP_MAX),\n                fontface = 'bold', show.legend = FALSE) +\n  scale_size_binned(breaks = brks, range = c(2, 3)) +\n  scale_x_continuous(expand = c(0,0)) +\n  scale_y_continuous(expand = c(0,0)) +\n  theme_bw() +\n  theme(\n    panel.grid = element_line(colour = \"black\", linewidth = 0.1),\n    panel.background = element_rect(fill = NA),\n    panel.ontop = TRUE\n  ) +\n  labs(x = NULL, y = NULL)\n\n\n\n\n\n\n\n\n\n\n10.7.2 Готовые классы\nЕсли объекты уже наделены классами, их можно непосредственно отобразить на графические переменные. Например, слой дорог в Natural Earth содержит дороги разных классов, а также паромные переправы:\n\nroads = st_read(ne, 'ne_10m_roads', quiet = FALSE) |&gt; \n  st_transform(prj) |&gt; \n  st_crop(box)\n## Reading layer `ne_10m_roads' from data source \n##   `/Volumes/Data/Spatial/Natural Earth/natural_earth_vector.gpkg' \n##   using driver `GPKG'\n## Simple feature collection with 56600 features and 31 fields\n## Geometry type: MULTILINESTRING\n## Dimension:     XY\n## Bounding box:  xmin: -166.5325 ymin: -55.11212 xmax: 178.4191 ymax: 71.17768\n## Geodetic CRS:  WGS 84\n\nplot(roads['type'])\n\n\n\n\n\n\n\n\nКак правило, дороги отображаются линиями разного цвета и толщины: чем более важна дорога, тем толще будет ее линия и интенсивнее цвет. Попробуем реализовать это средствами ggplot2, при этом ограничим охват территорией Польши, чтобы не перегружать изображение.\n\nauto = roads |&gt; \n  filter(featurecla == 'Road') |&gt; \n  mutate(type = ordered(\n    type, \n    levels = c(\"Unknown\", \"Road\", \"Secondary Highway\", \"Major Highway\"))\n  )\n\nexp = 75000\n\nbox_pl = countries_vw |&gt; \n  filter (SOVEREIGNT == 'Poland') |&gt; \n  st_bbox() +\n  c(-exp, -exp, exp, exp) # expand by 50 km each side\n\nggplot() +\n  geom_sf(data = countries_vw, linewidth = 1) +\n  geom_sf(data = auto, aes(color = type, linewidth = type)) +\n  scale_x_continuous(limits = box_pl[c(1,3)], expand = c(0,0)) +\n  scale_y_continuous(limits = box_pl[c(2,4)], expand = c(0,0)) +\n  theme_bw()\n\n\n\n\n\n\n\n\nПо умолчанию ситуация с символами тревожная, но проблему можно решить путем ручной настройки толщин линий и цветов:\n\nggplot() +\n  geom_sf(data = countries_vw, linewidth = 1) +\n  geom_sf(data = auto, aes(color = type, linewidth = type), \n          show.legend = \"line\") +\n  scale_linewidth_ordinal(range = c(0.05, 1), \n                          name = 'Road class',\n                          guide = guide_legend(reverse = TRUE)) +\n  scale_color_manual(values = c('orange', 'red', 'firebrick', 'darkviolet'), \n                     name = 'Road class',\n                     guide = guide_legend(reverse = TRUE)) +\n  scale_x_continuous(limits = box_pl[c(1,3)], expand = c(0,0)) +\n  scale_y_continuous(limits = box_pl[c(2,4)], expand = c(0,0)) +\n  theme_bw()\n\n\n\n\n\n\n\n\nВернем отображение населенных пунктов, но уже с более дробной классификацией:\n\noptions(scipen = 999)\nbrks = c(100000, 500000, 1000000)\n\nmap_pl = ggplot() +\n  geom_sf(data = countries_vw, linewidth = 1) +\n  geom_sf(data = auto, aes(color = type, linewidth = type), \n          show.legend = \"line\") +\n  scale_linewidth_ordinal(range = c(0.2, 1), \n                          name = 'Road class',\n                          guide = guide_legend(reverse = TRUE)) +\n  scale_color_manual(values = c('grey20', 'firebrick', 'red', 'darkviolet'), \n                     name = 'Road class',\n                     guide = guide_legend(reverse = TRUE)) +\n  geom_sf(data = cities_eu, mapping = aes(size = POP_MAX), colour = \"black\",\n          fill = \"white\",  shape = 21, stroke = 0.5) +\n  scale_size_binned(breaks = brks, range = c(1.5, 4), \n                    name = 'Population, ppl', trans = 'sqrt') +\n  new_scale('size') +\n  geom_label_repel(data = cities_eu, stat = \"sf_coordinates\", force_pull = 1,\n                aes(label = NAME, geometry = geom, size = POP_MAX),\n                fontface = 'bold', label.padding=.1, label.size = NA, \n                fill = alpha(\"white\", 0.8), show.legend = FALSE) +\n  scale_size_binned(breaks = brks, range = c(2.5, 4), name = 'Population, ppl') +\n  scale_x_continuous(limits = box_pl[c(1,3)], expand = c(0,0)) +\n  scale_y_continuous(limits = box_pl[c(2,4)], expand = c(0,0)) +\n  theme_bw() +\n  labs(x = NULL, y = NULL, title = 'Poland')\n\nmap_pl\n\n\n\n\n\n\n\n\nБолее сложная ситуация возникает, когда требуется варьировать одновременно несколько графических переменных. Например, если крупнейшие населенные пункты необходимо показывать квадратом, а не кружком. Или автомобильные дороги должны быть толще, чем железные. В этом случае у вас есть два варианта решения проблемы. Вариант “в лоб” — разнести классы объектов по разным слоям и назначить им индивидуальные значки. Вариант более вдумчивый — настроить отображение там образом, чтобы данные брались из одного слоя и классифицировались непосредственно при отображении. Но в этом случае с высокой вероятностью придется делать индивидуальные символы для каждого типа объекта.",
    "crumbs": [
      "Пространственные данные и карты",
      "<span class='chapter-number'>10</span>  <span class='chapter-title'>Основы картографии</span>"
    ]
  },
  {
    "objectID": "10-Maps.html#масштабные-линейки-и-указатели-направления-на-север.",
    "href": "10-Maps.html#масштабные-линейки-и-указатели-направления-на-север.",
    "title": "10  Основы картографии",
    "section": "10.8 Масштабные линейки и указатели направления на север.",
    "text": "10.8 Масштабные линейки и указатели направления на север.\nСтандартные элементы компоновки карты — масштабная линейка и указатель на север. С точки зрения ggplot они являются аннотациями. Соответствующие аннотации можно найти в пакете ggspatial.\nМасштабную линейку и указатель севера, отображаемые по умолчанию:\n\nmap_pl +\n  annotation_north_arrow() +\n  annotation_scale()\n\n\n\n\n\n\n\n\nможно кастомизировать, изменив их стиль, размер, расположение и прочие параметры. Например, в данном случае целесообразно переместить их в левый верхний угол и уменьшить в размере:\n\nsuppl = list(\n  annotation_north_arrow(style = north_arrow_fancy_orienteering(),\n                         height = unit(1, 'cm'),\n                         width = unit(1, 'cm'),\n                         pad_x = unit(0.05, \"cm\"),\n                         pad_y = unit(0.7, \"cm\"),\n                         which_north = \"true\",\n                         location = 'tl'),\n  annotation_scale(location = 'tl',\n                   style = 'ticks',\n                   height = unit(0.1, \"cm\"),\n                   pad_y = unit(0.2, \"cm\"),\n                   pad_x = unit(2.0, \"cm\"))\n)\n\nmap_pl + suppl",
    "crumbs": [
      "Пространственные данные и карты",
      "<span class='chapter-number'>10</span>  <span class='chapter-title'>Основы картографии</span>"
    ]
  },
  {
    "objectID": "10-Maps.html#карты-врезки",
    "href": "10-Maps.html#карты-врезки",
    "title": "10  Основы картографии",
    "section": "10.9 Карты-врезки",
    "text": "10.9 Карты-врезки\nКарты-врезки используются для того чтобы дополнить картографическое изображение пространственной информацией, которая не помещается на основное изображение. Достаточно часто такие карты показывают:\n\nфрагменты изображаемой территории в более крупном масштабе;\nту же самую территорию или ее окружение в более мелком масштабе;\n\nПри этом с содержательной точки зрения карты-врезки могут как быть идентичными основной карте (показывать те же явления, но в другом масштабе), так и отличаться от нее. Например, на гидрогеологической картах врезки показывают артезианские бассейны для той же территории.\nВ качестве примера врезки разместим карту Европы, которая показывает местоположение отображаемой страны на карте Европы и выделяет ее другим цветом. Для этого понадобится создать карту-врезку как новый объект ggplot и добавить ее на основную карту на слой аннотаций как объект ggplotGrob.\nНачнем с построения карты-врезки:\n\ninset_map = ggplot() +\n  geom_sf(data = cnt110, linewidth = 0.25,\n          fill = 'grey',\n          show.legend = FALSE) +\n  geom_sf(data = filter(cnt110, SOVEREIGNT == 'Poland'), \n          fill = 'cyan', linewidth = 1,\n          show.legend = FALSE) +\n  coord_sf(crs = prj, label_graticule = '',\n           xlim = c(box[1], box[3]),\n           ylim = c(box[2], box[4])) +\n  theme_bw() +\n  theme(panel.background = element_rect(fill = 'azure'),\n        plot.margin = margin(0, 0, 0, 0, \"cm\"))\n\ninset_map\n\n\n\n\n\n\n\n\nТеперь разместим ее в одном из углов. Поскольку мы знаем ограничивающий прямоугольник отображаемой области, это сделать можно путем аффинных преобразований относительно выбранного угла карты. Например, относительно левого нижнего:\n\nlowleft = box_pl[c(1,2,1,2)] # левый нижний угол\nratio = (box[4] - box[2]) / (box[3] - box[1]) # пропорции карты-врезки\ndx = box_pl[3] - box_pl[1] # ширина основной карты\n\n# высота основной карты, как если бы она имела \n# такие же пропорции, как и врезка\ndy = dx * ratio \n\n# Находим ограничивающий прямоугольник врезки\n# Которая будет иметь длину стороны 0,25 от длины карты\n\nbox_ins = 0.25 * c(0, 0,  dx, dy) + lowleft \n\n# собираем аннотацию \ninset = annotation_custom(\n    grob = ggplotGrob(inset_map),\n    xmin = box_ins[1], xmax = box_ins[3],\n    ymin = box_ins[2], ymax = box_ins[4]\n)\n\nmap_pl +\n  suppl +\n  inset\n\n\n\n\n\n\n\n\nКод построения карты-врезки целесообразно вынести в функцию для последующего использования:\n\nannotation_inset = function(map, inset, scale = 0.25, rx = 0, ry = 0, scaledir = 'auto') {\n  \n  # Scale limits for main map\n  xlim = ggplot2::ggplot_build(map)$layout$panel_params[[1]]$x_range\n  ylim = ggplot2::ggplot_build(map)$layout$panel_params[[1]]$y_range\n  \n  # Scale limits for inset map\n  xlim_ins = ggplot2::ggplot_build(inset)$layout$panel_params[[1]]$x_range\n  ylim_ins = ggplot2::ggplot_build(inset)$layout$panel_params[[1]]$y_range\n  \n  if (scaledir == 'auto') {\n    along_x = diff(xlim)/diff(ylim) &lt; diff(xlim_ins)/diff(ylim_ins)\n    scaledir = ifelse(along_x, 'x', 'y')\n    message('Scaling inset along ', scaledir, ' axis')\n  } else if (! (scaledir %in% c('x', 'y'))) {\n    stop('scaledir should be one of \"auto\", \"x\" or \"y\"')\n  }\n    \n  if (scaledir == 'x') {\n    ratio = diff(ylim_ins) / diff(xlim_ins)\n    xmax = diff(xlim)\n    ymax = xmax * ratio \n  } else {\n    ratio = diff(xlim_ins) / diff(ylim_ins)\n    ymax = diff(ylim)\n    xmax = ymax * ratio \n  }\n  \n  lowleft = c(xlim[1], ylim[1], xlim[1], ylim[1])\n  \n  box = scale * c(0, 0,  xmax, ymax) + lowleft\n\n  dx = rx * (xlim[2] - box[3])\n  dy = ry * (ylim[2] - box[4])\n  \n  ggplot2::annotation_custom(\n      grob = ggplot2::ggplotGrob(inset),\n      xmin = box[1] + dx, xmax = box[3] + dx,\n      ymin = box[2] + dy, ymax = box[4] + dy\n  )\n  \n}\n\nПрооверим работоспособность для 9 разных местоположений карты-врезки:\n\nmap_simple = ggplot() +\n  geom_sf(data = countries_vw, linewidth = 1) +\n  scale_x_continuous(limits = box_pl[c(1,3)]) +\n  scale_y_continuous(limits = box_pl[c(2,4)]) +\n  theme_bw() +\n  labs(x = NULL, y = NULL, title = 'Poland')\n\nfor (i in 0:2 / 2) \n  for (j in 0:2 / 2)\n    print(map_simple + annotation_inset(map_simple, inset_map, 0.3, i, j))",
    "crumbs": [
      "Пространственные данные и карты",
      "<span class='chapter-number'>10</span>  <span class='chapter-title'>Основы картографии</span>"
    ]
  },
  {
    "objectID": "10-Maps.html#basemaps_review",
    "href": "10-Maps.html#basemaps_review",
    "title": "10  Основы картографии",
    "section": "10.10 Краткий обзор",
    "text": "10.10 Краткий обзор\nДля просмотра презентации щелкните на ней один раз левой кнопкой мыши и листайте, используя кнопки на клавиатуре:\n\n\n\n\n\nПрезентацию можно открыть в отдельном окне или вкладке браузере. Для этого щелкните по ней правой кнопкой мыши и выберите соответствующую команду.",
    "crumbs": [
      "Пространственные данные и карты",
      "<span class='chapter-number'>10</span>  <span class='chapter-title'>Основы картографии</span>"
    ]
  },
  {
    "objectID": "10-Maps.html#questions_tasks_maps",
    "href": "10-Maps.html#questions_tasks_maps",
    "title": "10  Основы картографии",
    "section": "10.11 Контрольные вопросы и упражнения",
    "text": "10.11 Контрольные вопросы и упражнения\n\n10.11.1 Вопросы\n\nКакие типы геометрии ggplot2 позволяют визуализировать данные типа sf и stars?\nПеречислите масштабы (уровни детализации), на которых доступны данные Natural Earth.\nНужно ли для отображения карт средствами ggplot2 выполнять предварительное проецирование всех слоев в единую проекцию? Если нет, то каким образом можно задать желаемую проекцию отображения? Будет ли работать этот подход с растровыми данными?\nОбъясните, как избежать возникновения ложных участков границ и береговых линий при визуализации карт мира.\nКакие приемы можно использовать для того чтобы обеспечить хорошую читаемость подписей на карте, нагруженной границами?\nКакая функция позволяет строить координатную сетку в виде викторных объектов?\nЧто необходимо сделать с ограничивающим прямоугольником географической системы координат \\([-180; 180] \\times [-90; 90]\\), состоящим из 4 точек, чтобы его границы изгибались по внешней границе карты в соответствии проекцией? Какую функцию необходимо применить для этого?\nПри визуализации рельефа гипсометрическим способом отрицательные высоты на суше и на море показываются разными цветам. Если у вас сплошная цифровая модель рельефа на сушу и море в виде объекта stars, как можно добиться этого эффекта?\nКакая функция пакета rmapshaper позволяет выполнять геометрическое упрощение линий и полигонов? В чем визуальный недостаток линий, упрощенных алгоритмом Дугласа-Пейкера? Какой алгоритм лучше использовать для геометрического упрощения вместо него?\nОбъясните, как можно добиться того, чтобы точки пересечения (касания) объектов двух слоев оставались неподвижными при геометрическом упрощении (т.е. сохранялась топология объектов).\nЕсли на карте точечные объекты (например, населенные пункты) размещены слишком густо, как можно добиться их прореживания?\n\n\n\n10.11.2 Упражнения\n\nСкачайте базу данных и цифровую модель рельефа на территорию Сатинского полигона МГУ. Изучите содержимое базы данных и постройте на основе этих данных общегеографическую карту средствами ggplot2 в проекции UTM.\n\nОпционально: сделайте на карте врезку, которая показывает расположение полигона точкой на мелкомасштабной карте (в качестве основы используйте данные Natural Earth).\n\nИспользуя возможности ggplot2, и данные Natural Earth масштаба 10M, создайте политико-административную и физическую карты Африки в азимутальной равновеликой проекции. Определите самостоятельно необходимые для этого слои. В качестве данных о рельефе для физической карты скачайте цифровую модель рельефа GEBCO, оптимизированную для отображения в соответствующих масштабах.\n\n\n\n\nСамсонов Т.Е. Визуализация и анализ географических данных на языке R. М.: Географический факультет МГУ, 2023. DOI: 10.5281/zenodo.901911",
    "crumbs": [
      "Пространственные данные и карты",
      "<span class='chapter-number'>10</span>  <span class='chapter-title'>Основы картографии</span>"
    ]
  },
  {
    "objectID": "11-ThematicMaps.html#mapping_prerequisites",
    "href": "11-ThematicMaps.html#mapping_prerequisites",
    "title": "11  Тематические карты",
    "section": "11.1 Предварительные условия",
    "text": "11.1 Предварительные условия\nДля выполнения кода данной лекции вам понадобятся следующие пакеты:\n\nlibrary(dplyr)\n\n# Данные \nlibrary(readxl)\nlibrary(geodata)\nlibrary(WDI)\nlibrary(gapminder)\nlibrary(googlesheets4)\n\n# Картография\nlibrary(sf)\nlibrary(stars)\nlibrary(tmap)\nlibrary(mapsf)\nlibrary(mapview)\nlibrary(classInt)\n\noptions(scipen = 999)",
    "crumbs": [
      "Пространственные данные и карты",
      "<span class='chapter-number'>11</span>  <span class='chapter-title'>Тематические карты</span>"
    ]
  },
  {
    "objectID": "11-ThematicMaps.html#thematic_mapping_intro",
    "href": "11-ThematicMaps.html#thematic_mapping_intro",
    "title": "11  Тематические карты",
    "section": "11.2 Введение",
    "text": "11.2 Введение\nТематические карты представляют собой важный инструмент географических исследований. Таблицы и графики не дают полного представления о пространственном распределении изучаемого явления. Это знание способна дать исследователю карта.\nРазнообразие типов и видов карт достаточно велико. Комплексные картографические произведения, содержащие многослойный набор объектов, создаются, как правило, средствами геоинформационных пакетов. Такие карты требуют тщательной и кропотливой работы с легендой, устранения графических конфликтов между знаками, многократного редактирования входных данных, условий, фильтров и способов изображения в попытке достичь эстетичного и вместе с тем информативного результата.\nВ то же время, гораздо большее количество создаваемых в повседневной практике карт носят простой аналитический характер. Такие карты показывают одно, максимум два явления, и могут иллюстрировать входные данные, результаты промежуточных или итоговых расчетов. Создание именно таких карт целесообразно автоматизировать средствами программирования. В этом разделе мы познакомимся с созданием тематических карт средствами пакетов tmap и mapsf.",
    "crumbs": [
      "Пространственные данные и карты",
      "<span class='chapter-number'>11</span>  <span class='chapter-title'>Тематические карты</span>"
    ]
  },
  {
    "objectID": "11-ThematicMaps.html#данные-natural-earth",
    "href": "11-ThematicMaps.html#данные-natural-earth",
    "title": "11  Тематические карты",
    "section": "11.3 Данные Natural Earth",
    "text": "11.3 Данные Natural Earth\nДля работы нам понадобятся слои базы данных Natural Earth. Загрузим их локально:\n\nne = '/Volumes/Data/Spatial/Natural Earth/natural_earth_vector.gpkg'\ncountries = read_sf(ne, 'ne_110m_admin_0_countries')\ncoast = read_sf(ne, 'ne_110m_coastline')\nocean = read_sf(ne, 'ne_110m_ocean')\ncities = read_sf(ne, 'ne_110m_populated_places')\nrivers = read_sf(ne, 'ne_110m_rivers_lake_centerlines')\nlakes = read_sf(ne, 'ne_110m_lakes')\nland = read_sf(ne, 'ne_110m_land')\nborders = read_sf(ne, 'ne_110m_admin_0_boundary_lines_land')\n\nlyr = lst(ocean, land, coast, countries, \n          rivers, lakes, cities, borders)\n\n\n11.3.1 Данные WorldClim\nWorldClim — это открытые сеточные наборы климатических характеристик с пространственным разрешением от \\(30''\\) (около 1 км) до \\(10'\\) (около 20 км). Данные можно выгрузить в виде файлов GeoTiff, однако эту операцию можно сделать и программным путем через пакет geodata — используя функцию worldclim_global().\nВыполним загрузку 10-минутного растра с суммарным количеством осадков за год:\n\nprec = geodata::worldclim_global(var = \"prec\", res = 10, path = 'data') |&gt; \n  st_as_stars() # преобразуем в stars для удобства работы\nplot(prec) # это 12-канальный растр\n\n\n\n\n\n\n\n\n\nИспользовать программную загрузку целесообразно для небольших наборов данных. Если счет пошел на десятки мегабайт и выше, следует все-таки выкачать данные в виде файла и работать с ним.\n\nВыполним трансформирование данных в проекцию Миллера. Для того чтобы карта не обрезалась по охвату растра (он не включает данные на Антарктиду), необходимо расширить его охват на весь земной шар. Для этого используем функцию extend() из пакета raster:\n\nprecp = prec |&gt; \n  st_warp(crs = \"+proj=mill\")\n\nlyrp = lapply(lyr, st_transform, crs = \"+proj=mill\") # Цилиндрическая проекция Миллера\n\nВизуализируем полученные данные на карте:\n\n# Визуализируем данные на январь:\nplot(precp[,,,1], \n     main = 'Количество осадков в январе, мм',\n     reset = FALSE) # разрешаем добавлять объекты на карту.\nplot(st_geometry(lyrp$ocean), border = 'steelblue', \n     col = 'lightblue', add = TRUE)",
    "crumbs": [
      "Пространственные данные и карты",
      "<span class='chapter-number'>11</span>  <span class='chapter-title'>Тематические карты</span>"
    ]
  },
  {
    "objectID": "11-ThematicMaps.html#тематические-карты-в-tmap",
    "href": "11-ThematicMaps.html#тематические-карты-в-tmap",
    "title": "11  Тематические карты",
    "section": "11.4 Тематические карты в tmap",
    "text": "11.4 Тематические карты в tmap\n\n11.4.1 Способы изображения\n\nВ этом разделе изложение сосредоточено на параметрах способов изображения. Приведение легенд и компоновки карты в аккуратный вид рассматривается далее в разделе Компоновка.\n\nПакет tmap предоставляет простой в использовании и достаточно мощный механизм формирования тематических карт. Шаблон построения карты в этом пакете напоминает ggplot и выглядит следующим образом:\n\ntm_shape(&lt;DATA&gt;) +\n  tm_&lt;METHOD&gt;(&lt;PARAMETERS&gt;)\n\nгде:\n\nDATA - объект пространственного типа (sf, sp, stars или raster)\nMETHOD - метод визуализации этого объекта (способ изображения)\nPARAMETERS - параметры метода\n\n\n\n11.4.2 Векторные данные\nДля реализации качественного и количественного фона, а также картограмм используется метод tm_polygons(). Он автоматически определяет тип переменной и строит соответствующую шкалу:\n\ntm_shape(lyrp$countries) +\n  tm_polygons('ECONOMY') + # качественная переменная\ntm_shape(lyrp$ocean)+\n  tm_fill(col = 'azure') +\n  tm_borders(col = 'steelblue')\n\n\n\n\n\n\n\n\nКоличественный фон или картограммы получаются при картографировании числового показателя применением той же функции tm_polygons():\n\nlifexp = WDI::WDI(indicator = 'SP.DYN.LE00.IN')\ngap = read_excel('data/gapminder.xlsx', 2)\n\nlifedf = left_join(gap, \n                   filter(lifexp, year == 2016), \n                   by = c('name' = 'country')) |&gt;\n  rename(lifexp = SP.DYN.LE00.IN) |&gt; \n  mutate(geo = stringr::str_to_upper(geo))\n\ncoun = lyrp$countries |&gt; \n  left_join(lifedf, by = c('ADM0_A3' = 'geo'))\n\ntm_shape(coun) +\n  tm_polygons('lifexp', border.col = 'gray20') + # количественная переменная\ntm_shape(lyrp$ocean) +\n  tm_fill(col = 'azure') +\n  tm_borders(col = 'steelblue4')\n\n\n\n\n\n\n\n\nДля реализации способа картодиаграмм используется геометрия tm_bubbles(). Чтобы оставить отображение границ полигонов, нам необходимо к одной геометрии применить несколько способов изображения:\n\ntm_shape(lyrp$ocean) +\n  tm_fill(col = 'lightblue') +\n  tm_borders(col = 'steelblue') +\ntm_shape(lyrp$countries) +\n  tm_fill(col = 'white') +\n  tm_borders(col = 'grey') +\n  tm_bubbles('GDP_MD_EST', \n             scale = 3,\n             col = 'red', \n             alpha = 0.5) # количественная переменная\n\n\n\n\n\n\n\n\nАналогичным образом реализуется значковый способ применительно к объектам, локализованным по точкам. Картографируем численность населения по крупнейшим городам:\n\ntm_shape(lyrp$countries) +\n  tm_fill(col = 'white') +\n  tm_borders(col = 'grey') +\ntm_shape(lyrp$ocean) +\n  tm_fill(col = 'lightblue') +\n  tm_borders(col = 'steelblue') +\ntm_shape(lyrp$cities) +\n  tm_bubbles('POP2015', col = 'olivedrab', alpha = 0.8)\n\n\n\n\n\n\n\n\nНадписи объектов на карте размещаются с помощью функции tm_text. Данная функция содержит весьма полезные параметры remove.overlap и auto.placement, которые позволяют убрать перекрывающиеся подписи и автоматически разместить из вокруг точек так, чтобы уменьшить перекрытия с самими знаками и другими подписями. Дополним предыдущую карту названиями городов:\n\ntm_shape(lyrp$countries) +\n  tm_fill(col = 'white') +\n  tm_borders(col = 'grey') +\ntm_shape(lyrp$ocean) +\n  tm_fill(col = 'lightblue') +\n  tm_borders(col = 'steelblue') +\ntm_shape(lyrp$cities) +\n  tm_bubbles('POP2015', col = 'olivedrab', alpha = 0.8) +\n  tm_text('name_ru', size = 0.5, remove.overlap = TRUE, auto.placement = TRUE)\n\n\n\n\n\n\n\n\n\n\n11.4.3 Растровые данные\nПри отображении растровых данных используется способ отображения tm_raster(). В случае отображения количественных растров Параметр breaks определяет границы интервалов, для которых будут использованы цвета, взятые из параметра palette:\n\n# box = st_bbox(c(xmin = -180, xmax = 180, ymax = 90, ymin = -90), crs = st_crs(4326))\n\nramp = colorRampPalette(c('white', 'darkcyan'))\n\ntm_shape(precp[,,,1]) +\n    tm_raster('prec1',\n              breaks = c(0, 50, 100, 200, 500, 1000),\n              palette = ramp(5)) +\ntm_shape(lyrp$ocean) +\n  tm_fill(col = 'lightblue') +\n  tm_borders(col = 'steelblue')\n\n\n\n\n\n\n\n\nРастровые данные могут хранить и качественную информацию: например, тип почв или вид землепользования. В качестве примера визуализируем типы земельного покрова (land cover) из растрового стека land, который есть в пакете tmap. Цвета здесь выбираются автоматически, их настройка рассматривается в следующем параграфе:\n\ndata(land, package = 'tmap')\n\ntm_shape(land) +\n  tm_raster('cover')\n\n\n\n\n\n\n\n\n\n\n11.4.4 Цветовые шкалы\nДля изменения цветовой шкалы при определении способа изображения вы можете определить параметр palette. Пакет tmap позволяет работать с цветовыми палитрами Color Brewer или задавать цвета вручную. Очень удобным инструментом подбора шкалы является функция palette_explorer() из пакета tmaptools. При вызове функции открывается интерактивное приложение, позволяющее менять настройки цветовых палитр:\n\ntmaptools::palette_explorer()\n\n\n\n\nПриложение Palette Explorer из пакета tmaptools\n\n\nДанных палитр хватит для решения большинства задач по картографической визуализации. Применим категориальную палитру Dark2:\n\ntm_shape(lyrp$countries) +\n  tm_polygons('ECONOMY', palette = 'Dark2') + # качественная переменная\ntm_shape(lyrp$ocean)+\n  tm_fill(col = 'azure') +\n  tm_borders(col = 'steelblue')\n\n\n\n\n\n\n\n\nДля количественного показателя (количество осадков) применим палитру PuBuGn:\n\ntm_shape(precp[,,,1]) +\n    tm_raster('prec1',\n              breaks = c(10, 50, 100, 200, 500, 1000),\n              palette = 'PuBuGn') +\ntm_shape(lyrp$ocean) +\n  tm_fill(col = 'lightblue') +\n  tm_borders(col = 'steelblue')\n\n\n\n\n\n\n\n\nВы всегда можете, конечно, определить цвета вручную. В этом случае их количество должно совпадать с количеством интервалов классификации:\n\ntm_shape(precp[,,,1]) +\n    tm_raster('prec1',\n              breaks = c(10, 50, 100, 200, 500, 1000),\n              palette = c('white', 'gray80', 'gray60', 'gray40', 'gray20')) +\ntm_shape(lyrp$ocean) +\n  tm_fill(col = 'lightblue') +\n  tm_borders(col = 'steelblue')\n\n\n\n\n\n\n\n\nДля категориальных данных необходимо тщательно подбирать цвета, стандартные шкалы тут могут не подойти (более подробно о шкалах — далее). Для вышеприведенного примера с растром типов земельного покрова можно подобрать следующие цвета:\n\npal = c(\"#003200\", \"#3C9600\", \"#006E00\", \"#556E19\", \"#00C800\", \"#8CBE8C\",\n           \"#467864\", \"#B4E664\", \"#9BC832\", \"#EBFF64\", \"#F06432\", \"#9132E6\",\n           \"#E664E6\", \"#9B82E6\", \"#B4FEF0\", \"#646464\", \"#C8C8C8\", \"#FF0000\",\n           \"#FFFFFF\", \"#5ADCDC\")\n\ntm_shape(land) +\n  tm_raster('cover', palette = pal)\n\n\n\n\n\n\n\n\n\n\n11.4.5 Классификация\n\n11.4.5.1 Методы классификации\nКлассификация данных — важнейший этап картографирования, который во многом определяет, как данные будут представлены на карте и какие географические выводы читатель сделает на ее основе. Существует множество методов классификации числовых рядов. Классифицировать данные автоматически можно с помощью функции classIntervals() из пакета classInt. Наберите в консоли ?classInt чтобы прочитать справку о методах классификации.\nПосмотрим несколько методов классификации. Первый параметр функции classInt — это числовой ряд. Число классов следует передать в параметр n =, метод классификации указывается в параметре style =.\nДля начала попробуем метод равных интервалов, который просто делит размах вариации (диапазон от минимума до максимум) на \\(n\\) равных интервалов. Функция plot() применительно к созданной классификации рисует замечательный график, на котором показаны границы классов и эмпирическая функция распределения показателя. В параметр pal можно передать цветовую палитру:\n\n# Запишем число классов в переменную\nnclasses = 5\n\nintervals = classIntervals(countries$POP_EST, \n                           n = nclasses, \n                           style = \"equal\")\n\n# извлечь полученные границы можно через $brks\nintervals$brks\n## [1]        140  279543112  559086084  838629056 1118172028 1397715000\n\nplot(intervals, pal = ramp(nclasses), cex=0.5, main = \"Равные интервалы MIN/MAX\")\n\n\n\n\n\n\n\n\nСозданные интервалы хоть и равны, но не аккуратны. Зато метод классификации \"pretty\" создает также равные интервалы, но может слегка расширить диапазон или добавить 1 класс, чтобы получить границы интервалов, округленные до целых чисел:\n\nintervals = classIntervals(countries$POP_EST, \n                           n = nclasses, \n                           style = \"pretty\")\nintervals$brks\n## [1]          0  200000000  400000000  600000000  800000000 1000000000 1200000000\n## [8] 1400000000\nplot(intervals, pal = ramp(nclasses), cex=0.5, main = \"Округленные равные интервалы\")\n\n\n\n\n\n\n\n\nКвантили — равноколичественные интервалы. В каждом классе содержится одинаковое число объектов:\n\nintervals = classIntervals(countries$POP_EST, n = nclasses, style = \"quantile\")\nintervals$brks\n## [1]        140    2527151    6891418   16156569   39056177 1397715000\nplot(intervals, pal = ramp(nclasses), \n     cex=0.5, main = \"Квантили (равноколичественные)\")\n\n\n\n\n\n\n\n\nМетод “естественных интервалов”, или метод Фишера-Дженкса позволяет найти классы, максимально однородные внутри и при этом максимально отличающиеся друг от друга:\n\nintervals = classIntervals(countries$POP_EST, n = nclasses, style = \"jenks\")\nintervals$brks\n## [1]        140   23568378   69625582  163046161  328239523 1397715000\nplot(intervals, pal = ramp(nclasses), cex=0.5, main = \"Естественные интервалы\")\n\n\n\n\n\n\n\n\n\n\n11.4.5.2 Применение на картах\nЧтобы использовать заранее вычисленные интервалы классификации, их необходимо подать в параметр breaks при построении карты:\n\nbrks = classIntervals(countries$POP_EST, \n                      n = 7, \n                      style = \"jenks\")$brks\n\ntm_shape(lyrp$countries) +\n  tm_polygons('POP_EST', \n              border.col = 'gray20',\n              palette = 'YlGn',\n              breaks = brks) + # количественная переменная\ntm_shape(lyrp$ocean) +\n  tm_fill(col = 'azure') +\n  tm_borders(col = 'steelblue4')\n\n\n\n\n\n\n\n\nАналогичным путем работают шкалы для растровых данных:\n\ntm_shape(precp[,,,1]) +\n    tm_raster('prec1',\n              breaks = classIntervals(sample(precp[,,,1][[1]], 1000), n = 5, style = \"jenks\", na.rm = TRUE)$brks,\n              palette = 'PuBuGn') +\ntm_shape(lyrp$ocean) +\n  tm_fill(col = 'lightblue') +\n  tm_borders(col = 'steelblue')\n\n\n\n\n\n\n\n\n\nУчтите, что метод естественных интервалов — ресурсоемкий в вычислительном плане. Поэтому если вы хотите с его помощью классифицировать растровые данные, целесообразно сделать выборку не более чем из нескольких тысяч пикселов. Иначе придется долго ждать.\n\nДля классификации естественными интервалами сделаем выборку в 2 000 значений с растра c помощью функции sampleRandom() из пакета raster:\n\nsmpl = sample(precp[,,,1][[1]], 2000) \n\ntm_shape(precp[,,,1]) +\n    tm_raster('prec1',\n              breaks = classIntervals(smpl, n = 5, style = \"jenks\")$brks,\n              palette = 'PuBuGn') +\ntm_shape(lyrp$ocean) +\n  tm_fill(col = 'lightblue') +\n  tm_borders(col = 'steelblue')\n\n\n\n\n\n\n\n\n\n\n\n11.4.6 Классификация при отображении\nПакет tmap позволяет выполнять классификацию данных непосредственно при отображении. Это бывает удобно, когда одну и ту же классификацию не надо использовать несколько раз, и когда нет необходимости делать выборку значений (как в случае метода естественных интервалов). Для этого функции способов изображения предлагают несколько параметров:\n\nn — количество классов\nstyle — метод классификации (так же как и в classIntervals())\nbreaks — значения границ интервалов (необходимы, если style == fixed)\ninterval.closure — замыкание интервала (по умолчанию стоит left, что означает, что в интервал включается нижняя граница, за исключением последнего интервала, включающего и нижнюю и верхнюю границу)\nmidpoint — нейтральное значение, которое используется для сопоставления с центральным цветом в расходящихся цветовых палитрах\n\nПостроим карту продолжительности жизни, используя классификацию при отображении:\n\ntm_shape(lyrp$countries) +\n  tm_polygons('POP_EST', \n              palette = 'YlGn',\n              n = 5,\n              style = 'fisher',\n              border.col = 'gray20') + # количественная переменная\ntm_shape(lyrp$ocean) +\n  tm_fill(col = 'azure') +\n  tm_borders(col = 'steelblue4')\n\n\n\n\n\n\n\n\nУстановка средней точки при классификации оказывается очень полезной в тех случаях, когда данные являются биполярными. Покажем это на примере данных WorldClim по температуре:\n\ntemp = geodata::worldclim_global(var = \"tavg\", res = 10, \n                                 path = 'data') |&gt; \n  st_as_stars() |&gt; \n  rename(tavg = 1) |&gt; \n  st_warp(crs = \"+proj=mill\")\n\nВизуализируем данные по температуре, используя классическую красно-бело-синюю палитру RdBu и нейтральную точку 0 градусов по Цельсию. По умолчанию в данной палитре красный цвет соответствует малым значениям. пакет tmap позволяет инвертировать цвета палитры, добавив знак минус перед ее названием. Помимо этого, для размещения положительных значений наверху выполним обратную сортировку элементов легенды, используя параметр legend.reverse = TRUE:\n\ntm_shape(temp[,,,3]) +\n    tm_raster('tavg',\n              n = 11,\n              midpoint = 0,\n              style = 'pretty',\n              legend.reverse = TRUE,\n              palette = '-Spectral') +\ntm_shape(lyrp$ocean) +\n  tm_fill(col = 'azure') +\n  tm_borders(col = 'steelblue')\n\n\n\n\n\n\n\n\n\n\n11.4.7 Пропущенные данные\nВесьма важно отметить на карте области, для которых данные отсутствуют. Вы могли обратить внимание, что для способов изображения, применимых к векторным данным, tmap автоматически добавляет класс легенды, который отвечает за пропуски. Для растров, однако, он это не делает. Чтобы принудительно вывести в легенду и на карту символ, отвечающий за пропущенные значения, необходимо определить параметр colorNA. Обычно, в зависимости от цветовой палитры легенды, для этого используют серый или белый цвет:\n\ntm_shape(temp[,,,1]) +\n    tm_raster('tavg',\n              colorNA = 'grey', # определяем цвет для пропущенных значений\n              n = 11,\n              midpoint = 0,\n              style = 'pretty',\n              legend.reverse = TRUE,\n              palette = '-RdBu') +\ntm_shape(lyrp$ocean) +\n  tm_fill(col = 'azure') +\n  tm_borders(col = 'steelblue')\n\n\n\n\n\n\n\n\n\n\n11.4.8 Компоновка\nПакет tmap предоставляет широкий набор настроек компоновки картографического изображения, который включает настройку легенды, заголовка карты и ряда других важных параметров. Большинство настроек компоновки осуществляется через функцию tm_layout(), однако часть из них, специфичная для конкретного слоя, определяется непосредственно при настройке способа изображения.\nВ примере ниже показано, как:\n\nдобавить заголовок карты (main.title),\nразместить легенду в нижнем левом углу (legend.position = c('left', 'bottom'))\nпоместить ее легенду в полупрозрачный прямоугольник (параметры legend&lt;...&gt;),\nубрать заголовок легенды (title),\nзаменить стандартный шрифт на Open Sans (fontfamily):\n\n\ntm_shape(lyrp$countries) +\n  tm_polygons('ECONOMY', title = '') + # убираем заголовок легенды\ntm_shape(lyrp$ocean)+\n  tm_fill(col = 'azure') +\n  tm_borders(col = 'steelblue') +\ntm_layout(legend.position = c('left', 'bottom'),\n          fontfamily = 'PT Sans', # шрифт\n          main.title.size = 1.2,   # масштаб шрифта в заголовке\n          main.title = 'Тип экономики', # заголовок\n          legend.frame = TRUE, # рамка вокруг легенды\n          legend.frame.lwd = 0.2, # толщина рамки вокруг легенды\n          legend.bg.alpha = 0.8, # прозрачность фона в легенде\n          legend.bg.color = 'white') # цвет фона легенды\n\n\n\n\n\n\n\n\nДля того чтобы определить заголовок легенды размера значка или диаграммы, необходимо задать параметр title.size. Помимо этого, легенду можно пристыковать непосредственно к рамке карты, если задать значения параметра legend.position в верхнем регистре:\n\ntm_shape(lyrp$ocean) +\n  tm_fill(col = 'lightblue') +\n  tm_borders(col = 'steelblue') +\ntm_shape(lyrp$countries) +\n  tm_fill(col = 'white') +\n  tm_borders(col = 'grey') +\n  tm_bubbles('GDP_MD_EST', \n             scale = 2.5,\n             col = 'red', \n             alpha = 0.5,\n             title.size = '$ млн') + # количественная переменная\ntm_layout(legend.position = c('LEFT', 'BOTTOM'), # верхний регистр — легенда встык\n          fontfamily = 'Open Sans', # шрифт\n          main.title.size = 1.2,   # масштаб шрифта в заголовке\n          main.title = 'Валовый внутренний продукт стран мира', # заголовок\n          frame.lwd = 2,\n          legend.frame = TRUE, # рамка вокруг легенды\n          legend.frame.lwd = 0.5, # толщина рамки вокруг легенды\n          legend.bg.color = 'white') # цвет фона легенды\n\n\n\n\n\n\n\n\nПо умолчанию tmap размещает легенду внутри фрейма картографического изображения. Однако ее можно вынести и наружу, используя параметр legend.outside функции tm_layout(). В примере ниже показано также, как можно\n\nзадать текст легенды для отсутствующих данных (textNA),\nотформатировать разделитель в легенде с интервалами значений (legend.format),\nубрать рамку карты (frame),\nсдвинуть заголовок вдоль строки, выровняв его с центром карты (main.title.position):\n\n\ntm_shape(lyrp$countries) +\n  tm_polygons('POP_EST', \n              border.col = 'gray20', \n              palette = 'YlGn',\n              n = 4,\n              style = 'jenks',\n              title = 'Чел.',\n              colorNA = 'lightgray',\n              textNA = 'Нет данных',\n              legend.format = list(text.separator = '—')) + # количественная переменная\ntm_shape(lyrp$ocean) +\n  tm_fill(col = 'azure') +\n  tm_borders(col = 'steelblue4') +\ntm_layout(frame = FALSE,\n          main.title.position = 0.5,\n          legend.outside = TRUE,\n          legend.outside.position = 'right',\n          fontfamily = 'Open Sans',\n          main.title.size = 1.2,\n          main.title = 'Численность населения',\n          legend.bg.color = 'white')\n\n\n\n\n\n\n\n\nДля отображения координатной сетки вы можете использовать функцию tm_grid(). По умолчанию она строит координатную сетку в единицах измерения проекции. Однако если требуется градусная сетка, то ее можно определить, используя параметр projection = 4326:\n\ntm_shape(temp[,,,1]) +\n  tm_raster('tavg',\n            title = '°C',\n            colorNA = 'grey', # определяем цвет для пропущенных значений\n            textNA = 'Нет данных',\n            legend.format = list(text.separator = '—'),\n            n = 11,\n            midpoint = 0,\n            style = 'pretty',\n            legend.reverse = TRUE,\n            palette = '-RdBu') +\ntm_shape(lyrp$ocean) +\n  tm_fill(col = 'azure') +\n  tm_borders(col = 'steelblue') +\ntm_layout(legend.position = c('left', 'bottom'),\n          fontfamily = 'Open Sans',\n          main.title.size = 1.2,\n          main.title = 'Средняя температура января',\n          legend.frame = TRUE,\n          legend.frame.lwd = 0.2,\n          legend.bg.alpha = 0.5,\n          legend.bg.color = 'white') +\ntm_graticules(x = seq(-150, 150, by = 30),\n        y = seq(-60, 60, by = 30),\n        lwd = 0.2,\n        col = \"black\")\n\n\n\n\n\n\n\n\nПодписи сетки координат можно добавить и для более сложных проекций, однако располагаться они будут по-прежнему вдоль осей X и Y. В примере ниже также показано как можно увеличить расстояние между заголовком и картой, определив более крупный отступ от верхней стороны в параметре inner.margins:\n\ntm_shape(coun, projection = '+proj=moll') +\n  tm_polygons('lifexp', \n              palette = 'YlGn',\n              n = 4,\n              style = 'jenks',\n              border.col = 'gray20', \n              title = 'Лет',\n              colorNA = 'lightgray',\n              textNA = 'Нет данных',\n              legend.reverse = TRUE,\n              legend.format = list(text.separator = '—')) + # количественная переменная\ntm_shape(lyrp$ocean) +\n  tm_fill(col = 'azure') +\n  tm_borders(col = 'steelblue4') +\ntm_layout(frame = FALSE,\n          main.title.position = 0.22,\n          legend.outside = TRUE,\n          legend.outside.position = 'right',\n          fontfamily = 'Open Sans',\n          main.title.size = 1.2,\n          main.title = 'Продолжительность жизни',\n          legend.bg.color = 'white',\n          outer.margins = c(0.02, 0.05, 0.02, 0.02),\n          inner.margins = c(0.02, 0.02, 0.07, 0.02)) +\ntm_graticules(x = seq(-150, 150, by = 30),\n        y = seq(-60, 60, by = 30),\n        lwd = 0.2,\n        col = \"black\")\n\n\n\n\n\n\n\n\n\n\n11.4.9 Фасеты и серии карт\nФасетная компоновка предполагает, упорядочение элементов в матричной форме на одной странице. Как правило, картографические фасеты идентичны по содержанию, но показывают одно и то же явление при различных заданных условиях: за разные года, по разным странам и т.д. Создание фасет с помощью tmap осуществляется с помощью специальной функции tm_facets(), которой необходимо передать название переменной, отвечающей за разделение. В свою очередь, это означает, что данные должны быть приведены к «длинной» форме (если информация за разные года содержится в разных столбцах, то нужно год записать в отдельную переменную). Здесь вам пригодится знание пакета tidyr.\nРассмотрим создание фасет на примере данных Gapminder по средней продолжительности жизни c 1960 по 2010 г:\n\nlifexp_dec = lifexp |&gt; \n  filter(year %in% c(1960, 1970, 1980, 1990, 2000, 2010))\n\nlifedf_dec = left_join(gap, lifexp_dec, by = c('name' = 'country')) |&gt;\n  rename(lifexp = SP.DYN.LE00.IN) |&gt; \n  mutate(geo = stringr::str_to_upper(geo))\n\ncoun_dec = lyrp$countries |&gt;  \n  left_join(lifedf_dec, by = c('ADM0_A3' = 'geo'))\n\nСоздадим серию карт за разные года:\n\ntm_shape(coun_dec) +\n  tm_polygons('lifexp', \n              palette = 'YlGnBu',\n              n = 3,\n              style = 'pretty',\n              border.col = 'gray20', \n              title = 'Лет',\n              colorNA = 'lightgray',\n              textNA = 'Нет данных',\n              legend.reverse = TRUE,\n              legend.format = list(text.separator = '—')) + # количественная переменная\n  tm_facets(by = 'year',\n            free.coords = FALSE,\n            drop.units = TRUE,\n            drop.NA.facets = TRUE,\n            ncol = 2) +\ntm_shape(lyrp$ocean) +\n  tm_fill(col = 'azure') +\n  tm_borders(col = 'steelblue4') +\ntm_layout(frame = FALSE,\n          legend.outside = TRUE,\n          legend.outside.position = 'bottom',\n          fontfamily = 'Open Sans',\n          main.title.size = 1.2,\n          main.title = 'Средняя продолжительность жизни',\n          legend.bg.color = 'white',\n          outer.margins = c(0.02, 0.1, 0.02, 0.02),\n          inner.margins = c(0.02, 0.02, 0.07, 0.02))\n\n\n\n\n\n\n\n\nФасетные карты по растровым данным в настоящий момент не поддерживаются в пакете tmap, но вы можете создать их, используя функцию tmap_arrange(), которая принимает на вход список из карт tmap и упорядочивает их в фасетной компоновке.\nВ примере ниже показано, как:\n\nвычислить равноступенную шкалу, единую для всех карт — используя максимум и минимум по всем растрам из стека, а также функцию fullseq() из пакета scales, заведомо накрывающую указанный диапазон значений интервалами заданного размера.\nприменить функционал map2()из пакета purrr (входит в tidyverse) для одновременной итерации по двум спискам: названий растров в стеке (X) и названий месяцев (Y), которые нужны для формирования заголовков\nупорядочить карты по регулярной сетке с двумя столбцами и полями отступа каждой фасеты (параметр outer.margins), используя tmap_arrange()\n\n\nminval = min(temp[[1]], na.rm = TRUE)\nmaxval = max(temp[[1]], na.rm = TRUE)\n\nbrks = scales::fullseq(c(minval, maxval), 10)\n\nmonths = c('Январь', 'Февраль', 'Март', 'Апрель', \n           'Март', 'Июнь', 'Июль', 'Август', \n           'Сентябрь', 'Октябрь', 'Ноябрь', 'Декабрь')\n\ntm_shape(temp) +\n    tm_raster('tavg',\n              title = '°C',\n              colorNA = 'grey', # определяем цвет для пропущенных значений\n              textNA = 'Нет данных',\n              legend.format = list(text.separator = '—'),\n              breaks = brks,\n              midpoint = 0,\n              style = 'fixed',\n              legend.reverse = TRUE,\n              palette = '-RdBu') +\n  tm_shape(lyrp$ocean) +\n    tm_fill(col = 'azure') +\n    tm_borders(col = 'steelblue') +\n  tm_layout(legend.position = c('LEFT', 'BOTTOM'),\n            fontfamily = 'Open Sans',\n            main.title.size = 1.2,\n            main.title = 'Среднемесячная температура',\n            legend.frame = TRUE,\n            legend.frame.lwd = 0.2,\n            legend.bg.alpha = 0.8,\n            legend.bg.color = 'white',\n            inner.margins = c(0, 0, 0, 0)) +\n  tm_graticules(x = seq(-150, 150, by = 30),\n        y = seq(-60, 60, by = 30),\n        lwd = 0.2,\n        col = \"black\")\n\n\n\n\n\n\n\n# tmap_arrange(maps, asp = NA, ncol = 2,\n#              outer.margins = 0.05)\n\n\n\n11.4.10 Картографические анимации\nКартографические анимации вы пакете tmap создаются путем следующей последовательности действий:\n\nДобавить в построение карты функцию tm_facets(along = \"name\"), где name — название атрибута, значения которого отвечают за каждый кадр анимации.\nЗаписать созданную карту в переменную (условно назовем ее map).\nВызвать для созданной переменной функцию tmap_animation(map, filename = \"filename.gif\", delay = 25), определив имя файла и задержку в миллисекундах между кадрами.\n\n\nВнимание: для того чтобы работало построение анимаций средствами tmap, на вашем компьютере должна быть установлена библиотека ImageMagick.\n\nДля примера построим анимацию по данным изменения средней продолжительности жизни:\n\nmap = tm_shape(coun_dec) +\n  tm_polygons('lifexp', \n              palette = 'YlGnBu',\n              n = 3,\n              style = 'pretty',\n              border.col = 'gray20', \n              title = 'Лет',\n              colorNA = 'lightgray',\n              textNA = 'Нет данных',\n              legend.reverse = TRUE,\n              legend.format = list(text.separator = '—')) + # количественная переменная\n  tm_facets(along = 'year',\n            free.coords = FALSE,\n            drop.units = TRUE) +\ntm_shape(lyrp$ocean) +\n  tm_fill(col = 'azure') +\n  tm_borders(col = 'steelblue4') \n\ntmap_animation(map, 'images/lifexp.gif', delay = 100)\n\n\n\n\n11.4.11 Интерактивные карты\nЛюбую карту tmap можно перевести в интерактивный режим с помощью функции tmap_mode() с параметром 'view'. Управлять дополнительными параметрами, специфичными для интерактивного режима, можно используя функцию tm_view(). В частности, можно установить координаты центра карты и масштабный уровень в параметре set.view и ограничить диапазон масштабных уровней в параметре set.zoom.limits. Состав полей, значения которых отображаются во всплывающем окне при щелчке на символе, определяются параметром popup.vars:\n\ntmap_mode('view')\ntmap_options(check.and.fix = TRUE)\n\nsf::sf_use_s2(FALSE)\ntm_shape(coun) +\n  tm_polygons('lifexp', \n              border.col = 'gray20', \n              palette = 'YlGn',\n              n = 4,\n              style = 'jenks',\n              title = 'Лет',\n              colorNA = 'lightgray',\n              textNA = 'Нет данных',\n              legend.format = list(text.separator = '—'),\n              popup.vars = c('SOVEREIGNT', 'lifexp')) + # поля для всплывающего окна\ntm_view(set.view = c(20, 45, 2),    # центр карты и масштабный уровень\n        set.zoom.limits = c(1, 4))\n\n\n\n\n\nЧтобы добавить карту-подложку, необходимо предварительно вызвать функцию tm_basemap(), передав ей название картографического сервиса. В примере ниже также показано, как можно сделать размер кружка постоянным во всех масштабах (параметр symbol.size.fixed):\n\ntmap_mode('view')\ntmap_options(check.and.fix = TRUE)\n\ncoun = coun |&gt; mutate(GDP_SCALED = round(0.001 * GDP_MD_EST))\n\ntm_basemap(\"OpenStreetMap\") +\ntm_shape(coun) +\n  tm_borders(col = 'black', alpha = 0.5, lwd = 0.3) +\ntm_shape(st_point_on_surface(coun)) + # делаем точки, чтобы диаграммы были точно внутри\n  tm_bubbles('GDP_SCALED', \n             scale = 3,\n             col = 'violetred', \n             alpha = 0.5,\n             popup.vars = c('SOVEREIGNT', 'GDP_SCALED')) +\n  tm_text('GDP_SCALED', size = 'GDP_SCALED', \n          remove.overlap = TRUE,\n          size.lowerbound = 0.2,\n          scale = 2) +\ntm_view(set.view = c(20, 45, 3),\n        set.zoom.limits = c(2, 4),\n        symbol.size.fixed = TRUE,\n        text.size.variable = TRUE)",
    "crumbs": [
      "Пространственные данные и карты",
      "<span class='chapter-number'>11</span>  <span class='chapter-title'>Тематические карты</span>"
    ]
  },
  {
    "objectID": "11-ThematicMaps.html#тематические-карты-в-mapsf",
    "href": "11-ThematicMaps.html#тематические-карты-в-mapsf",
    "title": "11  Тематические карты",
    "section": "11.5 Тематические карты в mapsf",
    "text": "11.5 Тематические карты в mapsf\nПакет mapsf предлагает альтернативный подход к составлению",
    "crumbs": [
      "Пространственные данные и карты",
      "<span class='chapter-number'>11</span>  <span class='chapter-title'>Тематические карты</span>"
    ]
  },
  {
    "objectID": "11-ThematicMaps.html#tmaps_review",
    "href": "11-ThematicMaps.html#tmaps_review",
    "title": "11  Тематические карты",
    "section": "11.6 Краткий обзор",
    "text": "11.6 Краткий обзор\nДля просмотра презентации щелкните на ней один раз левой кнопкой мыши и листайте, используя кнопки на клавиатуре:\n\n\n\n\n\nПрезентацию можно открыть в отдельном окне или вкладке браузере. Для этого щелкните по ней правой кнопкой мыши и выберите соответствующую команду.",
    "crumbs": [
      "Пространственные данные и карты",
      "<span class='chapter-number'>11</span>  <span class='chapter-title'>Тематические карты</span>"
    ]
  },
  {
    "objectID": "11-ThematicMaps.html#questions_tasks_tmap",
    "href": "11-ThematicMaps.html#questions_tasks_tmap",
    "title": "11  Тематические карты",
    "section": "11.7 Контрольные вопросы и упражнения",
    "text": "11.7 Контрольные вопросы и упражнения\n\n11.7.1 Вопросы\n\nОпишите шаблон построения тематической карты средствами tmap. Что из себя представляют его три основные компоненты?\nМогут ли на одной тематической карте комбинироваться пространственные данные в разных проекциях?\nПеречислите названия функций, отвечающих за отображение полигонов, линий и окружностей средствами tmap.\nЧему должно быть равно значение параметра col при отображении одноканального растра в случае если классификация и цвета определяются посредством параметров breaks и palette?\nОпишите порядок использования функции classIntervals() и ее основные параметры.\nПеречислите методы классификации, доступные в classIntervals(), а также принципы и работы. Какой из методов наиболее трудоемок в вычислительном плане?\nВ каком соотношении должно быть количество граничных классов и количество цветов при классификации?\nГрафик какой функции отображается при вызове функции plot() применительно к результату выполнения classIntervals()?\nКакие возможности существуют для применения классификации при построении карт средствами tmap? Обязательно ли заранее определять количество классов? В каком случае это может быть полезно.\nКак можно изменить порядок размещения элементов легенды в tmap?\nОпишите возможности управления расположением и внутренним форматированием легенды средствами tmap.\nС помощью какой функции можно построить координатную сетку на карте tmap?\nКак добавить значки градусов в подписи выходов сетки координат на карте tmap?\nКакие параметры позволяют управлять внешними и внутренними полями карты tmap?\nОпишите последовательность действий, которую необходимо реализовать для построения фасетной карты средствами tmap. Как можно реализовать построение таких карт на основе растровых данных?\nОпишите последовательность действий, которую необходимо реализовать для построения картографических анимаций средствами tmap. Какая библиотека должна быть установлена для этого на компьютере пользователя?\nКаким образом можно перевести отображение карт tmap в интерактивный режим? А обратно в статичный?\nРасскажите, что вы знаете о данных Natural Earth. На каком сайте они размещены? Сколько существует масштабных уровней? В каких форматах доступны данные? Как получить доступ к ним программным путем непосредственно из среды R?\n\n\n\n11.7.2 Упражнения\n\nИспользуя возможности пакетов rnaturalearth и tmap, создайте карту мира, в которой страны раскрашены в соответствии с континентом (переменная continent). Визуализируйте ее в статичном и интерактивном режиме.\nСкачайте базу данных на территорию Сатинского полигона МГУ. Изучите содержимое базы данных и постройте на основе этих данных серию тематических карт в проекции UTM средствами пакета tmap.\nСкачайте цифровую модель рельефа GEBCO. Используя слои ocean и land из масштаба 110 данных Natural Earth, разделите ее на два растра, отвечающих за рельефа суши и моря соответственно. Подберите для них классификации и создайте физическую карту мира, которая будет содержать помимо рельефа также основные объекты гидрографии.\nВыполните выборку стран из набора данных Natural Earth масштаба \\(50\\) на Европейский континент. Трансформируйте данные о странах в коническую равнопромежуточную проекцию. Визуализируйте численность населения по странам (переменная pop_est) способом картодиаграмм. Добавьте на карту реки, озера и города, используя возможности ne_download().\n\n\n\n\nСамсонов Т.Е. Визуализация и анализ географических данных на языке R. М.: Географический факультет МГУ, lubridate::year(Sys.Date()). DOI: 10.5281/zenodo.901911",
    "crumbs": [
      "Пространственные данные и карты",
      "<span class='chapter-number'>11</span>  <span class='chapter-title'>Тематические карты</span>"
    ]
  },
  {
    "objectID": "12-3DModels.html#mapping3d_prerequisites",
    "href": "12-3DModels.html#mapping3d_prerequisites",
    "title": "12  Трехмерные модели",
    "section": "12.1 Предварительные условия",
    "text": "12.1 Предварительные условия\nДля выполнения кода данной лекции вам понадобятся следующие пакеты:\n\nlibrary(sf)\nlibrary(stars)\nlibrary(dplyr)\nlibrary(rayshader)",
    "crumbs": [
      "Пространственные данные и карты",
      "<span class='chapter-number'>12</span>  <span class='chapter-title'>Трехмерные модели</span>"
    ]
  },
  {
    "objectID": "12-3DModels.html#three_intro",
    "href": "12-3DModels.html#three_intro",
    "title": "12  Трехмерные модели",
    "section": "12.2 Введение",
    "text": "12.2 Введение\nТрехмерные модели местности могут использоваться в тех случаях, когда стандартное картографическое изображение недостаточно наглядно. Поскольку и построение трехмерных моделей и взаимодействие с ними сложнее, чем с обычными картами, они распространены не столь повсеместно.",
    "crumbs": [
      "Пространственные данные и карты",
      "<span class='chapter-number'>12</span>  <span class='chapter-title'>Трехмерные модели</span>"
    ]
  },
  {
    "objectID": "12-3DModels.html#three_labels",
    "href": "12-3DModels.html#three_labels",
    "title": "12  Трехмерные модели",
    "section": "12.3 Создание трёхмерной сцены",
    "text": "12.3 Создание трёхмерной сцены\n\n12.3.1 Освещение цифровой модели рельефа\nПостроение трехмерной модели обычно начинается с создания изображения рельефа. В качестве примера рассмотрим ЦМР на территорию в окрестностях Хибин и Ловозёрских тундр в Мурманской области. Чтобы построить изображение рельефа, для начала надо получить матрицу со значениями цвета RGB, а затем вывести ее на экран посредством plot_map(). Градиентная окраска по высоте получается функцией height_shade(), аналитическая отмывка — через sphere_shade():\n\ndem = read_stars('data/dem_khibiny.tif')\n\nelev = dem[[1]]\n\n# ВАЖНО: в текущей версии rayshader оси матрицы не должны иметь названий \ndim(elev) &lt;- unname(dim(elev)) \n\nelev |&gt; \n  height_shade() |&gt; \n  plot_map()\n\n\n\n\n\n\n\n\nelev |&gt; \n  sphere_shade(zscale = 10) |&gt; \n  plot_map()\n\n\n\n\n\n\n\n\ndem_colors = colorRampPalette(c(\"darkolivegreen\", \"lightyellow\", \"orange\", \"firebrick\", \"white\"))\n\nelev |&gt; \n  height_shade(texture = dem_colors(256)) |&gt; \n  add_overlay(sphere_shade(elev, texture = 'bw', zscale=10), alphalayer=0.7) |&gt; \n  plot_map()\n\n\n\n\n\n\n\n\nФункция sphere_shade() имеет несколько встроенных палитр, которые позволяют раскрашивать поверхность в зависимости от восвещенности точки поверхности. В частности, она содержит стандартную черно-белую палитру, и четыре отмывки в швейцарском стиле Эдуарда Имгофа. Каждая палитра имеет, по сути, три цвета: фона, света и тени:\n\npalettes = c('bw', 'desert', 'imhof1','imhof2','imhof3','imhof4', 'unicorn')\n\nfor (pal in palettes) {\n  elev |&gt; \n    sphere_shade(texture = pal, zscale=10) |&gt; \n    plot_map()\n}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nДобавим принудительно посчитанные тени:\n\nelev |&gt; \n  height_shade(texture = dem_colors(256)) |&gt; \n  add_overlay(sphere_shade(elev, texture = 'bw', zscale=10), alphalayer=0.5) |&gt;\n  add_shadow(lamb_shade(elev, zscale = 20), 0.1) |&gt;\n  plot_map()\n\n\n\n\n\n\n\n\nРассеянный свет (ambient light) позволяет отделить долины от вершин хребтов:\n\nelev |&gt; \n  height_shade(texture = dem_colors(256)) |&gt; \n  add_overlay(sphere_shade(elev, texture = 'bw', zscale=10), alphalayer=0.5) |&gt; \n  add_shadow(lamb_shade(elev, zscale = 20), 0.1) |&gt; \n  add_shadow(ambient_shade(elev), 0.1) %&gt;%\n  plot_map()\n\n\n\n\n\n\n\n\nДля построение трехмерной сцены вместо plot_map() необходимо использовать plot_3d(). При этом будет открыто интерактивное окно OpenGL, в котором вы сможете вращать созданную сцену:\n\nelev |&gt; \n  height_shade(texture = dem_colors(256)) |&gt; \n  add_overlay(sphere_shade(elev, texture = 'bw', zscale=10), alphalayer=0.5) |&gt; \n  add_shadow(lamb_shade(elev, zscale = 20), 0.1) |&gt; \n  add_shadow(ambient_shade(elev), 0.1) |&gt; \n  plot_3d(elev, zscale = 20, fov = 0,\n          theta = 135, zoom = 0.75, phi = 45, \n          windowsize = c(1400, 800))\n\n# rgl::rglwidget(width = 800, height = 600)\n\nЧтобы сохранить текущий вид сцены, необходимо использовать функцию render_snapshot(). Для закрытия сцены используется функция rgl::rgl.close()\n\nrender_snapshot()\n\n\n\n\n\n\n\nrgl::rgl.close()\n\n\n\n12.3.2 Векторные слои\nПрочтем векторные данные:\n\ndb = 'data/khibiny.gpkg'\nrivers = st_read(db, 'rivers', quiet = T)\nlakes = st_read(db, 'lakes', quiet = T) |&gt;\n  filter(CLASS_ID != 31300000)\n\nroads_all = st_read(db, 'roads', quiet = T)\nroads = filter(roads_all, CLASS_ID &lt;= 62131000)\n\nrails = st_read(db, 'rails', quiet = T)\nforest = st_read(db, 'veg', quiet = T)\nblocks = st_read(db, 'blocks', quiet = T)\npoppol = st_read(db, 'poppol', quiet = T)\n\nДобавим их через оверлей объектов:\n\next = st_bbox(dem)\nelev |&gt;\n  height_shade(texture = dem_colors(256)) |&gt;\n  add_overlay(sphere_shade(elev, texture = 'bw', zscale=10), alphalayer=0.5) |&gt;\n  add_shadow(lamb_shade(elev, zscale = 20), 0.1) |&gt;\n  add_overlay(generate_line_overlay(rivers, linewidth = 2, color=\"steelblue4\",\n                                    extent = ext,\n                                    heightmap = elev)) |&gt;\n  add_overlay(generate_polygon_overlay(lakes, linewidth = 1,\n                                       palette = 'azure',\n                                       linecolor = 'steelblue4',\n                                       extent = ext,\n                                       heightmap = elev)) |&gt;\n  plot_map()\n\n\n\n\n\n\n\n\nВизуализируем в 3D:\n\nelev |&gt;\n  height_shade(texture = dem_colors(256)) |&gt;\n  add_overlay(sphere_shade(elev, texture = 'bw', zscale=10), alphalayer=0.5) |&gt;\n  add_shadow(lamb_shade(elev, zscale = 20), 0.1) |&gt;\n  add_overlay(generate_line_overlay(rivers, linewidth = 2, color=\"steelblue4\",\n                                    extent = ext,\n                                    heightmap = elev)) |&gt;\n  add_overlay(generate_polygon_overlay(lakes, linewidth = 1,\n                                       palette = 'azure',\n                                       linecolor = 'steelblue4',\n                                       extent = ext,\n                                       heightmap = elev)) |&gt;\n  plot_3d(elev, zscale = 20, fov = 0,\n          theta = 135, zoom = 0.75, phi = 45,\n          windowsize = c(1400, 800))\n\nSys.sleep(0.2)\nrender_snapshot()\n\n\n\n\n\n\n\nrgl::rgl.close()\n\nЧтобы приблизить изображение, повернуть, изменить угол наклона и т.д., используйте параметры функции plot_3d():\n\nelev |&gt;\n  height_shade(texture = dem_colors(256)) |&gt;\n  add_overlay(sphere_shade(elev, texture = 'bw', zscale=10), alphalayer=0.5) |&gt;\n  add_shadow(lamb_shade(elev, zscale = 20), 0.1) |&gt;\n  add_overlay(generate_line_overlay(rivers, linewidth = 2, color=\"steelblue4\",\n                                    extent = ext,\n                                    heightmap = elev)) |&gt;\n  add_overlay(generate_polygon_overlay(lakes, linewidth = 1,\n                                       palette = 'azure',\n                                       linecolor = 'steelblue4',\n                                       extent = ext,\n                                       heightmap = elev)) |&gt;\n  plot_3d(elev, zscale = 50, fov = 0,\n          theta = 80, zoom = 0.25, phi = 35,\n          windowsize = c(1400, 800))\n\nSys.sleep(0.2)\nrender_snapshot()\n\n\n\n\n\n\n\nrgl::rgl.close()\n\nРасширим состав визуализируемых объектов:\n\nplt = elev |&gt;\n  height_shade(texture = dem_colors(256)) |&gt;\n  add_overlay(sphere_shade(elev, texture = 'bw', zscale=10), alphalayer=0.5) |&gt;\n  add_shadow(lamb_shade(elev, zscale = 20), 0.1) |&gt;\n  add_overlay(generate_polygon_overlay(poppol, linewidth = 1,\n                                     palette = 'orange',\n                                     linecolor = 'black',\n                                     extent = ext,\n                                     heightmap = elev)) |&gt;\n  add_overlay(generate_line_overlay(rivers, linewidth = 2, color=\"steelblue4\",\n                                    extent = ext,\n                                    heightmap = elev)) |&gt;\n  add_overlay(generate_polygon_overlay(lakes, linewidth = 1,\n                                       palette = 'azure',\n                                       linecolor = 'steelblue4',\n                                       extent = ext,\n                                       heightmap = elev)) |&gt;\n  add_overlay(generate_line_overlay(roads, linewidth = 4, color=\"black\",\n                                    extent = ext,\n                                    heightmap = elev)) |&gt;\n  add_overlay(generate_line_overlay(roads, linewidth = 2, color=\"lightyellow\",\n                                  extent = ext,\n                                  heightmap = elev)) |&gt;\n  add_overlay(generate_line_overlay(rails, linewidth = 3, color=\"black\",\n                                  extent = ext,\n                                  heightmap = elev))\n\nplot_map(plt)\n\n\n\n\n\n\n\n\nplot_3d(plt, elev, zscale = 30, fov = 0,\n        theta = -45, zoom = 0.25, phi = 30,\n        windowsize = c(1400, 800))\n\nSys.sleep(0.2)\nrender_snapshot()\n\n\n\n\n\n\n\nrgl::rgl.close()\n\n\n\n12.3.3 Подписи\nДля размещения подписей следует использовать функцию generate_label_overlay():\n\npopmajor = poppol |&gt;\n  filter(CLASS_ID &lt; 41300000) |&gt;\n  st_centroid()\n\npopminor= poppol |&gt;\n  filter(CLASS_ID == 41300000) |&gt;\n  st_centroid()\n\nplt_lbl = plt |&gt;\n  add_overlay(generate_point_overlay(popmajor, size = 8, extent = ext, color = \"black\", pch = 19,\n                                     heightmap = elev)) |&gt;\n  add_overlay(generate_point_overlay(popmajor, size = 3, extent = ext, color = \"white\", pch = 19,\n                                     heightmap = elev)) |&gt;\n  add_overlay(generate_label_overlay(labels = popmajor,\n                                     data_label_column = 'NAME',\n                                     extent = ext, text_size = 2, color = \"black\", font=2,\n                                     halo_color = \"white\", halo_expand = 2, point_size = 0,\n                                     seed=1, heightmap = elev))\nplot_map(plt_lbl)\n\n\n\n\n\n\n\n\nplot_3d(plt_lbl, elev, zscale = 30, fov = 0,\n        theta = -45, zoom = 0.5, phi = 30,\n        windowsize = c(1400, 800))\n\nSys.sleep(0.2)\nrender_snapshot()\n\n\n\n\n\n\n\nrgl::rgl.close()\n\nКак видно, оверлей подписей выглядит не очень в трехмерноме режиме. В этом случае необходимо эти подписи наносить уже после того как трехмерный режим активирован:\n\nplot_3d(plt, elev, zscale = 30, fov = 0,\n        theta = -45, zoom = 0.5, phi = 35,\n        windowsize = c(1400, 800))\n\nfor (name in popmajor$NAME) {\n  pop = filter(popmajor, NAME == name)\n  render_label(elev, lat = st_coordinates(pop)[, 2], lon = st_coordinates(pop)[, 1],\n               text = name, altitude = 1000, zscale=30, textsize = 1.75, linewidth = 4,\n               extent = ext, textcolor = \"turquoise2\", linecolor=\"turquoise2\",\n               relativez = TRUE)\n}\n\nSys.sleep(0.2)\n\nrender_snapshot()\n\n\n\n\n\n\n\nrgl::rgl.close()",
    "crumbs": [
      "Пространственные данные и карты",
      "<span class='chapter-number'>12</span>  <span class='chapter-title'>Трехмерные модели</span>"
    ]
  },
  {
    "objectID": "12-3DModels.html#three_animation",
    "href": "12-3DModels.html#three_animation",
    "title": "12  Трехмерные модели",
    "section": "12.4 Анимация трёхмерной сцены",
    "text": "12.4 Анимация трёхмерной сцены\nАнимация с помощью пакета rayshader осуществляется покадрово. Для этого необходимо задать последовательность параметров камеры, каждый из которых будет определять кадр видеофильма, и определить эти параметры в функции render_movie().\n\n12.4.1 Вращение относительно точки\nНаиболее простой спобособ визуализации сцены — вращение относительно фиксированной точки. В этом случае необходимо менять только угол поворота камеры. По умолчанию render_movie() создает 12-секундный ролик с частотой 30 кадров в секунду (т.е. 360 кадров всего). Именно такой результат будет получен, если вызывать ее без параметров:\n\nplot_3d(plt, elev, zscale = 30, fov = 0,\n        theta = -45, zoom = 0.5,\n        windowsize = c(1400, 800))\n\nfor (name in popmajor$NAME) {\n  pop = filter(popmajor, NAME == name)\n  render_label(elev, lat = st_coordinates(pop)[, 2], lon = st_coordinates(pop)[, 1],\n               text = name, altitude = 1000, zscale=30, textsize = 1.75, linewidth = 4,\n               extent = ext, textcolor = \"turquoise2\", linecolor=\"turquoise2\",\n               relativez = TRUE)\n}\n\nrender_movie(filename = 'images/khibiny_rotate.gif')\n\n\n\n\n\n\n\n\n\n\n\n\n12.4.2 Облёт по траектории\nДля того чтобы территорию облететь по заданной траектории, необходимо эту траекторию создать. Проще всего такую задачу решить в настольной ГИС (ArcGIS, QGIS), оцифровав необходимую линию. Также можно создать объект через редактор пакета mapedit. Подгрузим готовую траекторию из базы данных и посмотрим на ее контур:\n\ntraj_line = st_read(db, 'trajectory')\n## Reading layer `trajectory' from data source \n##   `/Users/tsamsonov/GitHub/r-geo-course/data/khibiny.gpkg' using driver `GPKG'\n## Simple feature collection with 1 feature and 0 fields\n## Geometry type: LINESTRING\n## Dimension:     XY\n## Bounding box:  xmin: 482251.7 ymin: 7473232 xmax: 593004.8 ymax: 7545685\n## Projected CRS: WGS 84 / UTM zone 36N\n\nn_frames = 360\n\ntraj_pts = st_sample(traj_line, size = n_frames, type = 'regular') |&gt;\n  st_cast('POINT')\n\nplt_lbl |&gt;\n  add_overlay(generate_line_overlay(traj_line, linewidth = 10, extent = ext, heightmap = elev, color = 'cyan'), 0.8) |&gt;\n  add_overlay(generate_point_overlay(traj_pts, size = 3, extent = ext, heightmap = elev, color = 'orangered'), 1) |&gt;\n  plot_map()\n\n\n\n\n\n\n\n\nГотовой функции для облета по траектории в rayshader пока что нет, поэтому необходимо соорудить эту функциональность самим. Рендер будем выполнять покадрово, обрезая растр таким образом чтобы текущая точка траектории оказывалась в его середине:\n\nlibrary(magick)\nanim_wd = 'anim'\ndir.create(anim_wd)\n\noutput_gif = \"images/khibiny_traj.gif\"\n\nimg_frames &lt;- file.path(\n  anim_wd,\n  paste0(\"anim_\", formatC(seq_len(n_frames), width = 3, flag = \"0\"), \".png\")\n)\n\ncoords = st_coordinates(traj_pts)\n\nfor (i in seq_along(img_frames)) {\n\n  box = st_buffer(traj_pts[i], 50000) |&gt; st_bbox()\n\n  elev_crop = dem[box][[1]]\n\n  dim(elev_crop) = unname(dim(elev_crop))\n\n  ext_crop = raster::extent(box)\n\n  plt = elev_crop |&gt;\n    height_shade(texture = dem_colors(256)) |&gt;\n    add_overlay(sphere_shade(elev_crop, texture = 'bw', zscale=10), alphalayer=0.5) |&gt;\n    add_shadow(lamb_shade(elev_crop, zscale = 20), 0.1)\n\n  dx = coords[i+1, 1] - coords[i, 1]\n  dy = coords[i+1, 2] - coords[i, 2]\n\n  A = 180 * atan2(dx, dy) / pi\n\n  plot_3d(plt, elev_crop, zscale = 30, zoom = 0.5, theta = -A, phi = 20, windowsize = c(1400, 800))\n\n  Sys.sleep(0.2)\n\n  render_snapshot(img_frames[i])\n  rgl::clear3d()\n}\n\nrgl::rgl.close()\n\n# Create gif\nimage_write_gif(image_read(img_frames[-360]),\n                        path = output_gif,\n                        delay = 6/n_frames)",
    "crumbs": [
      "Пространственные данные и карты",
      "<span class='chapter-number'>12</span>  <span class='chapter-title'>Трехмерные модели</span>"
    ]
  },
  {
    "objectID": "12-3DModels.html#three_review",
    "href": "12-3DModels.html#three_review",
    "title": "12  Трехмерные модели",
    "section": "12.5 Краткий обзор",
    "text": "12.5 Краткий обзор\nДля просмотра презентации щелкните на ней один раз левой кнопкой мыши и листайте, используя кнопки на клавиатуре:\n\n\n\n\n\nПрезентацию можно открыть в отдельном окне или вкладке браузере. Для этого щелкните по ней правой кнопкой мыши и выберите соответствующую команду.",
    "crumbs": [
      "Пространственные данные и карты",
      "<span class='chapter-number'>12</span>  <span class='chapter-title'>Трехмерные модели</span>"
    ]
  },
  {
    "objectID": "12-3DModels.html#questions_tasks_three",
    "href": "12-3DModels.html#questions_tasks_three",
    "title": "12  Трехмерные модели",
    "section": "12.6 Контрольные вопросы и упражнения",
    "text": "12.6 Контрольные вопросы и упражнения\n\n12.6.1 Вопросы\n\n\n12.6.2 Упражнения\n\nСкачайте базу данных и цифровую модель рельефа на территорию Сатинского полигона МГУ. Постройте на их основе трехмерную модель местности и выполните ее круговую анимацию.\n\n\n\n\nСамсонов Т.Е. Визуализация и анализ географических данных на языке R. М.: Географический факультет МГУ, 2023. DOI: 10.5281/zenodo.901911",
    "crumbs": [
      "Пространственные данные и карты",
      "<span class='chapter-number'>12</span>  <span class='chapter-title'>Трехмерные модели</span>"
    ]
  },
  {
    "objectID": "13-VectorAnalysis.html#mapping3d_prerequisites",
    "href": "13-VectorAnalysis.html#mapping3d_prerequisites",
    "title": "13  Векторный анализ",
    "section": "13.1 Предварительные условия",
    "text": "13.1 Предварительные условия\nДля выполнения кода данной лекции вам понадобятся следующие пакеты:\n\nlibrary(readxl)\nlibrary(sf)\nlibrary(tidyverse)\nlibrary(classInt)\nlibrary(mapsf) # Удобное построение тематических карт средствами plot()\n\nlibrary(circular) # статистика направлений\nlibrary(NPCirc) # статистика направлений\nlibrary(pracma)\n\nДанный модуль посвящен пространственному анализу в R. Несмотря на то, что пространственный анализ — чрезвычайно широкая и многогранная область геоинформатики, все методы, которые объединяются под этим заголовком, базируются на ограниченном числе базовых операций, таких как вычисление расстояний, оценка плотности распределения, построение буферных зон и выполнение пространственных запросов. В настоящем модуле мы рассмотрим, как одно и то же множество пространственных объектов можно анализировать в различных контекстах, используя базовые методы пространственного анализа\nПространственный анализ связан с оценкой размещения объектов и распределения величин в географическом пространстве. В геоинформатике для этих целей используется два подхода: геометрический и статистический. Эти подходы образуют две ступени пространственного анализа: как правило, данные геометрического анализа представляют собой входную информацию для анализа статистического.\nГеометрический подход связан с вычислением расстояний между географическими локациями, а также агрегированием объектов/интегрированием показателей в пределах заданных областей, вдоль линий или в окрестности точек. Поиск входной информации для агрегирования решается путем выполнения пространственных запросов.",
    "crumbs": [
      "Пространственный анализ",
      "<span class='chapter-number'>13</span>  <span class='chapter-title'>Векторный анализ</span>"
    ]
  },
  {
    "objectID": "13-VectorAnalysis.html#spatial_queries",
    "href": "13-VectorAnalysis.html#spatial_queries",
    "title": "13  Векторный анализ",
    "section": "13.2 Пространственные запросы",
    "text": "13.2 Пространственные запросы\nПространственные запросы связаны с поиском объектов (географических локаций), удовлетворяющих условию, заданному на множестве пространственных отношений. В свою очередь, пространственные отношения бывают трех типов: дирекционные (направления), метрические (расстояния) и топологические (взаимное размещение). Примеры пространственных запросов знакомы любому географу:\n\nНайти все объекты внутри административного района (топологические отношения)\nНайти все объекты не далее 100 метров от дороги (метрические отношения)\nНайти все объекты, расположенные к северу от точки (дирекционные отношения)\n\nПространственные запросы могут объединять несколько условий. Можно найти объекты, удовлетворяющие одновременно всем (логическое И) вышеперечисленным условиям: внутри района, не далее 100 м от дороги и к северу от выбранной точки; или хотя бы одному (логическое ИЛИ) из вышеперечисленных условий. Результат выполнения такого комплексного запроса будет являться, соответственно, пересечением множеств объектов, полученных каждым из запросов, или их объединением.\nНаконец, пространственные запросы можно объединять с атрибутивными и временными. Атрибутивные запросы связаны с поиском объектов (географических локаций), удовлетворяющих условию, заданному на множестве характеристик объектов. Временные запросы определены на множестве шкалы времени. Например, можно найти все населенные пункты населением свыше 10 000 человек (атрибутивный запрос), находящиеся в пределах выбранного административного района (пространственный запрос, основанный на топологических отношениях), время движения от которых до районного центра не превышает 90 минут (временной запрос).\n\n13.2.1 Контекстные и целевые объекты\nПри выполнении пространственного анализа, в общем случае, имеются множества объектов двух типов:\n\nконтекстные — объекты, относительно которых будет оцениваться размещение других объектов, то есть, определяющие контекст анализа\nцелевые — объекты, размещение которых анализируется по отношению к контекстным объектам, что является целью анализа\n\nЭти множества, разумеется, могут совпадать. Скажем, мы можем проанализировать размещение магазинов относительно других магазинов.\n\n\n13.2.2 Метрические отношение\n\n\n13.2.3 Топологические отношения\nПоиск объектов по местоположению базируется на проверке топологических отношений между объектами. Топологические отношения описывают взаимное расположение объектов. Различные варианты топологических отношений для площадных объектов представлены на следующем рисунке, где серым цветом показаны пересечения внутренних областей объектов \\(A\\) и \\(B\\), синим цветом — пересечения границ объектов \\(A\\) и \\(B\\):\n\n\n\n\n\n\n\n\n\nОтношение Пересекает (intersects) будет истинно для любого случая когда две геометрии имеют хотя бы одну общую точку, то есть во всех случаях кроме Не пересекает (disjoint). Для проверки этих, а также некоторых других отношений, в пакете sf существует ряд функций:\n\n\n\n\n\n\n\nФункция\nТопологическое отношение\n\n\n\n\nst_intersects(x, y)\nx имеет общие точки с y\n\n\nst_disjoint(x, y)\nx не имеет общих точек с y\n\n\nst_touches(x, y)\nx касается y (граница x имеет общие точки с границей y И внутренняя область x не имеет имеет общих точек с внутренней областью y)\n\n\nst_crosses(x, y)\nx пересекает y (граница x имеет общие точки с границей y, при этом размерность их пересечения меньше размерности хотя бы одного из исходных объектов)\n\n\nst_within(x, y)\nx внутри y (все точки x содержатся в y И внутренняя область x имеет общие точки с внутренней областью y)\n\n\nst_contains(x, y)\nx содержит y (все точки y содержатся в x И внутренняя область y имеет общие точки с внутренней областью x)\n\n\nst_contains_properly(x, y)\nx содержит y полностью (все точки y содержатся в x И граница x не имеет общих точек с границей y)\n\n\nst_overlaps(x, y)\nx перекрывает y (внутренняя область x имеет как общие, так и не общие точки с внутренней областью y)\n\n\nst_equals(x, y)\nx совпадает y (множества точек x и y совпадают)\n\n\nst_covers(x, y)\nx покрывает y (все точки y содержатся в x)\n\n\nst_covered_by(x, y)\nx покрыт y (все точки x содержатся в y)\n\n\nst_equals_exact(x, y)\nx совпадает y точно (упорядоченные множества точек x и y совпадают)\n\n\n\nМежду covered_by и within, а также covers и contains нет разницы в случае, когда оба объекта являются площадными. Эта разница будет сказываться если хотя бы один из объектов является линией либо точкой. В этом случае within, contains и contains_properly будут давать ложный результат (FALSE), поскольку ни у линий, ни у точек нет внутренней области.\nПроверка топологических отношений используется для выполнения выборки объектов по местоположению — пространственной выборки. Наиболее простой способ выбрать объекты по пространственному местоположению — это использовать один слой в качестве фильтра для другого слоя. В этом случае будет по умолчанию использовано отношение st_intersects() (пересекает). Никаких отличий от работы с обычными таблицами нет. Например, вот так можно выбрать точки, находящиеся внутри ранее отобранных стран с максимальным ВВП:\n\ncountries = st_read('data/ne/countries.gpkg')\n## Reading layer `admin_0_map_units' from data source \n##   `/Users/tsamsonov/GitHub/r-geo-course/data/ne/countries.gpkg' \n##   using driver `GPKG'\n## Simple feature collection with 183 features and 72 fields\n## Geometry type: MULTIPOLYGON\n## Dimension:     XY\n## Bounding box:  xmin: -180 ymin: -90 xmax: 180 ymax: 83.64513\n## Geodetic CRS:  WGS 84\noutlines = st_geometry(countries)\ncities = st_read('data/ne/cities.gpkg')\n## Reading layer `populated_places' from data source \n##   `/Users/tsamsonov/GitHub/r-geo-course/data/ne/cities.gpkg' \n##   using driver `GPKG'\n## Simple feature collection with 243 features and 103 fields\n## Geometry type: POINT\n## Dimension:     XY\n## Bounding box:  xmin: -175.2206 ymin: -41.29999 xmax: 179.2166 ymax: 64.15002\n## Geodetic CRS:  WGS 84\ncity.pts = st_geometry(cities)\n\nlargest = countries |&gt; \n  select(pop_est) |&gt; \n  filter(pop_est &gt; 100000000)\n\n# Наносим исходную конфигурацию\nplot(outlines, lwd = 0.5)\nplot(cities, col = 'black', pch = 20, cex = 0.5, add = TRUE)\n\n\n\n\n\n\n\n\nsf::sf_use_s2(FALSE)\n\n# Отбираем точки внутри стран с максимальным ВВП\nsel = cities[largest, ]\n\n# Смотрим что получилось\nplot(outlines, lwd = 0.5)\nplot(largest, col = 'gray', add = TRUE)\nplot(sel, pch = 20, col = 'black', add = TRUE)\n\n\n\n\n\n\n\n\nРазумеется, при выполнении пространственных запросов могут возникать и другие пространственные отношения. Например, мы можем выбрать все страны, имеющие общую границу с Чехией. Для этого можно использовать топологическое отношение st_touches вместо st_intersects — это будет гарантировать, что сама Чехия в результате не выберется (касающиеся объекты не могут перекрываться). Тип отношения необходимо поставить в параметр op = при выполнении фильтрации фрейма данных:\n\ncz = filter(countries, sovereignt == 'Czechia')\nneighbors = countries[cz, op = st_touches]\n\nplot(st_geometry(neighbors), col = 'lightgray', lwd = 0.5)\nplot(cz, col = 'darkgray', add = TRUE)\n\n\n\n\n\n\n\n\n\n\n13.2.4 Зоны окружения объектов\nВесьма часто в качестве контекстного множества используются не реальные пространственные объекты, а набор абстрактных геометрических объектов, каждый из которых является производным от оригинального пространственного объекта. Как правило, такие геометрии представляют из себя зоны окружения объектов, построенные по некоторому формальному признаку.\nМетоды построения зон окружения можно разделить по двум критериям: учету взаимного размещения объектов (абсолютные и конкурентные зоны) и пространству признаков, в котором эти зоны строятся.\nЕсли зоны окружения строятся без учета взаимного размещения объектов, то есть, независимо для каждого объекта, то мы будем называть их абсолютными. Абсолютные зоны окружения строятся путем фиксации порогового расстояния либо времени движения относительно исходного объекта. Такие зоны носят название буферных зон (по расстоянию) или зон доступности (по времени). Границей абсолютной зоны окружения является изолиния, построенная по соответствующему показателю. В случае времени это будет изохрона. Примеры абсолютных зон окружения:\n\nВодоохранная зона реки 200 метров (буферная зона)\nПлощадь городской территории, в любую точку которой вы можете доехать из дома на машине в течение 30 минут (зона доступности)\n\nЕсли же при построении зон окружения учитывается взаимное размещение объектов, то в данном случае зоны доступности строятся не исходя из порогового значения показателя (хотя оно может использоваться дополнительно), а исходя из того, какой объект является ближайшим. Конкурентные зоны окружения представляют собой разбиение пространства на неперекрывающиеся участки без дыр, каждый из которых является зоной окружения соответствующего пространственного объекта. При этом любая точка внутри зоны окружения объекта ближе к этому объекту по выбранному признаку (времени или расстоянию), нежели к любому другому объекту. Конкурентные зоны окружения, построенные по расстоянию, можно реализовать средствами диаграммы Вороного.",
    "crumbs": [
      "Пространственный анализ",
      "<span class='chapter-number'>13</span>  <span class='chapter-title'>Векторный анализ</span>"
    ]
  },
  {
    "objectID": "13-VectorAnalysis.html#use_case",
    "href": "13-VectorAnalysis.html#use_case",
    "title": "13  Векторный анализ",
    "section": "13.3 Постановка задач и изучение данных",
    "text": "13.3 Постановка задач и изучение данных\nВ настоящем модуле мы рассмотрим вышеперечисленные методы на примере анализа размещения пунктов общественного питания — кафе, ресторанов и т.д. Используя методы пространственного анализа в среде R, мы ответим на следующие вопросы:\n\nКакие улицы являются местами наибольшей концентрации заведений общественного питания?\nКак распределены заведения общественного питания по районам центра Москвы?\nКакие заведения общественного питания находятся вблизи метро и на берегу реки?\nВ какие заведения общественного питания можно доехать от выбранной точки в течение 5 минут?\nКаков оптимальный маршрут между вашим местоположением и заведением, в котором вы хотите пообедать?\n\nВ качестве источника данных используем OpenStreetMap — краудсорсинговый интернет-проект по созданию бесплатных и открытых пространственных данных глобального охвата. Данные OpenStreetMap в удобном для использования в ГИС виде доступны на портале GIS-Lab.\nДля решения задач настоящего модуля нам понадобятся следующие дополнительные пакеты, которые мы не использовали ранее:\n\nosrm — построение зон доступности, маршрутов и матриц корреспонденции онлайн на основе данных OpenStreetMap и OSRM API.\nmapsf — пакет, облегчающий построение тематических карт и легенд средствами стандартной функции plot().\n\nНачнем наше исследование с визуального анализа исходных данных\n\n# Чтение данных\nroads = read_sf(\"data/roads.gpkg\") # Дороги\npoi = read_sf(\"data/poi_point.gpkg\") # Точки интереса\nrayons = read_sf(\"data/boundary_polygon.gpkg\") # Границы районов\nstations = read_sf(\"data/metro_stations.gpkg\") # Станции метро\nwater = read_sf(\"data/water_polygon.gpkg\") # Водные объекты\n\n# Прочитаем текущие параметры компоновки\ndef = par(no.readonly = TRUE)\n\n# Уберем поля, чтобы карта занимала весь экран\npar(mar = c(0,0,0,0))\n\n# Получим ограничивающий прямоугольник слоя дорог в качестве общего охвата карты\nframe = roads |&gt; st_bbox() |&gt; st_as_sfc() |&gt; st_geometry()\n\n## ОБЗОР ИСХОДНЫХ ДАННЫХ -------------------------------------\n\n# Визуализируем входные данные\n\nbasemap = function(add = FALSE) {\n  mf_base(frame, col = NA, add = add)\n  mf_base(water, \n       col = \"lightskyblue1\",\n       border = \"lightskyblue3\",\n       add = TRUE)\n  mf_base(roads,\n       col = \"gray70\", \n       add = TRUE)\n}\n\nbasemap()\nmf_base(poi, \n     col = \"deepskyblue4\", \n     pch = 20, \n     cex = 0.5, \n     add = TRUE)\n\n\n\n\n\n\n\n\nТеперь приступим к изучению данных, хранящихся в слое poi (от англ. POI — Point Of Interest). Данный слой содержит все точечные маркеры OSM, которыми были отмечены на карте объекты, представляющие (по мнению создателей данных) интерес для пользователей. В POI включаются самые разнообразные объекты, такие как: объекты сферы услуг (amenity), места для отдыха (leisure), офисные здания (office), магазины и торговые центры (shop), туристические достопримечательности (tourism), спортивные объекты (sport), примечательные инженерные сооружения (man_made). В наших данных информация разнесена по соответствующим полям, каждый объект снабжен уникальным идентификатором:\n\n## Simple feature collection with 6623 features and 9 fields\n## Geometry type: POINT\n## Dimension:     XY\n## Bounding box:  xmin: 410947.3 ymin: 6176678 xmax: 415889.9 ymax: 6181909\n## Projected CRS: WGS 84 / UTM zone 37N\n## # A tibble: 6,623 × 10\n##        OSM_ID NAME           MAN_MADE LEISURE AMENITY OFFICE SHOP  TOURISM SPORT\n##         &lt;dbl&gt; &lt;chr&gt;          &lt;chr&gt;    &lt;chr&gt;   &lt;chr&gt;   &lt;chr&gt;  &lt;chr&gt; &lt;chr&gt;   &lt;chr&gt;\n##  1 2932331614 Арт-квартал    &lt;NA&gt;     &lt;NA&gt;    &lt;NA&gt;    &lt;NA&gt;   doit… &lt;NA&gt;    &lt;NA&gt; \n##  2 3639408399 &lt;NA&gt;           &lt;NA&gt;     &lt;NA&gt;    pharma… &lt;NA&gt;   &lt;NA&gt;  &lt;NA&gt;    &lt;NA&gt; \n##  3 3707882299 &lt;NA&gt;           &lt;NA&gt;     &lt;NA&gt;    parkin… &lt;NA&gt;   &lt;NA&gt;  &lt;NA&gt;    &lt;NA&gt; \n##  4 3639408396 Стиль золото   &lt;NA&gt;     &lt;NA&gt;    &lt;NA&gt;    &lt;NA&gt;   jewe… &lt;NA&gt;    &lt;NA&gt; \n##  5 3639408397 Цветочная баз… &lt;NA&gt;     &lt;NA&gt;    &lt;NA&gt;    &lt;NA&gt;   flor… &lt;NA&gt;    &lt;NA&gt; \n##  6 1413216563 Азбука Вкуса   &lt;NA&gt;     &lt;NA&gt;    &lt;NA&gt;    &lt;NA&gt;   supe… &lt;NA&gt;    &lt;NA&gt; \n##  7 3641139540 &lt;NA&gt;           &lt;NA&gt;     &lt;NA&gt;    waste_… &lt;NA&gt;   &lt;NA&gt;  &lt;NA&gt;    &lt;NA&gt; \n##  8 3636920934 Аршин          &lt;NA&gt;     &lt;NA&gt;    restau… &lt;NA&gt;   &lt;NA&gt;  &lt;NA&gt;    &lt;NA&gt; \n##  9 3644422074 Адамас         &lt;NA&gt;     &lt;NA&gt;    &lt;NA&gt;    &lt;NA&gt;   jewe… &lt;NA&gt;    &lt;NA&gt; \n## 10 3424516009 Андерсон       &lt;NA&gt;     &lt;NA&gt;    restau… &lt;NA&gt;   &lt;NA&gt;  &lt;NA&gt;    &lt;NA&gt; \n## # ℹ 6,613 more rows\n## # ℹ 1 more variable: geometry &lt;POINT [m]&gt;\n\nЗаведения общественного питания по классификатору OSM относятся к классу amenity. Поскольку данный классификатор представляет собой множество номинальных (категориальных) данных, можно начать изучение состава данных с помощью таблицы частот, которая строится средствами функции table():\n\ndata.frame(table(poi$AMENITY))\n##                  Var1 Freq\n## 1         arts_centre   17\n## 2                 atm  153\n## 3                bank  407\n## 4                 bar  161\n## 5               bench  210\n## 6     bicycle_parking   81\n## 7      bicycle_rental  116\n## 8          biergarten    1\n## 9             brothel    1\n## 10   bureau_de_change   21\n## 11        bus_station    1\n## 12               cafe  490\n## 13         car_rental    1\n## 14           car_wash   12\n## 15   charging_station    1\n## 16         child_care    1\n## 17             cinema   16\n## 18             clinic   51\n## 19              clock   10\n## 20            college    5\n## 21         commercial    1\n## 22   community_centre    4\n## 23         courthouse    3\n## 24     dancing_school    1\n## 25            dentist   58\n## 26            doctors   22\n## 27     drinking_water    3\n## 28     driving_school    2\n## 29            embassy   31\n## 30    emergency_phone    5\n## 31          fast_food  169\n## 32     ferry_terminal    5\n## 33         food_court    3\n## 34           fountain   32\n## 35               fuel    8\n## 36                gym    1\n## 37           hospital    2\n## 38              hotel    1\n## 39          ice_cream    3\n## 40       kindergarten   13\n## 41            library   17\n## 42     musical_school    1\n## 43          nightclub   19\n## 44           official    1\n## 45            parking   92\n## 46   parking_entrance   72\n## 47      parking_space    1\n## 48   payment_terminal    6\n## 49           pharmacy  166\n## 50           photolab    1\n## 51   place_of_worship   23\n## 52             police   21\n## 53           post_box    4\n## 54        post_office   37\n## 55                pub   96\n## 56    public_bookcase    2\n## 57    public_building    8\n## 58          recycling    6\n## 59    register_office    2\n## 60         restaurant  844\n## 61             school   10\n## 62            shelter    2\n## 63               shop    4\n## 64    social_facility    3\n## 65          stripclub    4\n## 66               taxi    1\n## 67          telephone   58\n## 68            theatre   48\n## 69            toilets   82\n## 70           training   15\n## 71         university   15\n## 72 vehicle_inspection    1\n## 73    vending_machine   98\n## 74       waste_basket   52\n## 75     waste_disposal  102\n\nДля дальнейшего анализа отберем из всего множества объектов сферы услуг заведения, где можно поесть: рестораны, кафе, бары, пабы и заведения быстрого питания (фастфуд). В классификаторе OSM эти заведения имеют тип restaurant, bar, cafe, pub и fast_food. Для отбора нужных строк и столбцов используем dplyr:\n\npoi_food = poi |&gt;  \n  select(NAME, AMENITY) |&gt; \n  filter(AMENITY %in% c(\"restaurant\", \"bar\", \"cafe\", \n                        \"pub\", \"fast_food\"))\nhead(poi_food)\n## Simple feature collection with 6 features and 2 fields\n## Geometry type: POINT\n## Dimension:     XY\n## Bounding box:  xmin: 410954.9 ymin: 6178842 xmax: 411023.8 ymax: 6181896\n## Projected CRS: WGS 84 / UTM zone 37N\n## # A tibble: 6 × 3\n##   NAME        AMENITY              geometry\n##   &lt;chr&gt;       &lt;chr&gt;             &lt;POINT [m]&gt;\n## 1 Аршин       restaurant (410975.2 6181661)\n## 2 Андерсон    restaurant (410954.9 6180118)\n## 3 Holynoot    fast_food  (410958.8 6179938)\n## 4 Gayane's    restaurant (410958.4 6178842)\n## 5 Molon Lave  restaurant (411013.7 6181448)\n## 6 Шоколадница cafe       (411023.8 6181896)",
    "crumbs": [
      "Пространственный анализ",
      "<span class='chapter-number'>13</span>  <span class='chapter-title'>Векторный анализ</span>"
    ]
  },
  {
    "objectID": "13-VectorAnalysis.html#distance_analysis",
    "href": "13-VectorAnalysis.html#distance_analysis",
    "title": "13  Векторный анализ",
    "section": "13.4 Анализ расстояний",
    "text": "13.4 Анализ расстояний\nМетрические отношения связывают объекты в терминах расстояний между ними. Предположим, что мы хотим определить улицы, являющиеся сосредоточением заведений питания. Один из вариантов решения состоит в том, чтобы для каждого пункта обслуживания определить ближайшую к нему улицу и далее для каждой улицы просуммировать количество раз, которое улиц оказалось ближайшей. Подробнее алгоритм решения выглядит следующим образом:\n\nВычислить матрицу расстояний между пунктами обслуживания и улицами. Размер матрицы \\(M \\times N\\), где \\(M\\) — количество улиц (строк), \\(N\\) — количество пунктов (столбцов)\nНайти в каждом столбце минимальное расстояние.\nПолучить идентификатор улицы (номер строки), соответствующий данному расстоянию.\nЗаписать идентификатор в выходной вектор.\n\nТаким образом, мы получим вектор из идентификаторов улиц, при этом каждый идентификатор будет встречаться в этом векторе столько раз, сколько раз данная улица оказалась ближайшей к какому-то объекту.\nВычислим матрицу расстояний с помощью функции st_distance() из пакета sf:\n\n\n## АНАЛИЗ РАССТОЯНИЙ -------------------------------------\n\ndist_matrix = st_distance(roads, poi_food)\n\n# посмотрим, как выглядит результат на примере первых пяти объектов\nprint(dist_matrix[1:5,1:5])\n## Units: [m]\n##          [,1]      [,2]      [,3]      [,4]     [,5]\n## [1,] 4962.292 3420.6849 3240.2066 2145.2044 4748.686\n## [2,] 2247.737  705.2923  524.9411  570.3986 2035.341\n## [3,] 2213.236  670.7904  490.4167  605.1606 2000.759\n## [4,] 2197.874  655.4285  475.0629  620.4411 1985.242\n## [5,] 3910.957 2368.5560 2188.1348 1092.5472 3698.246\n\nДалее необходимо в каждом столбце матрицы найти номер строки с минимальным расстоянием. Для этого необходимо получить порядок сортировки элементов по возрастанию значений данного столбца и взять номер первого элемента. Операцию можно применить с помощью apply ко всем столбцам:\n\nids = apply(dist_matrix, 2, function(X) order(X)[1])\n\nТеперь применим уже знакомую нам функцию table(), чтобы подсчитать, сколько раз каждая улица оказалась наиболее близкой. Далее присоединим статистику к исходным улицам, однако для этого нам потребуется вынести названия строк (номеров) улиц в отдельный столбец.\n\ncount_stats = ids |&gt; \n  table() |&gt; \n  as_tibble() |&gt; \n  mutate(ids = as.integer(ids))\nroads = roads |&gt; mutate(id = row_number())\nroads_poi = left_join(roads, \n                   count_stats, \n                   by = c('id' = 'ids'))\n\nПосмотрим первые 10 улиц по количеству общепита:\n\n# Статистика по улицам в табличном представлении (первые 10)\nroads_poi |&gt; \n  select(NAME, n) |&gt; \n  arrange(desc(n)) |&gt; \n  head(10)\n## Simple feature collection with 10 features and 2 fields\n## Geometry type: MULTILINESTRING\n## Dimension:     XY\n## Bounding box:  xmin: 411105.1 ymin: 6178083 xmax: 414504.1 ymax: 6181734\n## Projected CRS: WGS 84 / UTM zone 37N\n## # A tibble: 10 × 3\n##    NAME                        n                                        geometry\n##    &lt;chr&gt;                   &lt;int&gt;                           &lt;MULTILINESTRING [m]&gt;\n##  1 улица Арбат                43 ((412157.9 6179399, 412148.5 6179396, 412147.2…\n##  2 улица Новый Арбат          24 ((411105.1 6179409, 411112.5 6179408, 411162.7…\n##  3 Цветной бульвар            22 ((413491.7 6181734, 413493.8 6181729, 413495.6…\n##  4 Мясницкая улица            20 ((414504.1 6180781, 414499.7 6180779, 414497.2…\n##  5 Никольская улица           17 ((413704.5 6180101, 413701.3 6180097, 413674.4…\n##  6 Пятницкая улица            17 ((413895.8 6178083, 413896.4 6178095, 413899 6…\n##  7 Козицкий переулок          14 ((412831.7 6180834, 412822.5 6180829, 412782.6…\n##  8 улица Большая Дмитровка    14 ((413262.7 6180062, 413238.1 6180094, 413201.5…\n##  9 Неглинная улица            14 ((413498.2 6180132, 413492.5 6180151, 413461.7…\n## 10 улица Рождественка         14 ((413628.1 6180466, 413629.8 6180464, 413630.7…\n\nДля завершения анализа осталось визуализировать результаты:\n\nbasemap()\nmf_map(roads_poi,\n       type = 'prop',\n       var = c('n'),\n       col = 'red')\nmf_base(poi_food, \n     col = \"deepskyblue4\", \n     pch = 20, cex = 1, \n     add = TRUE)",
    "crumbs": [
      "Пространственный анализ",
      "<span class='chapter-number'>13</span>  <span class='chapter-title'>Векторный анализ</span>"
    ]
  },
  {
    "objectID": "13-VectorAnalysis.html#topology_analysis",
    "href": "13-VectorAnalysis.html#topology_analysis",
    "title": "13  Векторный анализ",
    "section": "13.5 Анализ взаимного положения (топологический)",
    "text": "13.5 Анализ взаимного положения (топологический)\nПространственные запросы, основанные на топологических отношениях, позволяют находить объекты, находящиеся внутри других объектов, соприкасающиеся с другими объектами, пересекающиеся с ними и так далее. Топологические отношения сохраняются при взаимно-однозначных и непрерывных преобразованиях плоскости.\nОтличия от метрических отношений легко пояснить на примере преобразования проекции. Представьте, что карту России в конической проекции с концентрическими параллелями (известную по учебникам и атласам) вы трансформировали в карту России в проекции Меркатора (такую же как на Google Maps). Изогнутые параллели превратились в прямые линии; форма регионов, площади и расстояния между населенными пунктами значительно изменились. Однако Красноярск по-прежнему находится в Красноярском крае, Ярославль — на реке Волге, Нижний Новгород — на правом берегу Волги, озеро Белое — внутри Вологодской области, а Московская область как не граничила с Тамбовской, так и не граничит после трансформации проекции. Это и есть топологические отношения.\nФормально топологические отношения в ГИС описываются с помощью модели девяти пересечений DE-9IM, которая была рассмотрена в начале этой лекции.\n\n## АНАЛИЗ ВЗАИМНОГО ПОЛОЖЕНИЯ -------------------------------------\npoi_food = poi_food |&gt; mutate(count = 1)\nrayons_poi = aggregate(poi_food['count'], rayons, sum)\n\n\n# Преобразуем результат в относительный показатель\n# (единиц на кв.км. площади) и запишем в таблицу районов:\nrayons_poi$density = 1000000 * rayons_poi$count / st_area(rayons_poi)\n\nМасштабный множитель 1000000 в коде понадобился чтобы перевести площадь, хранящуюся в поле Shape_Area из квадратных метров в квадратные километры. Обратите внимание на то, что в данном случае мы не стали ограничивать фигурными скобками тело анонимной функции (table(X)[2]) внутри apply(), поскольку выполняемая операция достаточно компактна.\nВизуализируем результат:\n\nmf_map(rayons_poi,\n       var = 'density',\n       type = 'choro',\n       leg_title = \"Заведений\\nна 1 кв.км\")\nbasemap(add = TRUE)\nmf_base(rayons,\n     border = \"black\",\n     lwd = 3, col = NA,\n     add = TRUE)\nmf_label(rayons,\n     var = 'NAME',\n     col = 'black',\n     overlap = FALSE,\n     font = 2,\n     cex = 1)\n\n\n\n\n\n\n\n\nИтак, используя топологический пространственный запрос “Содержит”, мы смогли агрегировать точечные объекты внутри площадных и построить картограммы плотности распределения пунктов питания по районам центра Москвы.",
    "crumbs": [
      "Пространственный анализ",
      "<span class='chapter-number'>13</span>  <span class='chapter-title'>Векторный анализ</span>"
    ]
  },
  {
    "objectID": "13-VectorAnalysis.html#absolute_zones",
    "href": "13-VectorAnalysis.html#absolute_zones",
    "title": "13  Векторный анализ",
    "section": "13.6 Анализ абсолютных зон окружения",
    "text": "13.6 Анализ абсолютных зон окружения\nЗадача данного раздела модуля звучит следующим образом: определить, какие пункты питания находятся в радиусе 300 метров от метро “Кропоткинская”. Контекстом анализа в данном случае служит 300-метровая зона окружения станции метро. Поставленную задачу можно решить двумя способами:\n\nРассчитать расстояния от каждого пункта питания до станции метро “Кропоткинская” и выбрать точки, для которых это расстояние меньше или равно 300 метрам.\nПостроить буферную зону радиусом 300 метров и выбрать ею точки, используя топологическое отношение пересечения\n\nМы будем использовать второй вариант решения. Алгоритм выглядит следующим образом:\n\nПостроить буферную зону, используя функцию st_buffer() из пакета sf.\nВыбрать полученной зоной точки пунктов питания, используя стандартный оператор [].\nВизуализировать на карте полученные точки и буферную зону.\n\nОпределим расширенную функцию basemap2(), которая будет рисовать объекты картографической основы, ее мы будем использовать далее.\n\n## АНАЛИЗ АБСОЛЮТНЫХ ЗОН ОКРУЖЕНИЯ -------------------------------------\n\nstations$label = 'М' # пригодится для подписей\n\n# Функция отвечает за рисование базовой карты\nbasemap2 = function(add = FALSE){\n  \n  mf_base(frame, col = NA, add = add)\n  mf_base(water, \n       col = \"lightskyblue1\",\n       border = \"lightskyblue3\",\n       add = TRUE)\n  mf_base(roads,\n       col = \"gray70\", \n       add = TRUE)\n  \n  mf_base(poi_food, \n     col = \"deepskyblue4\", \n     pch = 20, cex = 0.5, \n     add = TRUE)\n  \n  mf_base(stations, \n     col = \"slategray4\", \n     pch = 20, \n     cex = 3, \n     add = TRUE)\n  \n  mf_label(stations,\n     var = 'label',\n     col = \"white\",\n     cex = 0.6)\n}\n\nОпределив вспомогательные функции, можем приступать к выполнению анализа:\n\n# Выберем станцию метро и построим буферную зону\nkrop = filter(stations, NAME == \"Кропоткинская\")\nzone = st_buffer(krop, dist = 500)\n\n# Применим разработанную функцию для отбора точек\nselected_poi = poi_food[zone, ]\n\n# Применим разработанную функцию для рисования картографической основы\nbasemap2()\n\n# Визуализируем результаты анализа\nmf_base(zone,\n     col = adjustcolor(\"sienna3\", alpha.f = 0.5),\n     border = \"sienna3\",\n     add = TRUE)\n\nmf_base(selected_poi, \n     col = \"sienna4\", \n     pch = 20, \n     cex = 1, \n     add = TRUE)\n\nmf_base(krop, \n   col = \"red\", \n   pch = 20, \n   cex = 4, \n   add = TRUE)\n\nmf_label(krop,\n   var = 'label',\n   col = \"white\",\n   cex = 0.7)\n\n\n\n\n\n\n\n\n\n## Simple feature collection with 39 features and 3 fields\n## Geometry type: POINT\n## Dimension:     XY\n## Bounding box:  xmin: 411944.2 ymin: 6178233 xmax: 412839 ymax: 6179056\n## Projected CRS: WGS 84 / UTM zone 37N\n## # A tibble: 39 × 4\n##    NAME          AMENITY              geometry count\n##    &lt;chr&gt;         &lt;chr&gt;             &lt;POINT [m]&gt; &lt;dbl&gt;\n##  1 Журфак        restaurant (411944.2 6178611)     1\n##  2 Гоголь-моголь cafe       (411968.6 6178588)     1\n##  3 Манкс & Нанс  bar        (412029.5 6178819)     1\n##  4 5 специй      restaurant (412045.3 6178814)     1\n##  5 45            bar        (412063.1 6178771)     1\n##  6 Генацвале     restaurant (412072.2 6178255)     1\n##  7 Чемодан       restaurant (412092.2 6179000)     1\n##  8 Азия Кафе     restaurant (412142.7 6178592)     1\n##  9 Лица          restaurant   (412139 6178358)     1\n## 10 Баба Марта    restaurant (412154.8 6178720)     1\n## # ℹ 29 more rows\n\nВ качестве примера аналогичного анализа отберем все пункты питания, находящиеся в пределах 100 метров от реки Москвы:\n\nriver = water |&gt; filter(NAME == \"Москва\") |&gt; st_union()\nzone = st_buffer(river, dist = 100)\n\nselected_poi = poi_food[zone, ]\n\nbasemap2()\n\n# Визуализируем результаты анализа\nmf_base(zone,\n     col = adjustcolor(\"sienna3\", alpha.f = 0.5),\n     border = \"sienna3\",\n     add = TRUE)\n\nmf_base(river,\n     col = adjustcolor(\"cyan\", alpha.f = 0.5),\n     border = \"black\",\n     add = TRUE)\n\nmf_base(selected_poi, \n     col = \"red\", \n     pch = 20, \n     cex = 1.5, \n     add = TRUE)\n\n\n\n\n\n\n\n\n\n## Simple feature collection with 39 features and 3 fields\n## Geometry type: POINT\n## Dimension:     XY\n## Bounding box:  xmin: 411661.2 ymin: 6176685 xmax: 415287.1 ymax: 6178953\n## Projected CRS: WGS 84 / UTM zone 37N\n## # A tibble: 39 × 4\n##    NAME                 AMENITY              geometry count\n##    &lt;chr&gt;                &lt;chr&gt;             &lt;POINT [m]&gt; &lt;dbl&gt;\n##  1 Белый журавль        restaurant (411661.2 6177029)     1\n##  2 What's Up Dog!       fast_food  (411871.8 6176685)     1\n##  3 Coffee@Парк Горького cafe       (411917.7 6176775)     1\n##  4 Sekta                restaurant   (411975 6176908)     1\n##  5 GlowSubs             fast_food  (412060.5 6177161)     1\n##  6 Чай & кофе           cafe       (412197.5 6177284)     1\n##  7 Академия             restaurant (412222.4 6177790)     1\n##  8 Kaffebrod            cafe       (412280.3 6177452)     1\n##  9 Les                  cafe       (412299.1 6177468)     1\n## 10 Beefbar              restaurant (412344.9 6177823)     1\n## # ℹ 29 more rows",
    "crumbs": [
      "Пространственный анализ",
      "<span class='chapter-number'>13</span>  <span class='chapter-title'>Векторный анализ</span>"
    ]
  },
  {
    "objectID": "13-VectorAnalysis.html#conc_zones",
    "href": "13-VectorAnalysis.html#conc_zones",
    "title": "13  Векторный анализ",
    "section": "13.7 Анализ конкурентных зон окружения",
    "text": "13.7 Анализ конкурентных зон окружения\nВ данном разделе мы решим следующую задачу: разбить всю изучаемую территорию на зоны окружения станций метро и подсчитать количество пунктов питания, попадающих в каждую зону. Полученные зоны должны быть конкурентными: любая точка, находящаяся в зоне окружения конкретной станции метро, должна быть ближе к этой станции, чем к любой другой станции.\nРанее мы говорили о том, что конкурентные зоны окружения по расстоянию можно реализовать с помощью диаграммы Вороного. Применим функцию st_voronoi() из пакета sf, чтобы посмотреть, как выглядит диаграмма Вороного для точек станций метро:\n\n\n## АНАЛИЗ КОНКУРЕНТНЫХ ЗОН ОКРУЖЕНИЯ -------------------------------------\n\nzones = stations |&gt; \n  st_combine() |&gt; \n  st_voronoi() |&gt; \n  st_collection_extract() |&gt; \n  st_crop(frame)\n  \nmf_base(zones)\nmf_base(stations, add = TRUE, pch = 19, col = 'black')\n\n\n\n\n\n\n\n\nДля визуализации результатов мы будем использовать метод картодиаграмм (пропорциональных символов), реализованный в функции propSymbolsLayer() пакета cartography. Размером кружка покажем количество пунктов питания, оказавшихся в каждой зоне окружения:\n\n# Агрегруем данные по каждой зоне\nzones_poi = aggregate(poi_food['count'], zones, sum)\n\n# Визуализируем результат\n\nbasemap2()\nmf_base(zones, col = adjustcolor(\"white\", alpha.f = 0.5),\n        add = TRUE)\nmf_map(zones_poi, var = 'count', type = 'prop', \n       col = adjustcolor(\"turquoise3\", alpha.f = 0.5),\n       border = F,\n       leg_title = \"Заведений\\nпитания\")\nmf_label(zones_poi, \n     var = 'count',\n     col = \"turquoise4\",\n     cex = log(zones_poi$count)/4)",
    "crumbs": [
      "Пространственный анализ",
      "<span class='chapter-number'>13</span>  <span class='chapter-title'>Векторный анализ</span>"
    ]
  },
  {
    "objectID": "13-VectorAnalysis.html#areal_interpolation",
    "href": "13-VectorAnalysis.html#areal_interpolation",
    "title": "13  Векторный анализ",
    "section": "13.8 Интерполяция, взвешенная на площадь",
    "text": "13.8 Интерполяция, взвешенная на площадь\nВ некоторых случаях необходимо осуществить так называемую интерполяцию, взвешенную на площадь. Данный метод применяется в тех случаях, когда исходная информация привязана не к точечным, а к площадным объектам. Задача заключается в том, чтобы с одной площадной сетки перенести на другую (как правило, регулярную, обладающую большей дискретностью). Необходимость подобного преобразования может быть обусловлена следующими (но и не только) причинами:\n\nметод анализа (например, моделирование диффузии) предполагает, что данные распределены по регулярной сетке, в то время как исходная сетка нерегулярна.\nнеобходимо обеспечить сравнимость пространственных распределений показателя для разных территорий, в то время как дробность исходного территориального деления существенно меняется в пространстве.\n\nМетод интерполяции по ареалам реализуется средствами функции st_interpolate_aw() из пакета sf. Данной функции необходимо подать исходную и целевую полигональную сетку, а также указать тип параметра: интенсивный или экстенсивный:\n— экстенсивные параметры суммируются и делятся при агрегировании/агрегировании территориальных единиц. Например, площадь, покрытая лесом или численность населения — это экстенсивный параметр. - интенсивные параметры осредняются или остаются постоянными при агрегировании/дизагрегировании территориальных единиц. Например, густота древостоя и плотность населения — интенсивные параметры.\nРассмотрим это метод интерполяции на примере данных по графствам Северной Каролины (показатель — количество новорожденных в 1974 году). Для расчета векторной регулярной сетки используем функцию st_make_grid() из пакета sf.\n\n# Данные по Северной Каролине\nnc = st_read(system.file(\"shape/nc.shp\", package=\"sf\"))\n## Reading layer `nc' from data source \n##   `/Library/Frameworks/R.framework/Versions/4.3-x86_64/Resources/library/sf/shape/nc.shp' \n##   using driver `ESRI Shapefile'\n## Simple feature collection with 100 features and 14 fields\n## Geometry type: MULTIPOLYGON\n## Dimension:     XY\n## Bounding box:  xmin: -84.32385 ymin: 33.88199 xmax: -75.45698 ymax: 36.58965\n## Geodetic CRS:  NAD27\n\ncells = st_make_grid(nc, cellsize = 0.25)\n\nbirth = st_interpolate_aw(nc[\"BIR74\"], \n                       cells, \n                       extensive = FALSE)\n\n# исходное распределение\nmf_map(nc, var = 'BIR74', type = 'choro')\n\n\n\n\n\n\n\n\n# пересчет на регулярную сетку\nmf_map(birth, var = 'BIR74', type = 'choro')\nmf_base(nc, col = NA, border = 'white', add = TRUE)",
    "crumbs": [
      "Пространственный анализ",
      "<span class='chapter-number'>13</span>  <span class='chapter-title'>Векторный анализ</span>"
    ]
  },
  {
    "objectID": "13-VectorAnalysis.html#дирекционные-отношения",
    "href": "13-VectorAnalysis.html#дирекционные-отношения",
    "title": "13  Векторный анализ",
    "section": "13.9 Дирекционные отношения",
    "text": "13.9 Дирекционные отношения\n\n13.9.1 Статистика направлений\n\n13.9.1.1 Теория\nВ географии направления играют огромную роль. Ветер, морские течения, уличная сеть, перелеты птиц — эти явления можно охарактеризовать их направленностью. Для того, чтобы эффективно анализировать такие данные, необходимо владеть специализированным математическим аппаратом.\nОбработкой данных о направлениях занимается особая область математической статистики — статистика направлений, или круговая (циркулярная) статистика (Mardia, Jupp, 2000; Pewsey et al., 2013). В круговой статистике каждое направление \\(\\theta \\in [0, 2\\pi)\\) представляется в виде вектора \\(x = (\\cos \\theta, sin \\theta)\\). Все операции производятся над подобными векторами и их координатами. Аналогом нормального распределения для круговой случайной величины является распределение фон Мизеса (von Mises, 1918), которое задается функцией плотности вероятности: \\[\nf(θ)=\\frac{1}{2 \\pi I_0(\\kappa)} e^{\\kappa \\cos (\\theta - \\mu)},\n\\]\nгде \\(\\kappa \\geq 0\\) — параметр концентрации, \\(\\mu\\) — среднее значение (для \\(\\kappa &gt; 0\\)) и\n\\[\nI_p(\\kappa) = \\frac{1}{2π} \\int_{0}^{2\\pi} \\cos (p \\theta) e^{\\kappa \\cos θ} d \\theta\n\\] есть модифицированная функция Бесселя первого рода и порядка \\(p\\). Из формул видно, что по своему эффекту параметр концентрации противоположен среднеквадратическому отклонению \\(\\sigma\\), которое является параметром нормального распределения. Чем больше значение \\(\\kappa\\), тем более сконцентрировано распределение относительно среднего значения — отсюда идет название этого параметра. Распределение фон Мизеса используется для построения ядра при аппроксимации плотности распределения направлений методом ядерной оценки (оценки по методу Парзена-Розенблатта).\n\nВ метеорологии значения \\(\\cos \\theta\\) и \\(\\sin \\theta\\) определяют соотношение зональной и меридиональной составляющей скорости [ветра] (для получения самих составляющих их надо умножить на скорость ветра).\n\nДля вычисления статистических моментов круговой случайной величины требуется найти средний равнодействующий вектор первого порядка: \\[R = (C, S),\\] где\n\\[C = \\frac{1}{n} \\sum_{j=1}^{n} \\cos \\theta_j,\\\\\nS = \\frac{1}{n} \\sum_{j=1}^{n} \\sin \\theta_j.\\]\nДанный вектор имеет направление \\(\\bar\\theta\\), которое является выборочным средним направлением исследуемой величины.\nВыборочная средняя равнодействующая длина \\(\\bar R = \\sqrt{C^2 + S^2}\\) принимает значения в диапазоне \\([0, 1]\\) и показывает меру концентрации направлений относительно \\(\\theta\\). \\(\\bar R = 1\\) означает, что все исходные направления совпадают, \\(\\bar R = 0\\) — что данные равномерно распределены по кругу, либо распределение имеет несколько мод, которые уравновешивают друг друга.\nВеличина \\(\\bar R\\) дает важную информацию для предварительной диагностики картины направлений. Если значение \\(\\bar R\\) близко к единице, это означает, что распределение является унимодальным и в качестве основного направления можно принять значение \\(\\bar θ\\) (Mardia and Jupp 2000).\nСтандартное отклонение направлений \\(v\\) в радианах может быть найдено как \\(v=\\sqrt{-2 \\ln \\bar R}\\) .\nВ ряде случаев противоположные направления считаются эквивалентными. Например, нельзя сказать, идет ли улица с юга на север или с севера на юг. Такие данные в теории круговой статистики называются аксиальными (Mardia, Jupp, 2000). Для аксиальных данных возможный диапазон значений лежит в интервале \\([0, \\pi)\\). Поскольку методы круговой статистики рассчитаны на круговое замыкание данных, стандартный подход к обработке аксиальных данных предполагает переход от направлений к их удвоенным значениям \\(\\theta' = 2\\theta\\), обработку полученных значений стандартными методами и отображение полученных значение обратно на интервал \\([0, \\pi)\\). Для среднего, медианы и моды распределения это означает простое деление полученного значения пополам (Pewsey, Neuhäuser, and Ruxton 2013).\nМодальные направления могут быть определены как по гистограмме распределения, так и методом ядерной оценки. Основной вопрос поиска эффективного ядра заключается в параметризации функции \\(K\\). Для распределения фон Мизеса таким параметром является концентрация \\(\\kappa\\). Чем больше этот параметр, тем более локализованной будет оценка, тем сильнее будут проявляться в ней существующие моды распределения, но также будут и выделяться новые моды, которые на самом деле не значимы. Малые значения \\(\\kappa\\) приведут, наоборот, к «размыванию» плотности распределения в пределах полного круга. Как и в случае с количеством интервалов гистограммы, избыточно малые и большие значения κ нежелательны.\nВ работе (M. Oliveira, Crujeiras, and Rod’riguez-Casal 2012) показано, что оптимальное значение \\(\\kappa\\) может быть подобрано также для оценки распределений, являющихся конечной суммой \\(M\\) распределений фон Мизеса, то есть, мультимодальных распределений, имеющих плотность : \\[g(\\theta)=\\sum_{i=1}^{M} \\alpha_i \\frac{\\exp\\lbrace{\\kappa_i \\cos(\\theta - \\mu_i)\\rbrace}}{2 \\pi I_0 (\\kappa_i)},\\] где \\(\\sum_{i=1}^{M} = 1\\).\nПоскольку в результате подбора определяется не только параметр концентрации, но и число компонент в сумме распределений (Ma’ria Oliveira, Crujeiras, and Rod’riguez-Casal 2014), его можно также использовать для определения количества искомых мод, если это необходимо.\nКогда подобрана функция ядра и ее параметры, оценка плотности распределения (вычисление функции \\(\\circ f _h (x)\\)) для круговых данных делается либо для исходных направлений \\(\\theta_j\\), либо с равным (достаточно малым) интервалом — например, через 1 градус (Pewsey, Neuhäuser, and Ruxton 2013). После того как произведена оценка, могут быть выбраны направления, в которых функция плотности распределения достигает локального максимума — первого и второго по величине. Эти направления и будут соответствовать первой и второй моде распределения направлений.\n\n\n\n13.9.2 Практика\nВ практической части данного раздела мы будем работать с массивом среднемесячных значений метеопараметров в пограничном слое атмосферы по полярным аэрологическим обсерваториям России. Массив данных ежемесячно обновляется на портале Аисори-М ВНИИГМИ-МЦД.\nВ системе доступны данные по следующим обсерваториям:\n\nobs = read_excel('data/bound/scheme.xlsx', 2)\n\n\n\n\n\n\nИндекс\nНазвание\nШирота\nДолгота\n\n\n\n\n20674\nОстров Диксон\n73.50\n80.42\n\n\n21824\nТикси\n71.35\n128.55\n\n\n22113\nМурманск\n68.59\n33.07\n\n\n22217\nКандалакша\n67.09\n32.21\n\n\n22271\nШойна\n67.53\n44.09\n\n\n23078\nНорильск\n69.20\n88.18\n\n\n23205\nНарьян-Мар\n67.39\n53.07\n\n\n23330\nСалехард\n66.32\n66.40\n\n\n24125\nОленек\n68.31\n112.26\n\n\n24266\nВерхоянск\n67.55\n133.38\n\n\n24343\nЖиганск\n66.46\n123.21\n\n\n89512\nНоволазаревская\n-70.75\n11.83\n\n\n89592\nМирный\n-66.65\n19.71\n\n\n\n\n\nДля каждой обсерватории даны следующие параметры:\n\n\n\n\n\n\n\n\n\n\n\n\nПризначная часть/ метеоэлемент/число наблюдений\nОбозначение\nЧисло цифр\nЕдиницы измерения\nКонстанта отсутствия\n\n\n\n\nИндекс станции\nINDEX\n5\n-\nнет\n\n\nГод\nGGGG\n5\n-\nнет\n\n\nМесяц\nMM\n3\n-\nнет\n\n\nСрок\nHH\n3\nGMT\nнет\n\n\nСтандартное значение высоты\nZ\n6\nм\nнет\n\n\nСреднемесячные значения давления\nMP\n6\n10·гПа\n-9999\n\n\nСреднеквадратические отклонения давления\nSP\n6\n10·гПа\n-9999\n\n\nЧисло наблюдений для давления\nNP\n3\n-\nнет\n\n\nСреднемесячные значения температуры\nMT\n6\n10·°C\n-9999\n\n\nСреднеквадратические отклонения температуры\nST\n6\n10·°C\n-9999\n\n\nЧисло наблюдений для температуры\nNT\n3\n-\nнет\n\n\nСреднемесячные значения дефицита точки росы\nMD\n6\n10·°C\n-9999\n\n\nСреднеквадратические отклонения дефицита точки росы\nSD\n6\n10·°C\n-9999\n\n\nЧисло наблюдений для дефицита точки росы\nND\n3\n-\nнет\n\n\nСреднемесячные значения скалярной скорости ветра\nMS\n6\n10·м/с\n-9999\n\n\nСреднеквадратические отклонения скалярной скорости ветра\nSS\n6\n10·м/с\n-9999\n\n\nЧисло наблюдений для скалярной скорости ветра\nNS\n3\n-\nнет\n\n\nСреднемесячные значения зональной составляющей скорости ветра\nMU\n6\n10·м/с\n-9999\n\n\nСреднеквадратические отклонения зональной составляющей скорости ветра\nSU\n6\n10·м/с\n-9999\n\n\nЧисло наблюдений для зональной составляющей скорости ветра\nNU\n3\n-\nнет\n\n\nСреднемесячные значения меридиональной составляющей скорости ветра\nMV\n6\n10·м/с\n-9999\n\n\nСреднеквадратические отклонения меридиональной составляющей скорости ветра\nSV\n6\n10·м/с\n-9999\n\n\nЧисло наблюдений для меридиональной составляющей скорости ветра\nNV\n3\n-\nнет\n\n\n\n\n\nЗагрузим данные по всем обсерваториям из текстовых файлов в папке bound:\n\nfiles = paste('data/bound', list.files('data/bound', \"*.txt\"), sep = '/')\n\n(tab = lapply(files, function(X) {\n    read_table(X, col_names = params$Обозначение)\n  }) |&gt; \n  bind_rows() |&gt; \n  left_join(obs, by = c('INDEX' = 'Индекс'))) # присоединим информацию о названиях станций\n## # A tibble: 77,073 × 26\n##    INDEX  GGGG    MM    HH     Z    MP    SP    NP    MT    ST    NT    MD    SD\n##    &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt;\n##  1 20674  2007     1     0  2000  7629    78    27  -187    35    27    53    46\n##  2 20674  2007     1     0  1900  7732    79    27  -182    36    27    52    46\n##  3 20674  2007     1     0  1800  7836    79    27  -178    36    27    51    45\n##  4 20674  2007     1     0  1700  7942    80    27  -173    36    27    49    44\n##  5 20674  2007     1     0  1600  8048    81    27  -168    36    27    48    44\n##  6 20674  2007     1     0  1500  8157    81    27  -164    38    27    47    44\n##  7 20674  2007     1     0  1400  8266    82    27  -160    39    27    45    44\n##  8 20674  2007     1     0  1300  8376    82    27  -156    39    27    43    42\n##  9 20674  2007     1     0  1200  8488    83    27  -152    40    27    40    40\n## 10 20674  2007     1     0  1100  8601    83    27  -148    41    27    37    39\n## # ℹ 77,063 more rows\n## # ℹ 13 more variables: ND &lt;dbl&gt;, MS &lt;dbl&gt;, SS &lt;dbl&gt;, NS &lt;dbl&gt;, MU &lt;dbl&gt;,\n## #   SU &lt;dbl&gt;, NU &lt;dbl&gt;, MV &lt;dbl&gt;, SV &lt;dbl&gt;, NV &lt;dbl&gt;, Название &lt;chr&gt;,\n## #   Широта &lt;dbl&gt;, Долгота &lt;dbl&gt;\n\nСоздадим объект типа circular (из пакета circular) с направлениями ветра для анализа, и запишем его в новую переменую таблицы. Предварительно определим вспомогательную функцию, вычисляющую географический азимут на основе компонент скорости:\n\ngeo_azimuth = function(dx, dy) {\n  a = atan2(dx, dy)\n  ifelse(a &lt;= pi/2, pi/2 - a,  5*pi/2 - a)\n}\n\n(winds = tab |&gt; \n  mutate(wind = circular(geo_azimuth(MV, MU), template = 'geographics')) %&gt;% \n  select(INDEX, name = Название, GGGG, MM, HH, Z, MU, MV, SS, wind))\n## # A tibble: 77,073 × 10\n##    INDEX name           GGGG    MM    HH     Z    MU    MV    SS wind      \n##    &lt;dbl&gt; &lt;chr&gt;         &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;circular&gt;\n##  1 20674 Остров Диксон  2007     1     0  2000    33    31    45 0.8166380 \n##  2 20674 Остров Диксон  2007     1     0  1900    32    32    45 0.7853982 \n##  3 20674 Остров Диксон  2007     1     0  1800    30    33    46 0.7378151 \n##  4 20674 Остров Диксон  2007     1     0  1700    29    35    47 0.6919214 \n##  5 20674 Остров Диксон  2007     1     0  1600    28    38    49 0.6350267 \n##  6 20674 Остров Диксон  2007     1     0  1500    26    40    50 0.5763752 \n##  7 20674 Остров Диксон  2007     1     0  1400    25    41    51 0.5475622 \n##  8 20674 Остров Диксон  2007     1     0  1300    25    42    54 0.5369107 \n##  9 20674 Остров Диксон  2007     1     0  1200    24    45    56 0.4899573 \n## 10 20674 Остров Диксон  2007     1     0  1100    24    49    58 0.4554511 \n## # ℹ 77,063 more rows\n\nВыберем данные по высоте 0 метров за 12 часов дня для поселка Тикси, сохранив только составляющие скорости и ее скалярную величину:\n\n(tiksi_wind = winds |&gt; filter(name == 'Тикси', HH == 12, Z == 0))\n## # A tibble: 136 × 10\n##    INDEX name   GGGG    MM    HH     Z    MU    MV    SS wind      \n##    &lt;dbl&gt; &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;circular&gt;\n##  1 21824 Тикси  2007     1    12     0    36    35    48 0.7994817 \n##  2 21824 Тикси  2007     2    12     0    16    11    27 0.9685090 \n##  3 21824 Тикси  2007     3    12     0    23    22    34 0.8076167 \n##  4 21824 Тикси  2007     4    12     0    17     9    30 1.0838971 \n##  5 21824 Тикси  2007     5    12     0   -17    -3    34 4.5377168 \n##  6 21824 Тикси  2007     6    12     0   -23   -25    27 3.8853482 \n##  7 21824 Тикси  2007     7    12     0    -5   -11    27 3.5682201 \n##  8 21824 Тикси  2007     8    12     0     4     5    25 0.6747409 \n##  9 21824 Тикси  2007     9    12     0    24    14    34 1.0427219 \n## 10 21824 Тикси  2007    10    12     0    41    47    40 0.7173217 \n## # ℹ 126 more rows\n\nОтобразим распределение направлений, розу-диаграмму и плотность распределения. Для построени графиков используем функции plot.circular() и rose.diag из пакета circular. Для аппроксимации плотности распределения направлений воспользуемся функцией kern.den.circ() из пакета NPCirc. Эта функция использует функцию плотности распределения фон Мизеса в качестве ядра и по умолчанию разбивает круг на 250 направлений, по которым производится оценка плотности (при необходимости это значение можно изменить в параметре len):\n\nplot.circular(tiksi_wind$wind, \n     cex = 0.5, \n     stack = TRUE, \n     sep = 0.035,\n     axes = FALSE,\n     main = 'Среднемноголетняя роза ветров в Тикси',\n     sub = 'Измерения за период с 2007 по 2018 г, высота 0 м')\n\nrose.diag(tiksi_wind$wind, \n          bins = 8, \n          col = 'gray70',\n          border = 'gray30',\n          prop = 1, \n          add = TRUE, \n          tick = FALSE,\n          lwd = 0.5)\n\nkden = kern.den.circ(tiksi_wind$wind)\n\nlines(kden, shrink = 3, # параметр shrink отвечает за масштаб радиус-вектора\n      join = F,\n      col = 'steelblue')\n\n\n\n\n\n\n\n\n\nПараметр shrink отвечает за масштаб радиус-вектора на графиках из пакета circular. Чем больше его величина, тем сильнее будет сжат график относительно центра круга.\n\nТак же как и в случае с обычными данными, плотность распределения удобно использовать для определения модальных направлений, то есть наиболее часто встречающихся. Для этого воспользуемся функцией findpeaks() из пакета pracma:\n\npeak = findpeaks(kden$y, sortstr = T)[1,2] # находим индекс самого высокого пика плотности распределения\n\n(modal = kden$x[peak]) # извлекаем сам угол\n## Circular Data: \n## Type = angles \n## Units = radians \n## Template = geographics \n## Modulo = asis \n## Zero = 1.570796 \n## Rotation = clock \n## [1] 0.7346777\n\n# раскладываем на составляющие для отрисовки линии\nxp = sin(modal)\nyp = cos(modal)\n\nplot.circular(tiksi_wind$wind, \n     cex = 0.5, \n     stack = TRUE, \n     sep = 0.035,\n     axes = FALSE,\n     main = 'Среднемноголетняя роза ветров в Тикси',\n     sub = 'Измерения за период с 2007 по 2018 г, высота 0 м')\n\nrose.diag(tiksi_wind$wind, \n          bins = 8, \n          col = 'gray70',\n          border = 'gray30',\n          prop = 1, \n          add = TRUE, \n          tick = FALSE,\n          lwd = 0.5)\n\nlines(kden, shrink = 3, \n      join = F, col = 'steelblue')\n\nlines(c(0, xp), c(0, yp),\n      lwd = 2, col = 'orangered')\n\ntext(x = 1.4 * xp, y = 1.4 * yp, \n     col = 'orangered',\n     labels = paste0(round(180 * modal / pi, 0), '°')) # приводим к целым градусам\n\n\n\n\n\n\n\n\nПроведем анализ направлений для всех станций. Для этого рассчитаем функции плотности распределения и разместим их в новом фрейме данных с лист-колонкой.\n\nЛист-колонка (list-column) позволяет хранить в ячейках таблицы данные произвольного типа. В частности, используя лист-колонку, вы можете хранить в каждой ячейке не один объект, а множество объектов, например записать в нее вектор. Лист-колонка имеет тип list, и каждая ячейка в этой колонке так же, соответственно, имеет тип list. Что (и в каком количестве) располагать внутри ячейки — уже ваше дело. Лист-колонки оказываются неожиданно удобны в самых разнообразных сценариях, в том числе для представления статистических моделей (соответствующих каждой строке таблицы) и для хранения пространственных данных (об этом — в следующей лекции). Вместо хранения этих данных в отдельных переменных вы можете записать их в ячейки.\n\nВ приведенном ниже коде мы группируем все измерения по имени аэрологической обсерватории, вычисляем вектор плотности распределения, записываем его в список, и этот список уже помещается функцией summarise() в единственную ячейку столбца kden, соответствующую данной аэрологической станции. Далее полученная лист-колонка используется для нахождения модальных значений (тут оказывается полезно знание функционалов семейства apply):\n\n(dens = winds |&gt; \n  filter(HH == 12, Z == 0) |&gt; \n  group_by(name) |&gt; \n  summarise(kden = list(kern.den.circ(wind))) |&gt; \n  mutate(peak = sapply(kden, function(X) {\n                  peak = findpeaks(X$y, sortstr = T)[1,2]\n                  X$x[peak]\n                })\n  )\n)\n## # A tibble: 13 × 3\n##    name            kden         peak\n##    &lt;chr&gt;           &lt;list&gt;      &lt;dbl&gt;\n##  1 Верхоянск       &lt;dnsty.cr&gt; -1.77 \n##  2 Жиганск         &lt;dnsty.cr&gt; -1.50 \n##  3 Кандалакша      &lt;dnsty.cr&gt; -4.37 \n##  4 Мирный          &lt;dnsty.cr&gt; -3.78 \n##  5 Мурманск        &lt;dnsty.cr&gt;  0.772\n##  6 Нарьян-Мар      &lt;dnsty.cr&gt;  0.563\n##  7 Новолазаревская &lt;dnsty.cr&gt; -3.84 \n##  8 Норильск        &lt;dnsty.cr&gt; -3.85 \n##  9 Оленек          &lt;dnsty.cr&gt; -1.18 \n## 10 Остров Диксон   &lt;dnsty.cr&gt; -4.64 \n## 11 Салехард        &lt;dnsty.cr&gt; -1.90 \n## 12 Тикси           &lt;dnsty.cr&gt;  0.735\n## 13 Шойна           &lt;dnsty.cr&gt;  1.01\n\nПосле этого построим розы-диаграммы для всех станций. В данном случае оправдано использование обычного цикла, т.к. итераций немного:\n\n# устанавливаем параметры компоновки\npar(mar = c(1,1,1,1),\n    mfrow = c(1,2))\n\n# строим графики в цикле\nfor (obs_name in dens$name) {\n  \n  wind_df = winds |&gt; filter(name == obs_name, HH == 12, Z == 0)\n  dens_df = dens |&gt; filter(name == obs_name)\n  \n  modal = dens_df$peak\n\n  xp = sin(modal)\n  yp = cos(modal)\n  \n  plot.circular(wind_df$wind, \n       shrink = 1.2,\n       cex = 0.5, \n       stack = TRUE, \n       sep = 0.035,\n       axes = FALSE,\n       main = obs_name)\n  \n  rose.diag(wind_df$wind, \n            bins = 8, \n            col = 'gray70',\n            border = 'gray30',\n            prop = 1, \n            add = TRUE, \n            tick = FALSE,\n            lwd = 0.5)\n  \n  lines(dens_df$kden[[1]], \n        shrink = 3, join=F,\n        col = 'steelblue')\n  \n  lines(c(0, xp), c(0, yp),\n        lwd = 2, col = 'orangered')\n  \n  text(x = 1.4 * xp, y = 1.4 * yp, \n       col = 'orangered',\n       labels = paste0(round(180 * modal / pi, 0), '°')) # приводим к целым градусам\n}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nТаким образом, мы провели графический и статистический анализ среднемноголетних направлений ветра по данным полярных аэрологических станций России. Выявлены модальные направлений, выполнена аппроксимация функции плотности вероятности направлений ветра.",
    "crumbs": [
      "Пространственный анализ",
      "<span class='chapter-number'>13</span>  <span class='chapter-title'>Векторный анализ</span>"
    ]
  },
  {
    "objectID": "13-VectorAnalysis.html#vector_review",
    "href": "13-VectorAnalysis.html#vector_review",
    "title": "13  Векторный анализ",
    "section": "13.10 Краткий обзор",
    "text": "13.10 Краткий обзор\nДля просмотра презентации щелкните на ней один раз левой кнопкой мыши и листайте, используя кнопки на клавиатуре:\n\n\n\n\n\nПрезентацию можно открыть в отдельном окне или вкладке браузере. Для этого щелкните по ней правой кнопкой мыши и выберите соответствующую команду.",
    "crumbs": [
      "Пространственный анализ",
      "<span class='chapter-number'>13</span>  <span class='chapter-title'>Векторный анализ</span>"
    ]
  },
  {
    "objectID": "13-VectorAnalysis.html#qtasks_vector_analysis",
    "href": "13-VectorAnalysis.html#qtasks_vector_analysis",
    "title": "13  Векторный анализ",
    "section": "13.11 Контрольные вопросы и упражнения",
    "text": "13.11 Контрольные вопросы и упражнения\n\n13.11.1 Вопросы\n\nПеречислите три основных вида пространственных отношений, приведите их примеры.\nПеречислите 8 вариантов топологических отношений и названий функций sf, которые им соответствуют.\nОпишите способ, с помощью которого можно выбрать пространственные объекты, пересекающиеся с заданным множеством пространственных объектов.\nКаким образом можно заменить тип топологического отношения с пересечения на любой другой при выполнении пространственной выборки?\nЧем отличаются контекстные и целевые объекты?\nВ чем заключается отличие абсолютных и конкурентных зон окружения?\nКакая функция пакета sf позволяет вычислять расстояния между объектами? Как с помощью полученного результата определить для каждого объекта из множества \\(A\\) определить ближайший к нему объект из множества \\(B\\)?\nОпишите последовательность действий, которую необходимо выполнить для подсчета количества точечных объектов по заданной сетке полигонов.\nС помощью какой функции можно построить буферную зону вокруг пространственного объекта? Есть ли ограничения на размерность буферизуемого пространственного объекта (точка, линия, полигон)? Можно ли построить буфер вокруг поверхности?\nКакая геометрическая структура используется для построения конкурентных зон окружения?\nЧто такое OSRM?\nКакими средствами можно построить зоны транспортной доступности и маршруты в среде R? В какой системе координат должны быть точки, участвующие в сетевом анализе?\nОпишите возможности и основные функции пакета cartography, с помощью которых можно строить тематические карты способами картограмм, картодиаграмм и линейных знаков, а также легенды к ним.\nВ каком виде направления рассматриваются в круговой статистике?\nКакое распределение является аналогом нормального распределения для круговых данных? Что означают параметры \\(\\kappa\\) и \\(\\mu\\) в функции этого распределения?\nКак вычисляется равнодействующий вектор первого порядка и выборочная средняя равнодействующая длина этого вектора для направлений?\nЧем аксиальные данные отличаются от круговых данных в общем случае? Какие преобразования осуществляются над такими данными для того чтобы применять к ним стандартные методы циркулярной статистики?\nКакой класс данных (и пакет) можно использовать в R для представления направлений? Как указать, что направления отсчитываются географическим методом, то есть, по часовой стрелки от направления на север?\nКакую функцию можно использовать для для оценки плотности распределения круговых данных? В каком пакете она находится?\nКакую функцию можно использовать для выявления модальных направлений по данным функции плотности вероятности?\nКакие функции позволяют строить диаграммы и розы-диаграммы по круговым данным в среде R?\nКакой параметр управляет масштабом радиус-вектора на круговых графиках?\nЧто такое лист-колонка в фрейме данных, и какого типа данные можно в ней хранить?\n\n\n\n13.11.2 Упражнения\n\nПроанализируйте пространственную ассоциацию подтипов почв с типами рельефа данным ГИС Сатино. Для этого выполните оверлей между слоями RelTypes и SoilTypes методом st_intersection(). Для каждого подтипа почв рассчитайте долю, которая занята в его площади каждым типом рельефа. Визуализируйте результаты средствами ggplot2 в виде столбчатой диаграммы, где каждый столбик отвечает за подтип почвы, а его внутреннее разделение соответствует долям типов рельефа. Используя функцию cramerV() из пакета rcompanion, рассчитайте коэффициент ассоциации Крамера, чтобы охарактеризовать силу ассоциации между этими номинальными переменными.\n\nПодсказка: для вычисления коэффциента Крамера вам необходимо преобразовать данные в широкую форму, где подтипы почв идут по строкам, а типы рельефа — по столбцам. Полученную таблицу необходимо конвертировать в матрицу и подать на вход функции cramerV().\n\nОдна из гипотез, часто используемых в геомаркетинге — это так называемые аттракторы потоков — пространственные объекты, которые сосредотачивают в своей близости высокую плотность пешеходного трафика. Типичный пример аттрактора — любая транспортная локация: выход из метро, железнодорожная платформа, автобусная остановка. Владельцы предприятий сферы услуг в теории стремятся размещать свои точки вблизи к аттракторам. Используя данные из настоящей лекции, проведите проверку реалистичности этой теории. Для этого:\n\nпостройте вокруг выходов станций метро несколько буферных зон увеличивающегося радиуса\nвыберите ими пункты общественного питания\nрассчитайте их плотность как отношение количества к площади буфера\n\nДалее постройте график зависимости между радиусом буфера и плотностью объектов интереса. Рассчитайте также коэффициент корреляции между этими величинами.\nСубъекты Российской Федерации пронумерованы числами от 1 до 85 в алфавитном порядке. Для решения задач пространственного анализа часто бывает необходимо, чтобы нумерация была пространственная. В этом случае соседние субъекты будут иметь похожие номера. Придумайте методику такой нумерации и реализуйте ее в виде программы на языке R.\n\n\n\n\nСамсонов Т.Е. Визуализация и анализ географических данных на языке R. М.: Географический факультет МГУ, 2023. DOI: 10.5281/zenodo.901911\n\n\n\n\n\n\n\nMardia, K V, and P E Jupp. 2000. Directional Statistics. Chichester New York: Wiley.\n\n\nOliveira, Ma’ria, Rosa M. Crujeiras, and Alberto Rod’riguez-Casal. 2014. “NPCirc : An R Package for Nonparametric Circular Methods.” Journal of Statistical Software 61 (9): 1–26. https://doi.org/10.18637/jss.v061.i09.\n\n\nOliveira, M., R. M. Crujeiras, and A. Rod’riguez-Casal. 2012. “A Plug-in Rule for Bandwidth Selection in Circular Density Estimation.” Computational Statistics and Data Analysis 56 (12): 3898–908. https://doi.org/10.1016/j.csda.2012.05.021.\n\n\nPewsey, Arthur, Markus Neuhäuser, and Graeme D. Ruxton. 2013. Circular Statistics in R. Oxford New York: Oxford University Press.",
    "crumbs": [
      "Пространственный анализ",
      "<span class='chapter-number'>13</span>  <span class='chapter-title'>Векторный анализ</span>"
    ]
  },
  {
    "objectID": "14-RasterAnalysis.html#предварительные-условия",
    "href": "14-RasterAnalysis.html#предварительные-условия",
    "title": "14  Растровый анализ",
    "section": "Предварительные условия",
    "text": "Предварительные условия\nДля выполнения кода данной лекции вам понадобятся следующие пакеты:\n\nlibrary(sf)\nlibrary(stars)\nlibrary(mapview)\nlibrary(mapedit)\nlibrary(classInt)\nlibrary(geosphere)\nlibrary(dplyr)\nlibrary(tidyr)\nlibrary(ggplot2)\nlibrary(terra)\nlibrary(tidyterra)\nlibrary(ggnewscale)",
    "crumbs": [
      "Пространственный анализ",
      "<span class='chapter-number'>14</span>  <span class='chapter-title'>Растровый анализ</span>"
    ]
  },
  {
    "objectID": "14-RasterAnalysis.html#raster_intro",
    "href": "14-RasterAnalysis.html#raster_intro",
    "title": "14  Растровый анализ",
    "section": "14.1 Введение",
    "text": "14.1 Введение\nРастровая модель данных представляет собой мощный инструмент абстракции пространственных распределений и выполнения пространственного анализа. На первый взгляд, растр обладает целым рядом ограничений по сравнению с векторной моделью: не позволяет оперировать отдельными объектами, их границами и так далее. Растровые карты и снимки мы часто оцифровываем, выделяя объекты, чтобы на основе них можно было что-то посчитать. Самые первые ГИС были исключительно растровыми, что сейчас воспринимается как архаизм.\nОднако за ширмой ограниченности растровой модели кроются огромные аналитические возможности. Растровая модель обладает внутренней топологией: ее ячейки соприкасаются друг с другом, что позволяет моделировать непрерывные в пространстве и динамические явления (при которых происходит перемещение вещества, энергии или информации в пространстве). Поскольку ячейки растра имеют одинаковый размер, к ним можно применять однотипные операции, которые будут давать предсказуемый результат вне зависимости от конкретной локации в пределах растра. Это также позволяет сделать обработку растра очень быстро.",
    "crumbs": [
      "Пространственный анализ",
      "<span class='chapter-number'>14</span>  <span class='chapter-title'>Растровый анализ</span>"
    ]
  },
  {
    "objectID": "14-RasterAnalysis.html#модель-растровых-данных-terra",
    "href": "14-RasterAnalysis.html#модель-растровых-данных-terra",
    "title": "14  Растровый анализ",
    "section": "14.2 Модель растровых данных terra",
    "text": "14.2 Модель растровых данных terra\nПакет terra содержит модели данных для растровых и векторных данных. Растровые данные создаются посредством функции rast:\n\n# Чтение данных\n(bed = rast('data/etopo1_bed.tif'))\n## class       : SpatRaster \n## dimensions  : 360, 720, 1  (nrow, ncol, nlyr)\n## resolution  : 0.5, 0.5  (x, y)\n## extent      : -180, 180, -90, 90  (xmin, xmax, ymin, ymax)\n## coord. ref. : lon/lat WGS 84 (EPSG:4326) \n## source      : etopo1_bed.tif \n## name        : etopo1_bed\n(ice = rast('data/etopo1_ice.tif'))\n## class       : SpatRaster \n## dimensions  : 360, 720, 1  (nrow, ncol, nlyr)\n## resolution  : 0.5, 0.5  (x, y)\n## extent      : -180, 180, -90, 90  (xmin, xmax, ymin, ymax)\n## coord. ref. : lon/lat WGS 84 (EPSG:4326) \n## source      : etopo1_ice.tif \n## name        : etopo1_ice\n\n\nggplot() +\n  geom_spatraster(data = bed) +\n  scale_fill_hypso_tint_c(palette = \"gmt_globe\") +\n  ggtitle('ETOPO Bedrock')\n\n\n\n\n\n\n\n\nggplot() +\n  geom_spatraster(data = ice) +\n  scale_fill_hypso_tint_c(palette = \"gmt_globe\") +\n  ggtitle('ETOPO Ice surface')",
    "crumbs": [
      "Пространственный анализ",
      "<span class='chapter-number'>14</span>  <span class='chapter-title'>Растровый анализ</span>"
    ]
  },
  {
    "objectID": "14-RasterAnalysis.html#растровая-алгебра",
    "href": "14-RasterAnalysis.html#растровая-алгебра",
    "title": "14  Растровый анализ",
    "section": "14.3 Растровая алгебра",
    "text": "14.3 Растровая алгебра\nСуществует классификация операций растрового анализа, введенная американским профессором Даной Томлином, которая объединяет их под общим названием “алгебра карт” или “растровая алгебра” (Tomlin 2012). Предполагая, что обработке подвергается каждая ячейка растра, данная классификация разделяет все операции по охвату относительно текущей ячейки\n\nЛокальные — анализируется одна ячейка растра или совпадающие в пространстве ячейки нескольких растров\nФокальные — анализируются все ячейки в окрестности. Окрестность может быть как фиксированной, так и расширенной (expanded), когда ее размер управляется внешними факторами, например множеством объектов, до которых требуется вычислить расстояние. Информация по соседним ячейкам может быть как из исходного растра, так и из внешнего. Фокальные методы алгебры карт также называются методами анализа соседства.\nЗональные — анализируются все ячейки в пределах зон, определяемых извне (например, вторым растровым слоем).\nГлобальные — анализируются все ячейки растра.\n\n\n14.3.1 Локальные операции\nЛокальные операции связаны с алгебраическими преобразованиями значений в ячейках. Например, цифровую модель высот в футах можно перевести в цифровую модель высот в метрах. Для этого нужно значение в каждой ячейке умножить на \\(0.3048\\). В локальных операциях могут участвовать несколько растров. Например, если у нас есть растровые поверхности плотности населения за разные года, мы можем вычесть одну поверхность из другой, чтобы получить поверхность изменений плотности, выяснить где она увеличилась, уменьшилась или осталось прежней. К локальным операциям относится также оверлей растров, при котором получается взвешенная сумма значений по нескольким растрам. И в том и в другом случае анализируются ячейки с нескольких растров, которые совпадают в пространстве.\nВ качестве примера определим мощность покровного оледенения в Антарктике и Гренландии, путем вычитание двух моделей ETOPO1, одна из которых показывает рельеф коренных пород (bedrock), а вторая — видимый рельеф поверхности (ice surface):\n\n# ЛОКАЛЬНЫЕ ОПЕРАЦИИ\n# Вычисление толщины покровного оледенения\n\n#  Береговая линия для ориентировки\ncountries = read_sf('data/countries.gpkg')\n\n# вычисление разности\nice.depth = ice - bed\nice.depth[ice.depth == 0] = NA\n\nggplot() +\n  geom_spatraster(data = bed) +\n  scale_fill_gradient(low = 'black', high = 'white',\n                      guide=\"none\") +\n  new_scale_fill() +\n  geom_spatraster(data = ice.depth) +\n  scale_fill_gradient(low = 'white', high = 'navyblue', \n                      na.value = \"transparent\") +\n  geom_sf(data = countries, fill = NA) +\n  labs(title = 'Мощность покровного оледенения',\n         fill = '[м]')\n\n\n\n\n\n\n\n\n\n\n14.3.2 Фокальные операции\nВ фокальных операциях участвует не только сама ячейка или совпадающие с ней ячейки других растров, но также ячейки, находящиеся в некоторой окрестности (опять же, в одном или нескольких растрах одновременно). Данный вид анализа подразделяется на две категории: фокальный анализ с фиксированной окрестностью и с расширенной окрестностью.\n\n14.3.2.1 Фиксированная окрестность\nВ общем случае фиксированная окрестность может иметь различную форму, однако наиболее часто используется квадратная окрестность размером \\(3\\times3\\):\n\n\n\n\n\nВиды растровых окрестностей. Темной точкой выделена анализируемая ячейка\n\n\n\n\nФокальные операции с фиксированной окрестностью — привычное дело в обработке изображений. Они работают по принципу “плавающего окна”. Выбранная окрестность (квадратная, круглая и т.д.) представляется в виде матрицы коэффициентов — так называемого ядра свёртки (convolution kernel). Далее эта матрица перемещается, позиционируясь последовательно над каждой ячейкой растра, и значение в этой ячейке заменяется на взвешенную сумму значений ячеек в окрестности, умноженных на соответствующие коэффициенты ядра свертки. Например, если ядро состоит из единиц, то будет посчитана обычная сумма.\nС помощью фокального анализа можно выполнить сглаживание изображения, которое убирает из него мелкие детали (высокочастотные составляющие яркостного сигнала). В качестве такого изображения может быть цифровая модель рельефа или космический снимок. Чтобы выполнить сглаживание, коэффициенты должны быть такими, чтобы получаемая взвешенная сумма осредняла значения в соседних ячейках. Самый простой вариант — это рассчитать среднее арифметическое. В этом случае коэффициенты ядра свертки будут равны \\(1/k\\), где \\(k\\) — количество ячеек в окрестности. Для матрицы \\(3\\times3\\) они будут равны, соответственно \\(1/9\\):\n\n# ФОКАЛЬНЫЕ ОПЕРАЦИИ\n\n# Вырежем кусок из ЦМР\ndem = crop(ice, ext(-120, -75, 10, 40))\nplot(dem)\n\n\n\n\n\n\n\n\n# Среднее\nwgt = matrix(c(1, 1, 1,\n               1, 1, 1,\n               1, 1, 1) / 9, \n              nrow = 3)\n# на самом деле проще написать так:\n# wgt = matrix(1/9, 3, 3), но полная форма записана для наглядности\n\n# выполним обработку ЦМР с помощью фокального фильтра\nfiltered = focal(dem, w = wgt)\n\nggplot() +\n  geom_spatraster(data = c(dem, filtered)) +\n  scale_fill_hypso_tint_c(palette = \"etopo1\") + \n  facet_wrap(~lyr)\n\n\n\n\n\n\n\n\nБолее мягким эффектом сглаживания, который к тому же не нарушает дифференцируемость поверхности, является гауссово сглаживание. Коэффициенты в матрице Гаусса убывают от центральной ячейки к краям матрицы по закону Гаусса-Лапласа, что позволяет придать центральной ячейке более высокий вес по сравнению с ячейками, располагающимися на краю анализируемой окрестности:\n\n# Гауссово (параметр 0.5 - это стандартное отклонение в единицах измерения растра)\nwgt = focalMat(dem, 0.5, \"Gauss\")\nfiltered = focal(dem, wgt)\n\nggplot() +\n  geom_spatraster(data = c(dem, filtered)) +\n  scale_fill_hypso_tint_c(palette = \"etopo1\") + \n  facet_wrap(~lyr)\n\n\n\n\n\n\n\n\nЕще одна интересная область применения фильтрации — это обнаружение границ (change detection). Границы на изображении возникают в тех местах, где его яркость резко меняет свое значение (в одном или нескольких каналах). Например, на фотографии контур лица может быть распознан по перепаду яркости между его изображением и фоном (если он имеет существенно отличный цвет). Поскольку перепад яркости соответствует экстремальным значениям производной поверхности (отрицательным или положительным), его также можно определить путем фокального анализа, а затем отсечь ячейки растра, в которых значение этой производной по модулю превышает заданный порог (то есть, имеет необходимый контраст).\nРассмотрим, как можно выделить уступы континентального склона океана путем применения фильтра Собеля для выделения границ:\n\n# Матрица Собеля:\nwgt = matrix(c(1, 2, 1,\n                0, 0, 0,\n               -1,-2,-1) / 4, \n              nrow=3)\nfiltered = focal(dem, wgt)\n\n# Это поверхность производных:\n\nggplot() +\n  geom_spatraster(data = filtered) +\n  scale_fill_gradient2(low = 'navyblue', high = 'darkred') +\n  ggtitle('Производная поверхности')\n\n\n\n\n\n\n\n\n# Отберем все ячейки, обладающие высокими значениями производных\nfaults = abs(filtered) &gt; 1500\nfaults[faults == 0] = NA\n\nggplot() +\n  geom_spatraster(data = dem) +\n  scale_fill_hypso_tint_c(palette = \"etopo1\") + \n  ggnewscale::new_scale_fill() +\n  geom_spatraster(data = faults) +\n  scale_fill_discrete(type = 'black', na.value = \"transparent\")\n\n\n\n\n\n\n\n\nЕще один распространенный случай использования фокальных операций — это морфометрический анализ поверхностей. Квадратная окрестность \\(3\\times3\\) вокруг каждой ячейки формирует локальную поверхность, производные которой дают представление об уклоне, экспозиции и прочих морфометрических параметрах. Их можно вычислить с помощью функции terrain() из пакета raster:\n\n# Морфометрия рельефа — фиксированное соседство\ndem = rast('data/dem_fergana.tif')\n\nggplot() +\n  geom_spatraster(data = dem) +\n  scale_fill_hypso_c() +\n  labs(title = 'Ферганская долина', fill = 'Высота, [м]')\n\n\n\n\n\n\n\n\n# углы наклона\nslope = terrain(dem, 'slope', unit = 'degrees')\n\nggplot() +\n  geom_spatraster(data = slope) +\n  scale_fill_gradient(low = 'lightcyan', high = 'darkred') +\n  labs(title = 'Углы наклона', fill = 'Градусы [°]')\n\n\n\n\n\n\n\n\n# экспозиция\naspect = terrain(dem, 'aspect', unit = 'degrees')\n\nggplot() +\n  geom_spatraster(data = aspect) +\n  scale_fill_gradientn(colors = rainbow(9), values = 0:8 / 8) +\n  labs(title = 'Экспозиция', fill = 'Градусы [°]')\n\n\n\n\n\n\n\n\nВычисление производных поверхности позволяет не только исследовать рельеф, но также строить его изображения. Например, хорошо знакомую всем по картам аналитическую отмывку рельефа (hillshade). Яркость поверхности в этом способе изображения зависит от угла между направлением на источник освещения (откуда светит Солнце) и нормалью к поверхности. Нормаль можно вычислить как напрямую через производные поверхности, так и восстановить на основе значений угла наклона и экспозиции в точке, что и используется в пакете raster. Обратите внимание на то, что для того чтобы повысить наглядность (контрастность) изображения, мы умножаем высоты рельефа на 20. Это стандартная практика для мелкомасштабных карт:\n\n# отмывка\nslope_rad10 = terrain(dem * 10, 'slope', \n                 unit = 'radians')\n\nslope_rad5 = terrain(dem * 5, 'slope', \n                 unit = 'radians')\n\naspect_tad = terrain(dem, 'aspect', \n                  unit = 'radians')\n                 \n# параметры angle и direction функции hillShade определяют азимут и высоту источника освещения:\n\nhill = shade(slope_rad10, aspect_tad, angle = 45, direction = 315)\n\nhill_vert = shade(slope_rad5, aspect_tad, angle = 90, direction = 315)\n\nhill_comb = hill * hill_vert\n\nggplot() +\n  geom_spatraster(data = hill) +\n  scale_fill_gradient(low = 'black', high = 'white') +\n  ggtitle('Отмывка классическая')\n\n\n\n\n\n\n\n\nggplot() +\n  geom_spatraster(data = hill_vert) +\n  scale_fill_gradient(low = 'black', high = 'white') +\n  ggtitle('Отмывка отвесная')\n\n\n\n\n\n\n\n\nggplot() +\n  geom_spatraster(data = hill_comb) +\n  scale_fill_gradient(low = 'black', high = 'white') +\n  ggtitle('Отмывка комбинированная')\n\n\n\n\n\n\n\n\n\n\n14.3.2.2 Расширенная окрестность\nРасширенность окрестности означает, что она определяется не фиксированным шаблоном, а условием, которое должно выполниться для того, чтобы анализ в ячейке считался выполненным. Типичный пример анализа на основе расширенной окрестности — это операции, основанные на вычислении расстояний на растровой матрице, такие как аллокация, определение кратчайшего пути на поверхности сопротивления, и собственно, само вычисление расстояние.\nВ мелкомасштабных тематических атласах часто можно встретить карты доступности той или иной географической локации, которые в форме изолиний показывают время движения до ближайшего населенного пункта. Эти изолинии можно построить по растровой поверхности, в каждой ячейке которой зафиксировано расстояние до ближайшего населенного пункта.\nРассмотрим построение аналогичной поверхности на примере доступности станций метро (по расстоянию). Для этого нам понадобится представить растр в виде матрицы точек, рассчитать для этих точек расстояния до ближайших станций метро и присвоить эти значения выходному растру:\n\n# Определение Евклидовых расстояний — расширенное соседство\n\n# Чтение данных\nroads = read_sf(\"data/roads.gpkg\") # Дороги\npoi = read_sf(\"data/poi_point.gpkg\") # Точки интереса\nrayons = read_sf(\"data/boundary_polygon.gpkg\") # Границы районов\nstations = read_sf(\"data/metro_stations.gpkg\") # Станции метро\nwater = read_sf(\"data/water_polygon.gpkg\") # Водные объекты\n\ndist_grid = stations |&gt; \n  rast(resolution = 25) |&gt; \n  rasterize(stations, y = _) |&gt; \n  gridDist(NA)\n\n# Визуализируем результат\nggplot() +\n  geom_spatraster_contour_filled(data = dist_grid) +\n  geom_spatraster_contour(data = dist_grid, linewidth = 0.25, color = 'black') +\n  geom_sf(data = water, linewidth = 0.1) +\n  geom_sf(data = roads, linewidth = 0.1) +\n  geom_sf(data = stations, color = 'darkviolet') +\n  labs(title = 'Расстояние до ближайшей станции метро',\n       fill = 'м') +\n  theme_bw()\n\n\n\n\n\n\n\n\n\n\n\n14.3.3 Зональные операции\nЗональные операции связаны с агрегированием растровых данных по площадным зонам. В пределах каждой зоны вычисляется одна или несколько характеристик значений анализируемого растра: среднее, максимум и т.д. Как правило, зоны задаются в виде вспомогательного растрового или векторного набора данных. В случае растра каждая ячейка должна содержать идентификатор (номер) зоны, к которой она относится. Совокупность ячеек, имеющих одинаковый идентификатор, определяет территорию, которую покрывает зона с этим идентификатором. Если зоны представлены векторным набором пространственных объектов, то каждый объект (полигон) также должен иметь собственный идентификатор. Теоретически в одном наборе данных может быть несколько пространственно не связанных объектов, относящихся к одной зоне (например, зона экваториального климата состоит из трех ареалов). В этом случае агрегирование данных будет произведено сразу по трем полигонам. Таким образом, количество получаемых в результате зональной статистики значений определяется количеством зон, но может не совпадать с общим количеством полигонов, которыми эти зоны представлены.\nВ качестве примера рассмотрим вычисление среднеклиматических параметров WorldClim в пределах различных типов земельного покрова (Land Cover), которые доступны в пакете tmap:\n\ntemp = geodata::worldclim_global(var = \"tavg\", res = 10, path = tempdir())\n\ndata(land, package = 'tmap')\nterraland = rast(land['cover'])\n\npal = c(\"#003200\", \"#3C9600\", \"#006E00\", \"#556E19\", \"#00C800\", \"#8CBE8C\",\n           \"#467864\", \"#B4E664\", \"#9BC832\", \"#EBFF64\", \"#F06432\", \"#9132E6\",\n           \"#E664E6\", \"#9B82E6\", \"#B4FEF0\", \"#646464\", \"#C8C8C8\", \"#FF0000\",\n           \"#FFFFFF\", \"#5ADCDC\")\n\nggplot() +\n  geom_spatraster(data = terraland) +\n  scale_fill_manual(values = pal, guide = guide_legend(ncol = 3), name = NULL) + \n  theme(legend.position = 'bottom')\n\n\n\n\n\n\n\n\nПредварительно необходимо убедиться, что оба растра имеют совпадающий охват (экстент) и пространственное разрешение. Обратите внимание на то, что, поскольку растр земельного покрова категориальный, для его передискретизации необходимо использовать метод ближайшего соседа (Nearest Neighbor), который для каждого пиксела нового растра берет значение в ближайшем к нему пикселе исходного растра:\n\ntemp\n## class       : SpatRaster \n## dimensions  : 1080, 2160, 12  (nrow, ncol, nlyr)\n## resolution  : 0.1666667, 0.1666667  (x, y)\n## extent      : -180, 180, -90, 90  (xmin, xmax, ymin, ymax)\n## coord. ref. : lon/lat WGS 84 (EPSG:4326) \n## sources     : wc2.1_10m_tavg_01.tif  \n##               wc2.1_10m_tavg_02.tif  \n##               wc2.1_10m_tavg_03.tif  \n##               ... and 9 more source(s)\n## names       : wc2.1~vg_01, wc2.1~vg_02, wc2.1~vg_03, wc2.1~vg_04, wc2.1~vg_05, wc2.1~vg_06, ... \n## min values  :    -45.8840,   -44.80000,   -57.92575,   -64.19250,   -64.81150,   -64.35825, ... \n## max values  :     34.0095,    32.82425,    32.90950,    34.19375,    36.25325,    38.35550, ...\nterraland\n## class       : SpatRaster \n## dimensions  : 540, 1080, 1  (nrow, ncol, nlyr)\n## resolution  : 0.3333333, 0.3333333  (x, y)\n## extent      : -180, 180, -90, 90  (xmin, xmax, ymin, ymax)\n## coord. ref. : +proj=longlat +ellps=WGS84 +towgs84=0,0,0,0,0,0,0 +no_defs \n## source(s)   : memory\n## categories  : label \n## name        :                      cover \n## min value   : Broadleaf Evergreen Forest \n## max value   :               Water bodies\n\n(cover = project(terraland, temp, method = 'near'))\n## class       : SpatRaster \n## dimensions  : 1080, 2160, 1  (nrow, ncol, nlyr)\n## resolution  : 0.1666667, 0.1666667  (x, y)\n## extent      : -180, 180, -90, 90  (xmin, xmax, ymin, ymax)\n## coord. ref. : lon/lat WGS 84 (EPSG:4326) \n## source(s)   : memory\n## categories  : label \n## name        :                      cover \n## min value   : Broadleaf Evergreen Forest \n## max value   :               Water bodies\n# используем 'near', поскольку растр категориальный\n\nДля вычисления средней температуры за каждый месяц в пределах каждой зоны земельного покрова выполним следующую последовательность действий:\n\nstats = zonal(temp, cover, mean, na.rm = TRUE)\nhead(stats)\n##                         cover wc2.1_10m_tavg_01 wc2.1_10m_tavg_02\n## 1  Broadleaf Evergreen Forest        23.5782137        23.8492299\n## 2  Broadleaf Deciduous Forest         0.5019552         2.0665998\n## 3 Needleleaf Evergreen Forest       -11.7157410        -9.8924234\n## 4 Needleleaf Deciduous Forest       -25.9428218       -22.8029979\n## 5                Mixed Forest       -14.7891522       -12.3889821\n## 6                   Tree Open        -0.7002717         0.8318519\n##   wc2.1_10m_tavg_03 wc2.1_10m_tavg_04 wc2.1_10m_tavg_05 wc2.1_10m_tavg_06\n## 1         24.162432         24.232968         23.998414          23.42082\n## 2          6.017629         11.021756         15.056588          17.97374\n## 3         -4.084735          2.387608          8.726566          14.34026\n## 4        -15.169831         -5.111337          4.186215          11.81849\n## 5         -6.124290          1.950279          8.925499          14.36811\n## 6          4.560077          9.107631         13.256367          16.56003\n##   wc2.1_10m_tavg_07 wc2.1_10m_tavg_08 wc2.1_10m_tavg_09 wc2.1_10m_tavg_10\n## 1          23.12427          23.55343         23.934943         24.119599\n## 2          19.47548          18.93909         16.137864         11.575879\n## 3          17.06335          15.17327         10.227151          3.330671\n## 4          14.99470          12.45082          5.860229         -4.079028\n## 5          16.84991          15.02540          9.722261          2.786417\n## 6          18.08441          17.22145         14.473682          9.889385\n##   wc2.1_10m_tavg_11 wc2.1_10m_tavg_12\n## 1         23.943348        23.6360025\n## 2          5.903911         1.9374914\n## 3         -4.505279        -9.4876591\n## 4        -16.345332       -23.2874576\n## 5         -5.693239       -12.0065982\n## 6          4.082941         0.6377923\n\nzonal_stats = stats |&gt; \n  rename(cover = 1) |&gt; \n  pivot_longer(-cover, \n               names_to = 'month', values_to = 'tavg', \n               names_prefix = 'wc2.1_10m_tavg_', \n               names_transform = as.integer) |&gt; \n  mutate(month = ordered(month, 1:12, month.abb))\nhead(zonal_stats)\n## # A tibble: 6 × 3\n##   cover                      month  tavg\n##   &lt;chr&gt;                      &lt;ord&gt; &lt;dbl&gt;\n## 1 Broadleaf Evergreen Forest Jan    23.6\n## 2 Broadleaf Evergreen Forest Feb    23.8\n## 3 Broadleaf Evergreen Forest Mar    24.2\n## 4 Broadleaf Evergreen Forest Apr    24.2\n## 5 Broadleaf Evergreen Forest May    24.0\n## 6 Broadleaf Evergreen Forest Jun    23.4\n\nВизуализируем полученные результаты:\n\nggplot(zonal_stats) +\n  geom_line(aes(x = month, y = tavg, \n                color = cover, group = cover), size = 1) +\n  scale_color_manual(values = pal)\n\n\n\n\n\n\n\n\nПеред вычислением целесообразно разделить растр землепользования на северное и южное полушарие (т.к. ход температур в них противоположный):\n\ncover_north = crop(cover, ext(-180, 180, 0, 90))\ncover_south = crop(cover, ext(-180, 180, -60, 0))\n\ntemp_north = crop(temp, ext(-180, 180, 0, 90))\ntemp_south = crop(temp, ext(-180, 180, -60, 0))\n\nmtemp_north_tidy = zonal(temp_north, cover_north, mean, na.rm = TRUE) |&gt;  \n  rename(cover = 1) |&gt; \n  pivot_longer(-cover, \n               names_to = 'month', values_to = 'tavg', \n               names_prefix = 'wc2.1_10m_tavg_', \n               names_transform = as.integer) |&gt; \n  mutate(month = ordered(month, 1:12, month.abb),\n         hemisphere = 'north')\n\nmtemp_south_tidy = zonal(temp_south, cover_south, mean, na.rm = TRUE) |&gt;  \n  rename(cover = 1) |&gt; \n  pivot_longer(-cover, \n               names_to = 'month', values_to = 'tavg', \n               names_prefix = 'wc2.1_10m_tavg_', \n               names_transform = as.integer) |&gt; \n  mutate(month = ordered(month, 1:12, month.abb),\n         hemisphere = 'south')\n\nmtemp_tidy2 = bind_rows(mtemp_north_tidy, mtemp_south_tidy)\n\nggplot(mtemp_tidy2) +\n  geom_line(aes(x = month, y = tavg, \n                color = cover, group = cover), \n            size = 1) +\n  scale_color_manual(values = pal) +\n  facet_wrap(~hemisphere, ncol = 1)\n\n\n\n\n\n\n\n\n\n\n14.3.4 Глобальные операции\nГлобальные операции охватывают все ячейки растра. По сути, можно говорить, что это частный случай зональной операции, когда зона одна и покрывает растр целиком. В пакете raster для расчета глобальных статистик можно использовать функцию global(), передав ей название растра и агрегирующей функции:\n\nglobal(temp_north, max, na.rm = T) \nglobal(temp_south, min, na.rm = T)",
    "crumbs": [
      "Пространственный анализ",
      "<span class='chapter-number'>14</span>  <span class='chapter-title'>Растровый анализ</span>"
    ]
  },
  {
    "objectID": "14-RasterAnalysis.html#raster_extract",
    "href": "14-RasterAnalysis.html#raster_extract",
    "title": "14  Растровый анализ",
    "section": "14.4 Извлечение данных",
    "text": "14.4 Извлечение данных\nРастровая модель данных обеспечивает сплошное покрытие территории (с дискретностью, определяемой размером ячейки). В то же время, достаточно часто требуется получить значения растра в заданных местоположениях. Местоположения могут быть как конкретными объектами (например, точками почвенных разрезов), так и абстрактными географическими локациями, для которых известны координаты.\nДля извлечения растровых данных можно воспользоваться функцией extract(). Получать данные можно как по координатам (записанным в фрейм данных), так и используя пространственные объекты класса Spatial. Например, узнаем мощность покровного оледенения в точке в центре Гренландии:\n\npnt = tibble(\n  x = -45, y = 70,\n  z = terra::extract(ice.depth, bind_cols(x,y))[, 2]\n)\n\nggplot() +\n  geom_spatraster(data = bed) +\n  scale_fill_gradient(low = 'black', high = 'white',\n                      guide=\"none\") +\n  new_scale_fill() +\n  geom_spatraster(data = ice.depth) +\n  scale_fill_gradient(low = 'white', high = 'navyblue', \n                      na.value = \"transparent\") +\n  geom_point(aes(x, y), pnt, size = 2, color = 'red') +\n  geom_text(aes(x, y, label = z), pnt, fontface = 'bold',\n            vjust = 'bottom', hjust = 'left',\n            nudge_x = 3, nudge_y = 3) +\n  labs(title = 'Мощность покровного оледенения',\n       fill = '[м]')\n\n\n\n\n\n\n\n\nОдна из наиболее распространенных задач по извлечению растровых данных — это построение профиля вдоль заданной линии. Воспользуемся интерактивным редактором для проведения линии профиля\n\nmp = mapview(temp$tmean6)\nprofile = mapedit::drawFeatures(mp)\n\n\n\n\n\n\n\n\n\n\n\ntemprof = terra::extract(temp, profile, cells = TRUE, xy = TRUE)\n\nДля построения линии профиля далее нам необходимо преобразовать идентификаторы ячеек растра в расстояние от начала профиля:\n\ntempdf = temprof %&gt;%\n  mutate(dist = 0.001 * c(0, dplyr::select(., x, y) |&gt;  \n                             geosphere::distGeo() |&gt; \n                             cumsum() |&gt; \n                             head(-1))) |&gt;  \n  select(-c(x, y, cell, ID)) |&gt; \n  pivot_longer(-dist, \n               names_to = 'month', values_to = 'tavg', \n               names_prefix = 'wc2.1_10m_tavg_', \n               names_transform = as.integer)\n\npts = profile |&gt;   \n  st_cast('POINT') %&gt;%\n  bind_cols(st_coordinates(.)) |&gt;  \n  mutate(label = c('A', 'B'))\n\nggplot() +\n  geom_spatraster(data = temp$wc2.1_10m_tavg_07) +\n  scale_fill_gradient2(low = 'navyblue', \n                       mid = 'khaki', \n                       high = 'orangered') +\n  geom_sf(data = profile) +\n  geom_sf(data = pts) +\n  ggrepel::geom_text_repel(data = pts, aes(X, Y, label = label)) +\n  labs(x = NULL, y = NULL)\n\n\n\n\n\n\n\n\nggplot(tempdf, aes(x = dist, y = tavg)) +\n  geom_line() +\n  geom_smooth(span = 0.1) +\n  annotate('text', x = 0, y = 10, label = 'A') +\n  annotate('text', x = max(tempdf$dist), y = 10, label = 'B') +\n  ggtitle('Профиль среднемесячной температуры июня по линии A—B') +\n  facet_wrap(~month)",
    "crumbs": [
      "Пространственный анализ",
      "<span class='chapter-number'>14</span>  <span class='chapter-title'>Растровый анализ</span>"
    ]
  },
  {
    "objectID": "14-RasterAnalysis.html#temporal_review",
    "href": "14-RasterAnalysis.html#temporal_review",
    "title": "14  Растровый анализ",
    "section": "14.5 Краткий обзор",
    "text": "14.5 Краткий обзор\nДля просмотра презентации щелкните на ней один раз левой кнопкой мыши и листайте, используя кнопки на клавиатуре:\n\n\n\n\n\nПрезентацию можно открыть в отдельном окне или вкладке браузере. Для этого щелкните по ней правой кнопкой мыши и выберите соответствующую команду.",
    "crumbs": [
      "Пространственный анализ",
      "<span class='chapter-number'>14</span>  <span class='chapter-title'>Растровый анализ</span>"
    ]
  },
  {
    "objectID": "14-RasterAnalysis.html#questions_tasks_raster",
    "href": "14-RasterAnalysis.html#questions_tasks_raster",
    "title": "14  Растровый анализ",
    "section": "14.6 Контрольные вопросы и упражнения",
    "text": "14.6 Контрольные вопросы и упражнения\n\n14.6.1 Вопросы\n\nДайте описание локальных, фокальных, зональных и глобальных операций растровой алгебры. Приведите примеры использования данных типов операций.\nКаким требованиям должна отвечать геометрия растров, участвующих в локальных и зональных операциях?\nВ чем заключается отличие фокальных операций с фиксированной и расширенной окрестностью?\nЧем отличается геометрия растра до и после применения фокальной операции?\nКакая функция пакета raster реализует возможности фокальной обработки растров?\nКакой эффект оказывает сглаживающая фильтрация на значения растра?\nКакие виды производных морфометрических величин позволяет получать функция terrain() из пакета raster?\nКакие два растра необходимо рассчитать для построения аналитической отмывки средствами функции terrain()?\nОпишите последовательность действий, которую необходимо выполнить для построения растра Евклидовых расстояний от заданных объектов?\nКакой метод интерполяции необходимо использовать для передискретизации категориальных растров? В чем заключается принцип его действия?\nКакая функция пакета raster используется для выполнения зональных операций? Какой тип результата она возвращает?\nОпишите возможности функции extract() по извлечению информации из растровых данных. В какой формате можно задать анализируемые локации? Что будет результатом вызова этой функции в зависимости от формата входных данных?\nОпишите последовательность действий, которую необходимо выполнить для построения профиля растровой поверхности средствами R.\nМожно ли построить профиль по растру, имеющему привязку в географической системе координат (координаты выражены градусах)? Если да, то как добиться того, чтобы расстояния между точками профиля были посчитаны в метрических единицах?\nОпишите способ, с помощью которого можно осуществить фильтрацию растра (превратить его в растр TRUE/FALSE) и маскирование растра (заменить ненужные ячейки на NA).\n\n\n\n14.6.2 Упражнения\n\nИндекс континентальности Хромова рассчитывается по формуле \\(K = (A - 5.4 \\sin \\phi)/A\\), где \\(A\\) — годовая амплитуда хода температуры, \\(\\phi\\) — широта точки. Используя данные NOAA по среднемесячным температурам за 1981-2010 гг (air.mon.v501.ltm.1981-2010.nc) в формате NetCDF, рассчитайте растр индекса континентальности на территорию суши и нанесите его на карту средствами tmap.\n\nПодсказка: используйте функцию xyFromCell(), чтобы получить широты всех ячеек растра температур. Далее создайте новый растр и запишите в него широты в качестве значений. Растры минимальных и максимальных значений из стека растров можно получить, используя обычные статистические функции min() и max().\n\nПостройте растр, который содержит расстояние до береговой линии. Используйте данные Natural Earth. Задайте грубое разрешение растра, чтобы расчеты не производились долго (100 x 50 ячеек будет достаточно). Где находится самая удаленная от берега точка на суше? А самая удаленная точка на океане? Постройте карту, которая отображает полученный растр и береговую линию.\nРассчитайте морфометрические коэффициенты TPI, TRI и roughness для цифровой модели рельефа Ферганской долины, которая использовалась в текущей лекции. В чем их суть? Изучите справку к инструменту terrain().\nВ пакете tmap содержится растровый каталог land, включающий в себя растр elevation. Используя пакет mapedit, оцифруйте произвольную линию и постройте средствами ggplot профиль рельефа вдоль этой линии.\n\n\n\n\nСамсонов Т.Е. Визуализация и анализ географических данных на языке R. М.: Географический факультет МГУ, 2023. DOI: 10.5281/zenodo.901911\n\n\n\n\n\n\n\nTomlin, Dana. 2012. GIS and Cartographic Modeling. 2nd Editio. ESRI Press.",
    "crumbs": [
      "Пространственный анализ",
      "<span class='chapter-number'>14</span>  <span class='chapter-title'>Растровый анализ</span>"
    ]
  },
  {
    "objectID": "15-Interpolation.html#interpolation_intro",
    "href": "15-Interpolation.html#interpolation_intro",
    "title": "15  Интерполяция геополей",
    "section": "15.1 Введение",
    "text": "15.1 Введение\nИнтерполяция в общем случае — это способ нахождения промежуточных значений величины по имеющемуся дискретному набору известных значений. В географии обычно имеют дело с двумерным случаем интерполяции — когда измерения проведены в некоторых географических локациях, и по ним нужно восстановить непрерывную картину поля распределения величины. В общем случае неизвестно, как ведет себя исследуемое явление между точками, поэтому существует бесчисленное множество вариантов интерполяции.\nМетоды которые производят интерполяцию на основе заданной аналитической зависимости, называют детерминистическими. Параметры этой зависимости могут быть как априори заданы пользователем, так и определяться автоматически одним из методов оптимизации — в частности, по методу наименьших квадратов.\nНапример, мы можем сказать, что между соседними точками показатель меняется линейным образом (здесь нужно еще указать, что мы понимаем под соседством). Такие методы достаточно просты в использовании и интерпретации. В то же время, они не учитывают статистических особенностей поведения величины между точками, которое определяется ее автокорреляционными свойствами. Методы интерполяции, которые учитывают пространственную автокорреляцию, называют геостатистическими. Они более сложны в использовании, но потенциально могут дать более достоверные результаты.\nВ этом модуле мы познакомимся со следующими детерминистическими методами интерполяции.\n\nМетод ближайшего соседа (nearest neighbor)\nМетод естественного соседа (nearest neighbor)\nМетод интерполяции на основе триангуляции\nМетод обратно взвешенных расстояний (ОВР)\nМетод радиальных базисных функций (РБФ)\nМетод иерархических базисных сплайнов (ИБС)\n\nИнтерполяцию будем рассматривать на примере данных по количеству осадков на метеостанциях в северной Италии (долина реки По и окружающие горы). Станции распределены в пространстве нерегулярно, что позволит визуально оценить чувствительность методов к этому фактору.\nПрежде чем исследовать распределение показателя, необходимо проанализировать географический контекст. В этой части модуля мы воспользуемся уже известными функциями чтобы создать карту с общегеографической основой и нанести на нее пункты метеонаблюдений.\n\nlibrary(sf)\nlibrary(stars)\nlibrary(tmap)\nlibrary(raster)\nlibrary(plotly)\nlibrary(mapview)\nlibrary(tidyverse)\nlibrary(ggrepel)\nlibrary(dismo) # библиотека species distribution modelling\nlibrary(akima) # библиотека для интерполяции на основе триангуляции\nlibrary(gstat) # библиотека для геостатистической интерполяции, построения трендов и IDW\nlibrary(deldir) # библиотека для построения триангуляции Делоне и диаграммы Вороного\nlibrary(fields) # радиальные базисные функции (сплайны минимальной кривизны)\nlibrary(MBA) # иерархические базисные сплайны\n\n# Убираем экспоненциальное представление больших чисел\noptions(scipen=999)\n\ndb = \"data/italy.gpkg\"\n# Читаем слои картографической основы\ncities = st_read(db, 'cities') %&gt;% # Города\n  bind_cols(st_coordinates(.) |&gt; as_tibble())\n## Reading layer `cities' from data source \n##   `/Users/tsamsonov/GitHub/r-geo-course/data/italy.gpkg' using driver `GPKG'\n## Simple feature collection with 8 features and 37 fields\n## Geometry type: POINT\n## Dimension:     XY\n## Bounding box:  xmin: 368910.4 ymin: 4930119 xmax: 686026 ymax: 5115936\n## Projected CRS: WGS 84 / UTM zone 32N\nrivers = st_read(db, 'rivers') # Реки\n## Reading layer `rivers' from data source \n##   `/Users/tsamsonov/GitHub/r-geo-course/data/italy.gpkg' using driver `GPKG'\n## Simple feature collection with 23 features and 10 fields\n## Geometry type: MULTILINESTRING\n## Dimension:     XY\n## Bounding box:  xmin: 332178.5 ymin: 4922880 xmax: 758033.3 ymax: 5121416\n## Projected CRS: WGS 84 / UTM zone 32N\nlakes = st_read(db, 'lakes')   # Озера\n## Reading layer `lakes' from data source \n##   `/Users/tsamsonov/GitHub/r-geo-course/data/italy.gpkg' using driver `GPKG'\n## Simple feature collection with 6 features and 13 fields\n## Geometry type: POLYGON\n## Dimension:     XY\n## Bounding box:  xmin: 460686.2 ymin: 4938750 xmax: 757443.7 ymax: 5113557\n## Projected CRS: WGS 84 / UTM zone 32N\n\n# Читаем ЦМР — цифровую модель рельефа на регулярной сетке\ndem = read_stars(\"data/gtopo.tif\")\n\n# Читаем данные об осадках\npts = read_table2(\"data/Rainfall.dat\") %&gt;% \n  st_as_sf(coords = c('x', 'y'), \n           crs = st_crs(cities),\n           remove = FALSE)\n\n# Координаты пригодятся нам в дальнейшем\ncoords = st_coordinates(pts)\n\nПостроение карты\n\n# Цветовая шкала для рельефа\ndem_colors = colorRampPalette(c(\"darkolivegreen4\", \"lightyellow\", \"orange\", \"firebrick\"))\n\n# Шкала высот для рельефа\ndem_levels = c(0, 50, 100, 200, 500, 1000, 1500, \n               2000, 2500, 3000, 3500, 4000, 5000)\n\ndem_ncolors = length(dem_levels) - 1\n\ndem_contours = st_contour(dem, breaks = dem_levels, contour_lines = TRUE)\n\nold = theme_set(theme_bw())\n\n# Смотрим как выглядит результат\nggplot() +\n  geom_stars(data = cut(dem, breaks = dem_levels)) +\n  coord_sf(crs = st_crs(dem)) +\n  scale_fill_manual(name = 'м',\n                    values = dem_colors(dem_ncolors),\n                    labels = dem_levels,\n                    na.translate = FALSE,\n                    guide = guide_legend(label.vjust = -0.3, reverse = TRUE)) +\n  geom_sf(data = dem_contours, color = 'black', size = 0.2) +\n  geom_sf(data = rivers, color = 'midnightblue', size = 0.2) +\n  geom_sf(data = lakes, color = 'midnightblue', fill = 'lightblue', size = 0.2) +\n  geom_sf(data = pts, color = 'black', size = 0.5) +\n  geom_sf(data = cities, shape = 21, fill = 'white') + \n  geom_text_repel(data = cities, mapping = aes(x = X, y = Y, label = name), box.padding = 0.2)",
    "crumbs": [
      "Пространственный анализ",
      "<span class='chapter-number'>15</span>  <span class='chapter-title'>Интерполяция геополей</span>"
    ]
  },
  {
    "objectID": "15-Interpolation.html#interpolation_grid",
    "href": "15-Interpolation.html#interpolation_grid",
    "title": "15  Интерполяция геополей",
    "section": "15.2 Построение сетки",
    "text": "15.2 Построение сетки\nЛюбопытным свойством пакетов R, отвечающих за интерполяцию данных, является их индифферентность относительно того, в каких точках эта интерполяция будет производиться. Это может быть как регулярная растровая сетка, так и множество точек в совершенно произвольных конфигурациях. Подобная гибкость делает процесс интерполяции данных чуть более сложным, чем в ГИС-пакетах, однако способствует полному и глубокому пониманию происходящего. Вы своими руками задаете пункты, в которых следует интерполировать значения.\nДля построения сетки воспользуемся функцией st_as_stars() из пакета stars, передав ей ограничивающий прямоугольник исходного множества точек и разрешение сетки:\n\n# ПОСТРОЕНИЕ СЕТКИ ДЛЯ ИНТЕРПОЛЯЦИИ\n# получим ограничивающий прямоугольник вокруг точек:\nbox = st_bbox(pts)\nenvelope = box[c(1,3,2,4)]\n\npx_grid = st_as_stars(box, dx = 10000, dy = 10000)\n\nggplot() + \n  geom_sf(data = pts, color = 'red') +\n  geom_sf(data = st_as_sf(px_grid), size = 0.5, fill = NA)\n\n\n\n\n\n\n\n\nПолучившееся представление можно назвать сеточной моделью. В пределах каждой ячейки величина будет считаться постоянной. Ее значение будет интерполировано в центре пиксела. Можно видеть, что интерполяционная сетка слегка выходит за пределы исходного охвата множества точек. Это связано с тем, что размеры прямоугольника, ограничивающего множество точек, не кратны выбранному разрешению растра (\\(10 000\\) м). Проблема, однако, не столько критична, если вы выбираете достаточно подробное (малое) разрешение растра, что мы и сделаем. Зададим его равным \\(1 000\\) м:\n\n# создадим детальную растровую сетку\npx_grid = st_as_stars(box, dx = 1000, dy = 1000)\n\n# извлечем координаты точек в соответствующие столбцы, они нам пригодятся:\ncoords_grid = st_coordinates(px_grid)",
    "crumbs": [
      "Пространственный анализ",
      "<span class='chapter-number'>15</span>  <span class='chapter-title'>Интерполяция геополей</span>"
    ]
  },
  {
    "objectID": "15-Interpolation.html#interpolation_methods",
    "href": "15-Interpolation.html#interpolation_methods",
    "title": "15  Интерполяция геополей",
    "section": "15.3 Интерполяционные методы",
    "text": "15.3 Интерполяционные методы\n\n# Цветовая шкала для осадков\nrain_colors = colorRampPalette(c(\"white\", \"dodgerblue\", \"dodgerblue4\"))\n\n# Шкала количества осадков и соответствющее число цветов\nrain_levels = seq(0, 80, by=10)\nrain_ncolors = length(rain_levels)-1\n\nrain_legend = scale_fill_manual(name = 'мм',\n                                values = rain_colors(rain_ncolors),\n                                guide = guide_legend(label.vjust = -0.3, reverse = TRUE, title.position = \"bottom\"),\n                                labels = rain_levels,\n                                na.value = 'white',\n                                drop = FALSE)\nrain_mapping = aes(fill = cut(rain_24, breaks = rain_levels))\n\n\n15.3.1 Метод ближайшего соседа (nearest neighbour)\nДанный метод является простейшим по сути подходом к интерполяции. В его основе лежит построение диаграммы Вороного исходного множества точек. Считается, что в пределах каждой ячейки диаграммы значение показателя постоянно и равно значению в центре ячейки. Далее поверх диаграммы накладывается сетка интерполируемых точек и снимаются соответствующие значения:\n\n# МЕТОД БЛИЖАЙШЕГО СОСЕДА (NEAREST NEIGHBOR)\n\n# Диаграмма Вороного\nvoronoi_sf = voronoi(coords, envelope) |&gt; \n  st_as_sf() |&gt; \n  st_set_crs(st_crs(pts)) |&gt; \n  st_join(pts)\n\n# Триангуляция Делоне\nedges = pts |&gt; \n  st_union() |&gt; \n  st_triangulate()\n\n# Визуализация\nggplot() +\n  geom_sf(data = voronoi_sf,\n          mapping = rain_mapping,\n          size = 0.2) +\n  rain_legend +\n  geom_sf(data = pts, color = 'red', size = 0.5) +\n  geom_sf(data = edges, color = 'red', size = 0.1, fill = NA)\n\n\n\n\n\n\n\n\nЕсли есть задача конвертировать это в растр, то надо сформировать новый растр и “перенести” на него информацию с полигонов:\n\n# Создаем растр\nrnn = st_rasterize(voronoi_sf[\"rain_24\"], px_grid)\n\n# Визуализируем:\nggplot() +\n  geom_stars(data = cut(rnn, breaks = rain_levels)) +\n  rain_legend +\n  coord_sf(crs = st_crs(pts))\n\n\n\n\n\n\n\n\nВидно, что полученная поверхность уже пиксельная. Для наглядности визуализируем ее в трехмерном виде. Для этого используем замечательный пакет plotly, предоставляющий интерфейс к одноименной библиотеке. Функция plot_ly(), отвечающая за построение графиков в этом пакете, требует для визуализации поверхности предоставить три компоненты:\n\nx - вектор координат ячеек по оси \\(Х\\)\ny - вектор координат ячеек по оси \\(Y\\)\nz - матрицу значений, имеющую размеры \\(length(x) \\times length(y)\\)\n\nПоверхность будет раскрашиваться в различные цвета в зависимости от значений z, для управления цветами можно определить параметр colors, который должен иметь тип colorRamp:\n\nrain_colors3d = colorRamp(c(\"white\", \"dodgerblue\", \"dodgerblue4\"))\n\nx = coords_grid[,'x'] %&gt;% unique() # Получим координаты столбцов\ny = coords_grid[,'y'] %&gt;% unique() # Получим координаты строк\n\np = plot_ly(x = x, \n            y = y, \n            z = rnn$rain_24, \n            type = \"surface\",\n            colors = rain_colors3d)\nlayout(p, scene = list(aspectratio = list(x = 1, y = 1, z = 0.3)\n))\n\n\n\n\n\nПонятное дело, что такая ступенчатая форма поверхности вряд ли соответствует реальному распределению показателя, который меняется в пространстве непрерывным образом. Можно сказать, что это первое приближение пространственного распределения.\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n15.3.2 Интерполяция на основе триангуляции\nИнтерполяция на основе триангуляции — метод интерполяции, результатом которого является уже не ступенчатая поверхность, а аппроксимированная треугольными гранями — наподобие того как объекты представлены в системах трехмерного моделирования и компьютерных играх. Триангуляция представляет собой поверхность, склеенную из треугольников, соединяющих исходные точки. Каждый треугольник является участком наклонной плоскости.\n\nГраницей триангуляции является выпуклая оболочка множества точек\n\nДля выполнения интерполяции в произвольно заданной точке \\((x, y)\\) необходимо найти уравнение плоскости того треугольника который включает данную точку. В общем виде уравнение плоскости содержит четыре неизвестных коэффициента: \\[\nAx + By + Cz + D = 0,\n\\] Имея три точки \\(p_1\\), \\(p_2\\) и \\(p_3\\), искомые коэффициенты можно получить путем решения уравнения, левая часть которого задана в форме определителя: \\[\n\\begin{vmatrix}\nx - x_1 & y - y_1 & z - z_1 \\\\\nx_2 - x_1 & y_2 - y_1 & z_2 - z_1 \\\\\nx_3 - x_1 & y_3 - y_1 & z_3 - z_1\n\\end{vmatrix} = 0\n\\] Коэффициенты \\(A\\), \\(B\\), \\(C\\) и \\(D\\) вычисляются заранее для каждого треугольника и хранятся вместе с триангуляцией. Получив коэффициенты нужного треугольника, искомую величину \\(z(x, y)\\) можно найти, выразив ее из вышеприведенного уравнения плоскости: \\[\nz(x, y) = -\\frac{1}{C}(Ax+By+D)\n\\]\nРассмотрим применение данного метода на практике.\n\n\n# ИНТЕРПОЛЯЦИЯ НА ОСНОВЕ ТРИАНГУЛЯЦИИ (TRIANGULATION)\n\n# Интерполируем. Параметр linear говорит о том, что показатель будет меняться вдоль ребер триангуляции линейно:\npx_grid = px_grid |&gt; \n  mutate(z_linear = interpp(x = coords[,1],\n                            y = coords[,2],\n                            z = pts$rain_24, \n                            xo = coords_grid[,1],\n                            yo = coords_grid[,2],\n                            linear = TRUE)$z)\n\ncont_linear = st_contour(px_grid['z_linear'], breaks = rain_levels, contour_lines = TRUE)\n# Смотрим как выглядит результат\n\nggplot() +\n  geom_stars(data = cut(px_grid['z_linear'], breaks = rain_levels)) +\n  rain_legend +\n  coord_sf(crs = st_crs(pts)) +\n  geom_sf(data = cont_linear, color = 'black', size = 0.2) +\n  geom_sf(data = pts, color = 'red', size = 0.5) +\n  geom_sf(data = edges, color = 'red', size = 0.1, fill = NA)\n\n\n\n\n\n\n\n\nОбратите внимание, что все изломы (повороты) изолиний происходят на ребрах триангуляции, а внутри треугольников изолинии проходят параллельно друг другу. Каждый треугольник представляет собой фрагмент наклонной плоскости. Такой метод интерполяции, по сути, является самым простым и “честным” подходом, который близок к тому как горизонтали интерполируются вручную.\nРассмотрим поверхность в 3D:\n\np = plot_ly(x = x, \n            y = y, \n            z = px_grid$z_linear, \n            type = \"surface\",\n            colors = rain_colors3d)\nlayout(p, scene = list(aspectratio = list(x = 1, y = 1, z = 0.3)\n))\n\n\n\n\n\nЛинейная интерполяция на треугольниках, как можно видеть, выглядит достаточно угловато, хотя и существенно более правдоподобна, нежели ступенчатая поверхность, полученная методом ближайшего соседа.\nБолее гладкий результат можно получить, используя не линейный, а бикубический метод интерполяции на треугольниках, известный так же как метод Акимы (1978). Для того чтобы использовать его, необходимо в функции interpp указать параметр linear = FALSE. Помимо этого, параметр extrap = TRUE говорит о том, что можно производить экстраполяцию за пределами выпуклой оболочки точек (такая возможность недоступна в линейном случае):\n\n\npx_grid = px_grid |&gt; \n  mutate(z_spline = interpp(x = coords[,1],\n                            y = coords[,2],\n                            z = pts$rain_24, \n                            xo = coords_grid[,1],\n                            yo = coords_grid[,2],\n                            linear = FALSE,\n                            extrap = TRUE)$z)\n\ncont_spline = st_contour(px_grid['z_spline'], \n                         breaks = rain_levels, \n                         contour_lines = TRUE)\n\n# Смотрим как выглядит результат\nggplot() +\n  geom_stars(data = cut(px_grid['z_spline'], breaks = rain_levels)) +\n  rain_legend +\n  coord_sf(crs = st_crs(pts)) +\n  geom_sf(data = cont_spline, color = 'black', size = 0.2) +\n  geom_sf(data = pts, color = 'red', size = 0.5) +\n  geom_sf(data = edges, color = 'red', size = 0.1, fill = NA)\n\n\n\n\n\n\n\n\nПолученные изолинии отличаются более плавным и естественным рисунком. Тем не менее, использование триангуляции все еще заметно по фестончатым изгибам изолиний на ребрах.\nСмотрим наглядное представление поверхности в 3D:\n\np = plot_ly(x = x, \n            y = y, \n            z = px_grid$z_spline, \n            type = \"surface\",\n            colors = rain_colors3d)\nlayout(p, scene = list(aspectratio = list(x = 1, y = 1, z = 0.3)\n))\n\n\n\n\n\nМожно видеть, что в данном случае получена уже гладкая поверхность, плотно натянутая на ребра триангуляции.\n\n\n15.3.3 Метод обратно взвешенных расстояний (IDW)\nВ методе обратно взвешенных расстояний значение показателя в произвольной точке получается как средневзвешенная сумма значений в исходных точках. Веса определяются обратно пропорционально расстоянию: чем дальше исходная точка удалена, тем меньший вес она будет иметь в оценке. Формально значение функции в точке определяет согласно следующей формуле: \\[\nz(\\mathbf{p}) = \\begin{cases}\n\\dfrac{\\sum_{i = 1}^{N}{ w_i(\\mathbf{p}) z_i } }{ \\sum_{i = 1}^{N}{ w_i(\\mathbf{p}) } }, & \\text{если } d(\\mathbf{p},\\mathbf{p}_i) \\neq 0 \\text{ для всех } i, \\\\\nz_i, & \\text{если } d(\\mathbf{p},\\mathbf{p}_i) = 0 \\text{ хотя бы для одного } i,\n\\end{cases}\n\\] где \\(w_i(\\mathbf{p}) = | \\mathbf p - \\mathbf p_i | ^{-\\rho}\\) — весовая функция.\nМетод Шепарда — одна из наиболее распространенных модиификаций метода IDW. Веса вычисляются по формуле:\n\\[w_i(\\mathbf{p}) = d^{-2}_i / \\sum_{j=1}^n d^{-2}_j\\]\nМетод реализуется в R с помощью функции idw() из пакета gstat. Основным параметром метода является степень idp =, которая указывает, насколько быстро в зависимости от расстояния будет убывать вес исходной точки. По умолчанию idp = 2. При больших значениях степени (3, 4, 5, …) поверхность становится более платообразной, при меньших — островершинной.\nФункция idw() принимает 4 параметра:\n\nФормула, указывающая название зависимой переменной и независимых переменных.\nИсходные точки.\nРезультирующие точки.\nСтепень весовой функции idp.\n\nФормулы полезны в тех случаях, когда известно (или делается предположение), что исследуемый показатель функционально связан с другой величиной. В этом случае запись Z ~ x означает, что сначала будет построена линейная регрессия \\(Z(x)\\) и на основе нее получена грубая оценка показателя в каждой результирующей точке. Интерполяции же будут подвергаться случайные остатки между исходными величинами в точках и теми, что получены по регрессии. Эти остатки добавляются в результирующих точках к оценке, полученной по регрессии.\nПока что мы воспользуемся стандартной записью вида Z ~ 1, которая означает, что интерполироваться будет непосредственно исходная величина. В качестве Z надо указать название столбца, содержащего значения показателя. Этот столбец должен находиться в слое с исходными точками, который передается в параметр locations =. Сетка новых точек передается в параметр newdata.\nРассмотрим, как меняется вид поверхности при разных значениях idp.\n\n\n# МЕТОД ОБРАТНО ВЗЕШЕННЫХ РАССТОЯНИЙ (IDW --- INVERSE DISTANCE WEIGHTED)\n\n# Интерполируем количество осадков:\npx_grid = px_grid |&gt; \n  mutate(z_idw2 = gstat::idw(rain_24 ~ 1, locations = pts, newdata = px_grid, idp = 2.0) |&gt; pull(var1.pred) |&gt; as('vector'),\n         z_idw3 = gstat::idw(rain_24 ~ 1, locations = pts, newdata = px_grid, idp = 3.0) |&gt; pull(var1.pred) |&gt; as('vector'),\n         z_idw4 = gstat::idw(rain_24 ~ 1, locations = pts, newdata = px_grid, idp = 4.0) |&gt; pull(var1.pred) |&gt; as('vector'),\n         z_idw5 = gstat::idw(rain_24 ~ 1, locations = pts, newdata = px_grid, idp = 5.0) |&gt; pull(var1.pred) |&gt; as('vector'))\n\ncont_idw2 = st_contour(px_grid['z_idw2'], \n                       breaks = rain_levels, \n                       contour_lines = TRUE)\n\ncont_idw3 = st_contour(px_grid['z_idw3'], \n                       breaks = rain_levels, \n                       contour_lines = TRUE)\n\ncont_idw4 = st_contour(px_grid['z_idw4'], \n                       breaks = rain_levels, \n                       contour_lines = TRUE)\n\ncont_idw5 = st_contour(px_grid['z_idw5'], \n                       breaks = rain_levels, \n                       contour_lines = TRUE)\n\nggplot() +\n  geom_stars(data = cut(px_grid['z_idw2'], breaks = rain_levels)) +\n  rain_legend +\n  coord_sf(crs = st_crs(pts)) +\n  geom_sf(data = cont_idw2, color = 'black', size = 0.2) +\n  geom_sf(data = pts, color = 'red', size = 0.5)\n\n\n\n\n\n\n\n\nggplot() +\n  geom_stars(data = cut(px_grid['z_idw3'], breaks = rain_levels)) +\n  rain_legend +\n  coord_sf(crs = st_crs(pts)) +\n  geom_sf(data = cont_idw3, color = 'black', size = 0.2) +\n  geom_sf(data = pts, color = 'red', size = 0.5)\n\n\n\n\n\n\n\n\nggplot() +\n  geom_stars(data = cut(px_grid['z_idw4'], breaks = rain_levels)) +\n  rain_legend +\n  coord_sf(crs = st_crs(pts)) +\n  geom_sf(data = cont_idw4, color = 'black', size = 0.2) +\n  geom_sf(data = pts, color = 'red', size = 0.5)\n\n\n\n\n\n\n\n\nggplot() +\n  geom_stars(data = cut(px_grid['z_idw5'], breaks = rain_levels)) +\n  rain_legend +\n  coord_sf(crs = st_crs(pts)) +\n  geom_sf(data = cont_idw5, color = 'black', size = 0.2) +\n  geom_sf(data = pts, color = 'red', size = 0.5)\n\n\n\n\n\n\n\n\nПоскольку производная функции ОВР в каждой точке исходных данных равняется нулю (это следует из определения функции), данный метод формирует хорошо заметные замкнутые изолинии, оконтуривающие точки исходных данных. Данный эффект носит название эффекта “бычьих глаз” и относится наиболее критикуемым недостаткам метода ОВР. При увеличении степени весовой функции, однако, происходит размывание данного эффекта, выраженные в изолиниях вершины и впадины приобретают платообразный характер.\nНаглядное представление о характере поверхности, получаемой методом ОВР, дает трехмерная визуализация:\n\np = plot_ly(x = x, \n             y = y, \n             z = px_grid$z_idw3, \n             type = \"surface\",\n             colors = rain_colors3d)\nlayout(p, scene = list(aspectratio = \n                         list(x = 1, y = 1, z = 0.3)\n))\n\n\n\n\n\nЛюбопытным фактом является то, что при стремлении параметра idp к плюс-бесконечности получаемая поверхность становится все более похожей не результат интерполяции методом ближайшего соседа. А именно этот метод, как мы помним, дает ступенчатую платообразную поверхность. Данный эффект легко проверить на практике, задав достаточно большой параметр idp, например \\(30\\):\n\npx_grid = px_grid |&gt; \n  mutate(z_idw30 = \n    gstat::idw(\n      rain_24 ~ 1, \n      locations = pts, \n      newdata = px_grid,\n      idp = 30.0\n    ) |&gt; pull(var1.pred) |&gt; as('vector')\n  )\n## [inverse distance weighted interpolation]\n\ncont_idw30 = st_contour(px_grid['z_idw30'], \n                       breaks = rain_levels, \n                       contour_lines = TRUE)\n\nggplot() +\n  geom_stars(data = cut(px_grid['z_idw30'], breaks = rain_levels)) +\n  rain_legend +\n  coord_sf(crs = st_crs(pts)) +\n  geom_sf(data = cont_idw30, color = 'black', size = 0.2) +\n  geom_sf(data = pts, color = 'red', size = 0.5) +\n  geom_sf(data = voronoi_sf, color = 'violet', fill = NA, size = 0.2)\n\n\n\n\n\n\n\n\nРассмотрим полученную поверхность в 3D:\n\np = plot_ly(x = x, \n             y = y, \n             z = px_grid$z_idw30, \n             type = \"surface\",\n             colors = rain_colors3d)\nlayout(p, scene = list(aspectratio = list(x = 1, y = 1, z = 0.3)\n))\n\n\n\n\n\n\n\n15.3.4 Метод радиальных базисных функций (РБФ)\nВ методе радиальных базисных функций значение в точке \\(p\\) находится путем взвешенного осреднения радиальных функций \\(\\phi\\):\n\\[Z(\\textbf{p}) = \\sum_{i=1}^n \\lambda_i \\phi\\big(\\lVert \\textbf{p} - \\textbf{p}_i\\rVert\\big)\\] где коэффициенты \\(\\lambda_i\\) находятся заранее перед интерполяцией исходя из \\(n\\) условий вида \\(Z(\\textbf{p}_i) = z_i\\).\nК числу широко используемых радиальных функций относятся:\n\nМультиквадрики: \\(\\phi(r) = \\sqrt{r^2 + \\delta^2}\\)\nОбратные мультиквадрики: \\(\\phi(r) = 1 / \\sqrt{r^2 + \\delta^2}\\)\nМульти-логарифмическая: \\(\\phi(r) = \\ln(r^2 + \\delta^2)\\)\nСплайны минимальной кривизны: \\(\\phi(r) = r^2 \\ln(r^2)\\)\n\nМетод РБФ является одним из самых гибких благодаря широким возможностям выбора радиальной функции. Недостатком же его является то, что поверхность может выходить за пределы исходного диапазона значений (хотя и обязательно проходит через исходные точки).\nОсобого внимания среди радиальных функций заслуживают сплайны - функции, выполняющие некоторое дополнительное условие (условия) при одновременном выполнении условий интерполяции (прохождение через исходные точки). В частности, приведенный выше сплайн минимальной кривизны (thin plate spline — TPS) дает поверхность, обладающую максимально низкой кривизной между исходными точками. В такой поверхности будут отсутствовать резкие скачки и понижения, что мы видели на поверхности, построенной методом ОВР.\nНа языке R сплайны минимальной кривизны реализованы в пакете fields. Сначала необходимо инициализировать процесс интерполяции с помощью функции Tps(), передав ей координаты исходных точек и значения показателя в них. Дополнительно при необходимости указывается параметр scale.type = 'unscaled', который означает, что не следует масштабировать координаты исходных точек так чтобы область определения стала квадратной:\n\n\n# РАДИАЛЬНЫЕ БАЗИСНЫЕ ФУНКЦИИ (RADIAL BASIS FUNCTIONS)\npred = Tps(coords, pts$rain_24, scale.type = 'unscaled')\n\n# После этого можно интерполировать значения с помощью функции predict():\npx_grid = px_grid |&gt; \n  mutate(z_tps = predict(pred, coords_grid))\n\n# Придется расширить шкалу, так как сплайновая поверхность выходит за пределы исходных значений:\ntps_breaks = seq(-10,90,by=10)\ntps_ncolors = length(tps_breaks) - 1\n\ncont_tps = st_contour(px_grid['z_tps'], \n                       breaks = tps_breaks, \n                       contour_lines = TRUE)\n\n# Виузализируем результат:\n\nggplot() +\n  geom_stars(data = cut(px_grid['z_tps'], breaks = tps_breaks)) +\n  scale_fill_manual(name = 'мм',\n                    values = rain_colors(tps_ncolors),\n                    labels = paste(tps_breaks[-tps_ncolors-1], '-', tps_breaks[-1])) +\n  coord_sf(crs = st_crs(pts)) +\n  geom_sf(data = cont_tps, color = 'black', size = 0.2) +\n  geom_sf(data = pts, color = 'red', size = 0.5)\n\n\n\n\n\n\n\n\nМожно видеть, что по плавному характеру изолиний и отсутствию артефактов в виде “бычьих глаз” интерполяция методом РБФ существенно ближе к ожидаемому распределению показателя, а также удачно сглаживает неравномерность распределения исходных данных.\nСмотрим, как выглядит поверхность в 3D:\n\np = plot_ly(x = x, \n             y = y, \n             z = px_grid$z_tps, \n             type = \"surface\",\n             colors = rain_colors3d)\nlayout(p, scene = list(aspectratio = \n                         list(x = 1, y = 1, z = 0.3)\n))\n\n\n\n\n\n\n\n15.3.5 Метод иерархических базисных сплайнов (B-сплайнов)\nВ методе иерархических базисных сплайнов интерполяция прооизводится итеративно на нескольких уровнях детализации сетки: от более грубых к детальным. Пусть сетка \\(\\Phi\\) состоит из узлов \\(\\phi_{ij}\\). Тогда функция аппроксимации в узле \\(\\phi_{ij}\\) определяется следующим образом:\n\\[f(x, y) = \\sum_{k=0}^3 \\sum_{l=0}^3 B_k(s)B_l(t) \\phi_{i+k, j+l},\\] где \\(i = \\lfloor x \\rfloor -1\\), \\(j = \\lfloor y \\rfloor -1\\), \\(s = x - \\lfloor x \\rfloor\\) и \\(t = y - \\lfloor y \\rfloor\\).\nФункции \\(B_k\\) и \\(B_l\\) представляют собой кубические базисные функции в форме B-сплайнов, определяемые как:\n\\[B_0(t) = (1-t)^3/6,\\\\\nB_1(t) = (3t^3 - 6t^2 + 4)/6,\\\\\nB_2(t) = (-3t^3 + 3t^2 + 3t + 1)/6,\\\\\nB_3(t) = t^3/6,\\]\nгде \\(0 \\leq t &lt; 1\\). Данные функции служат в качестве весовых коэффициентов соответствующих узлов при определении значения в точке \\((x, y)\\).\nИнтерполируемые значения \\(\\phi_{ij}\\) находятся исходя из условия минимального отклонения функции \\(f(x, y)\\) от значений точек исходных данных. В методе иерархических базисных сплайнов используется иерархия сеток \\(\\Phi_0, \\Phi_1, ..., \\Phi_h\\), наложенных на область \\(\\Omega\\). На каждом последующем уровне вложенности, разрешение сетки удваивается, а интерполяции подвергаются остатки между исходными и интерполированными значениями в точках, полученные на предыдущем этапе. Финальные значения в узлах сетки определяются суммой функций по всем уровням иерархии:\n\\[f = \\sum_{k=0}^h f_k\\]Таким образом, достигается последовательная (инкрементная) аппроксимация исходной функции, которая выполняется быстрее для областей с разреженными данными (интерполяция достигается уже на первых итерациях) и требует большего количества итераций для участков с плотно расположенными данными.\nК достоинствам метода ИБС можно отнести:\n\nПоверхность получается сразу для всех узлов, нет необходимости решать систему линейных уравнений для каждого узла сетки;\nМетод является локальным: исходные точки, удаленные от текущего узла ЦМР далее чем на 2 узла, не оказывают на нее влияние. В результате этого метод ИБС получается чрезвычайно быстрым и эффективным в вычислительном плане.\nМультимасштабность метода позволяет эффективно использовать его при интерполяции данных, распределенных кластерным образом — например, данных профилирования.\n\nМетод иерархических базисных сплайнов доступен в пакете MBA. Чтобы использовать его, сначала необходимо подготовить исходные данные. Они должны представлять из себя матрицу из трех столбцов: X, Y, Показатель:\n\n# ИЕРАРХИЧЕСКИЕ БАЗИСНЫЕ СПЛАЙНЫ (HIERARCHICAL BASIS SPLINES)\nmba_data = cbind(coords, pts$rain_24)\n\nМетод ИБС, так же как и РБФ, предполагает по умолчанию, что область определения должна быть квадратной. Если разброс координат по осям X и Y не одинаков, поверхность будет искусственно растянута или сжата. Чтобы этого не произошло, необходимо сначала рассчитать пропорции ЦМР. Ранее мы уже создали объект envelope, который хранит крайние координаты по X и Y:\n\nratio = (envelope[2] - envelope[1])/(envelope[4] - envelope[3])\n\n# После этих приготовлений можно осуществить интерполяцию\npx_grid = px_grid |&gt; \n  mutate(z_bspline = \n    mba.points(\n      mba_data, coords_grid, \n      n = 1, m = ratio\n    )$xyz.est[, 'z']\n  )\n\n# Строим горизонтали\ncont_bspline = st_contour(px_grid['z_bspline'], \n                       breaks = tps_breaks, \n                       contour_lines = TRUE)\n\n# Виузализируем результат:\n\nggplot() +\n  geom_stars(data = cut(px_grid['z_bspline'], breaks = tps_breaks)) +\n  scale_fill_manual(name = 'мм',\n                    values = rain_colors(tps_ncolors),\n                    labels = paste(tps_breaks[-tps_ncolors-1], '-', tps_breaks[-1])) +\n  coord_sf(crs = st_crs(pts)) +\n  geom_sf(data = cont_bspline, color = 'black', size = 0.2) +\n  geom_sf(data = pts, color = 'red', size = 0.5)\n\n\n\n\n\n\n\n\nМожно видеть, что метод иерархических базисных сплайнов обеспечивает некий оптимум представления поверхности. С одной стороны, он, как и метод РБФ, дает гладкую и достаточно генерализованную поверхность. С другой стороны, на участках с плотным размещением исходных данных метод ИБС раскрывает локальные нюансы поверхности, чего лишен метод РБФ, и что более типично для метода ОВР.\nНаконец, рассмотрим результат в трехмерном виде:\n\np = plot_ly(x = x, \n            y = y, \n            z = px_grid$z_bspline, \n            type = \"surface\",\n            colors = rain_colors3d)\nlayout(p, scene = list(aspectratio = \n                         list(x = 1, y = 1, z = 0.3)\n))\n\n\n\n\n\nИтак, в настоящем модуле мы рассмотрели несколько распространенных методов детерминистической интерполяции поверхностей по данным в нерегулярно расположенных точках. В следующем модуле мы рассмотрим методы аппроксимации, которые могут быть полезны для работы с данными, обладающими высоким уровнем шума, а также для оценки пространственных трендов изменения показателя.",
    "crumbs": [
      "Пространственный анализ",
      "<span class='chapter-number'>15</span>  <span class='chapter-title'>Интерполяция геополей</span>"
    ]
  },
  {
    "objectID": "15-Interpolation.html#approximation_methods",
    "href": "15-Interpolation.html#approximation_methods",
    "title": "15  Интерполяция геополей",
    "section": "15.4 Аппроксимационные методы",
    "text": "15.4 Аппроксимационные методы\nАппроксимационные методы используются для выявления пространственных трендов - глобальных или локальных. В зависимости от этого они и классифицируются. Полученная поверхность в каждом узле показывает средневзвешенное (типичное) значение в заданной окрестности. Таким образом, задача аппроксимации — убрать детали и выявить основные закономерности пространственного распределения. При проведении аппроксимации условие прохождения поверхности через исходные точки не применяется. В случае глобального тренда окрестность аппроксимации включает весь набор исходных точек.\nЛокальные аппроксимации учитывают только ближайшие точки, причем общепринятым является подход, в котором окрестность определяется не расстоянием, а заданным количеством ближайших точек (или их долей от общего числа). В этом случае в области сгущения исходных данных локальная аппроксимация будет строиться по меньшей окрестности, что позволит отразить нюансы изменения показателя. И в локальных и в глобальных аппроксимациях используются обычно полиномиальные поверхности степени от \\(0\\) до \\(3\\). Коэффициенты полиномов подбираются методом наименьших квадратов для минимизации отклонения поверхности от исходных точек в заданной окрестности. В случае если степень равна \\(0\\), поверхность представляет из себя константу, или горизонтальную плоскость. Для степени \\(1\\) возможно построение наклонной плоскости. Степени \\(2\\) и \\(3\\) соответствуют квадратичным и кубическим поверхностям. Степени большего порядка для построения трендов, как правило, не используются.\n\n15.4.1 Глобальный тренд\nПостроение поверхности глобального тренда можно осуществить с помощью геостатистического пакета gstat, с которым мы познакомимся в следующем модуле. Для этого необходимо сначала создать объект gstat, используя формулу (см. метод ОВР), исходные точки и степень аппроксимации. После этого аппроксимация осуществляется с помощью функции predict(). Дальнейшие действия совпадают со стандартным алгоритмом, который мы использовали ранее.\n\n\n# ГЛОБАЛЬНАЯ АППРОКСИМАЦИЯ (GLOBAL APPROXIMATION)\n\n# Создаем объект gstat и интерполируем на его основе. Столбец, указываемый в параметре formula, должен содержаться\n# в наборе данных, который передается в параметр data:\npx_grid = px_grid |&gt; \n  mutate(z_trend1 = predict(gstat(formula = rain_24 ~ 1, data = pts, degree = 1), \n                            newdata = px_grid) |&gt;  pull(var1.pred) |&gt;  as('vector'),\n         z_trend2 = predict(gstat(formula = rain_24 ~ 1, data = pts, degree = 2), \n                            newdata = px_grid) |&gt;  pull(var1.pred) |&gt;  as('vector'),\n         z_trend3 = predict(gstat(formula = rain_24 ~ 1, data = pts, degree = 3), \n                            newdata = px_grid) |&gt; pull(var1.pred) |&gt; as('vector'))\n# Строим горизонтали\ncont_trend1 = st_contour(px_grid['z_trend1'], \n                       breaks = rain_levels, \n                       contour_lines = TRUE)\n\ncont_trend2 = st_contour(px_grid['z_trend2'], \n                       breaks = rain_levels, \n                       contour_lines = TRUE)\n\ncont_trend3 = st_contour(px_grid['z_trend3'], \n                       breaks = rain_levels, \n                       contour_lines = TRUE)\n\nggplot() +\n  geom_stars(data = cut(px_grid['z_trend1'], breaks = rain_levels)) +\n  rain_legend +\n  coord_sf(crs = st_crs(pts)) +\n  geom_sf(data = cont_trend1, color = 'black', size = 0.2) +\n  geom_sf(data = pts, color = 'red', size = 0.5)\n\n\n\n\n\n\n\n\nggplot() +\n  geom_stars(data = cut(px_grid['z_trend2'], breaks = rain_levels)) +\n  rain_legend +\n  coord_sf(crs = st_crs(pts)) +\n  geom_sf(data = cont_trend2, color = 'black', size = 0.2) +\n  geom_sf(data = pts, color = 'red', size = 0.5)\n\n\n\n\n\n\n\n\nggplot() +\n  geom_stars(data = cut(px_grid['z_trend3'], breaks = rain_levels)) +\n  rain_legend +\n  coord_sf(crs = st_crs(pts)) +\n  geom_sf(data = cont_trend3, color = 'black', size = 0.2) +\n  geom_sf(data = pts, color = 'red', size = 0.5)\n\n\n\n\n\n\n\n\nНаконец, рассмотрим полученные поверхности в трехмерном виде. Наклонная плоскость:\n\np = plot_ly(x = x, y = y, \n            z = px_grid$z_trend1, \n            type = \"surface\", \n            colors = rain_colors3d)\nlayout(p, scene = list(aspectratio = list(x = 1, y = 1, z = 0.3)))\n\n\n\n\n\nПоверхность 2-го порядка:\n\np = plot_ly(x = x, y = y, \n            z = px_grid$z_trend2, \n            type = \"surface\",\n            colors = rain_colors3d)\nlayout(p, scene = list(aspectratio = list(x = 1, y = 1, z = 0.3)))\n\n\n\n\n\nПоверхность 3-го порядка:\n\np = plot_ly(x = x, y = y, \n            z = px_grid$z_trend3, \n            type = \"surface\",\n            colors = rain_colors3d)\nlayout(p, scene = list(aspectratio = list(x = 1, y = 1, z = 0.3)))\n\n\n\n\n\n\n\n15.4.2 Локальный тренд\nМетод построения локальной регрессии изначально был разработан для построения кривых регрессии в случае когда зависимость между переменными ведет себя сложным образом и не может быть описана в терминах традиционной линейной и нелинейной регрессии — глобальных методов.\nПусть даны измерения показателя в \\(N\\) исходных точках и задано число \\(\\alpha\\) — сглаживающий параметр. Тогда аппроксимация показателя в каждом узле интерполяции получается путем построения поверхности тренда (см. выше) по \\(\\alpha N\\) ближайшим исходным точкам. Как и в одномерном случае, близкие точки будут оказывать более сильное влияние на коэффициенты регрессии, чем удаленные.\nМетод LOESS предоставляет широкие возможности настройки благодаря вариативности параметра сглаживания и степени регрессионного полинома.\nПоскольку LOESS — это один из базовых методов регрессионного анализа, он входит в состав базового пакета stats. Для его использования нужно вначале инициализировать параметры локальной регрессии с помощью функции loess(). Параметры задаются в следующей форме:\n\nФормула, содержащая названия зависимой и независимых (координаты) переменной\nНабор данных, в котором содержатся значения переменных\nСтепень полинома (degree)\nСглаживающий параметр (span)\nНеобходимость нормализации координат (приведения к квадратной области определения)\n\n\n\n# ЛОКАЛЬНАЯ АППРОКСИМАЦИЯ (LOWESS)\n\n# 0-я степень -------------------------------------------------------------\npx_grid = px_grid |&gt; \n  mutate(z_local0 = predict(loess(rain_24 ~ x + y, pts, degree = 0, \n                                  span = 0.07, normalize = FALSE), coords_grid) |&gt; as('vector'),\n         z_local1 = predict(loess(rain_24 ~ x + y, pts, degree = 1, \n                                  span = 0.07, normalize = FALSE), coords_grid) |&gt; as('vector'),\n         z_local2 = predict(loess(rain_24 ~ x + y, pts, degree = 2, \n                                  span = 0.07, normalize = FALSE), coords_grid) |&gt; as('vector'))\n\n\n# Визуализируем\ncont_local0 = st_contour(px_grid['z_local0'], \n                         breaks = rain_levels, \n                         contour_lines = TRUE)\n\ncont_local1 = st_contour(px_grid['z_local1'], \n                         breaks = rain_levels, \n                         contour_lines = TRUE)\n\ncont_local2 = st_contour(px_grid['z_local2'], \n                         breaks = rain_levels, \n                         contour_lines = TRUE)\n\nggplot() +\n  geom_stars(data = cut(px_grid['z_local0'], breaks = rain_levels)) +\n  rain_legend +\n  coord_sf(crs = st_crs(pts)) +\n  geom_sf(data = cont_local0, color = 'black', size = 0.2) +\n  geom_sf(data = pts, color = 'red', size = 0.5)\n\n\n\n\n\n\n\n\n\nggplot() +\n  geom_stars(data = cut(px_grid['z_local1'], breaks = rain_levels)) +\n  rain_legend +\n  coord_sf(crs = st_crs(pts)) +\n  geom_sf(data = cont_local1, color = 'black', size = 0.2) +\n  geom_sf(data = pts, color = 'red', size = 0.5)\n\n\n\n\n\n\n\n\n\nggplot() +\n  geom_stars(data = cut(px_grid['z_local2'], breaks = rain_levels)) +\n  rain_legend +\n  coord_sf(crs = st_crs(pts)) +\n  geom_sf(data = cont_local2, color = 'black', size = 0.2) +\n  geom_sf(data = pts, color = 'red', size = 0.5)\n\n\n\n\n\n\n\n\nРассмотрим результаты в 3D. Горизонтальная плоскость:\n\np = plot_ly(x = x, y = y, \n            z = px_grid$z_local0, \n            type = \"surface\", \n            colors = rain_colors3d)\nlayout(p, scene = list(aspectratio = list(x = 1, y = 1, z = 0.3)))\n\n\n\n\n\nНаклонная плоскость:\n\np = plot_ly(x = x, y = y, \n            z = px_grid$z_local1, \n            type = \"surface\",\n            colors = rain_colors3d)\nlayout(p, scene = list(aspectratio = list(x = 1, y = 1, z = 0.3)))\n\n\n\n\n\nПоверхность 2 порядка:\n\np = plot_ly(x = x, y = y, \n            z = px_grid$z_local2, \n            type = \"surface\",\n            colors = rain_colors3d)\nlayout(p, scene = list(aspectratio = list(x = 1, y = 1, z = 0.3)))\n\n\n\n\n\nМожно заметить, что с увеличением степени полинома поверхность все более точно аппроксимирует исходные данные — там, где достаточно большое количество исходных точек. В то же время, появляются нежелательные экстраполяции в приграничных областях, слабо обеспеченных измерениями, что можно наблюдать на последнем рисунке (степень = 2) в северо-западной части. Поэтому нельзя однозначно сказать, что более высокая степень обеспечивает лучшие результаты аппроксимации. Точность аппроксимации правильно регулировать не степенью полинома, а увеличением и уменьшением сглаживающего параметра альфа.\nРассмотрим это на примере линейной аппроксимации при \\(\\alpha = 0.05, 0.1, 0.2\\):\n\npx_grid = px_grid |&gt;  \n  mutate(z_local1_005 = predict(loess(rain_24 ~ x + y, pts, degree = 1, \n                                  span = 0.05, normalize = FALSE), coords_grid) |&gt; as('vector'),\n         z_local1_01  = predict(loess(rain_24 ~ x + y, pts, degree = 1, \n                                  span = 0.1, normalize = FALSE), coords_grid) |&gt; as('vector'),\n         z_local1_02  = predict(loess(rain_24 ~ x + y, pts, degree = 1, \n                                  span = 0.2, normalize = FALSE), coords_grid) |&gt; as('vector'))\n\n# Визуализируем\ncont_local1_005 = st_contour(px_grid['z_local1_005'], \n                         breaks = rain_levels, \n                         contour_lines = TRUE)\n\ncont_local1_01 = st_contour(px_grid['z_local1_01'], \n                         breaks = rain_levels, \n                         contour_lines = TRUE)\n\ncont_local1_02 = st_contour(px_grid['z_local1_02'], \n                         breaks = rain_levels, \n                         contour_lines = TRUE)\n\nggplot() +\n  geom_stars(data = cut(px_grid['z_local1_005'], breaks = rain_levels)) +\n  rain_legend +\n  coord_sf(crs = st_crs(pts)) +\n  geom_sf(data = cont_local1_005, color = 'black', size = 0.2) +\n  geom_sf(data = pts, color = 'red', size = 0.5)\n\n\n\n\n\n\n\n\nggplot() +\n  geom_stars(data = cut(px_grid['z_local1_01'], breaks = rain_levels)) +\n  rain_legend +\n  coord_sf(crs = st_crs(pts)) +\n  geom_sf(data = cont_local1_01, color = 'black', size = 0.2) +\n  geom_sf(data = pts, color = 'red', size = 0.5)\n\n\n\n\n\n\n\n\nggplot() +\n  geom_stars(data = cut(px_grid['z_local1_02'], breaks = rain_levels)) +\n  rain_legend +\n  coord_sf(crs = st_crs(pts)) +\n  geom_sf(data = cont_local1_02, color = 'black', size = 0.2) +\n  geom_sf(data = pts, color = 'red', size = 0.5)\n\n\n\n\n\n\n\n\nСравниваем результаты в трехмерном виде. Горизонтальная плоскость:\n\np = plot_ly(x = x, y = y, \n            z = px_grid$z_local1_005, \n            type = \"surface\", \n            colors = rain_colors3d)\nlayout(p, scene = list(aspectratio = list(x = 1, y = 1, z = 0.3)))\n\n\n\n\n\nНаклонная плоскость:\n\np = plot_ly(x = x, y = y, \n            z = px_grid$z_local1_01, \n            type = \"surface\",\n            colors = rain_colors3d)\nlayout(p, scene = list(aspectratio = list(x = 1, y = 1, z = 0.3)))\n\n\n\n\n\nПоверхность 2 порядка:\n\np = plot_ly(x = x, y = y, \n            z = px_grid$z_local1_02, \n            type = \"surface\",\n            colors = rain_colors3d)\nlayout(p, scene = list(aspectratio = list(x = 1, y = 1, z = 0.3)))",
    "crumbs": [
      "Пространственный анализ",
      "<span class='chapter-number'>15</span>  <span class='chapter-title'>Интерполяция геополей</span>"
    ]
  },
  {
    "objectID": "15-Interpolation.html#interp_review",
    "href": "15-Interpolation.html#interp_review",
    "title": "15  Интерполяция геополей",
    "section": "15.5 Краткий обзор",
    "text": "15.5 Краткий обзор\nДля просмотра презентации щелкните на ней один раз левой кнопкой мыши и листайте, используя кнопки на клавиатуре:\n\n\n\n\n\nПрезентацию можно открыть в отдельном окне или вкладке браузере. Для этого щелкните по ней правой кнопкой мыши и выберите соответствующую команду.",
    "crumbs": [
      "Пространственный анализ",
      "<span class='chapter-number'>15</span>  <span class='chapter-title'>Интерполяция геополей</span>"
    ]
  },
  {
    "objectID": "15-Interpolation.html#questions_tasks_interp",
    "href": "15-Interpolation.html#questions_tasks_interp",
    "title": "15  Интерполяция геополей",
    "section": "15.6 Контрольные вопросы и упражнения",
    "text": "15.6 Контрольные вопросы и упражнения\n\n15.6.1 Вопросы\n\nСформулируйте отличие интерполяционных и аппроксимационных методов восстановления поверхностей по данным в нерегулярно расположенных точках.\nКакой метод интерполяции подходит для работы с категориальными (качественными) данными?\nПри каких условиях в методе интерполяции на основе триангуляции возможна оценка величины за пределами выпуклой оболочки исходного множества точек?\nНазовите основной недостаток метода обратно взвешенных расстояний.\nКаким требованиям должна удовлетворять радиальная базисная функция?\nЕсли дана функция, являющаяся радиальной базисной, можно ли в качестве таковой использовать обратную к ней? Как это реализуется математически?\nВ каком методе интерполяции используются сплайны с натяжением?\nСформулируйте основные принципы восстановления поверхности методом иерархических базисных сплайнов.\nПолиномы каких степеней обычно используются в задачах аппроксимации на практике?\nКаким образом реализуется метод локальной регрессии в приложении к пространственным данным?\nВ чем заключается отличие экстенсивных и интенсивных пространственных переменных?\nПеречислите пакеты программной среды R, которые можно использовать для восстановления поверхностей по данным в нерегулярно расположенных точках.\nКакие функции R позволяют построить регулярную сетку? Как преобразовать эту сетку в растр?\nИзложите последовательность действий, необходимую для трехмерной визуализации поверхности средствами библиотеки plotly.\n\n\n\n15.6.2 Упражнения\n\nЗагрузите данные дрейфующих буев ARGO на акваторию Северной Атлантики за 30 января 2010 года. Постройте поля распределения солености и температуры всеми перечисленными в лекции методами с размером ячейки 50 км. Визуализируйте их средствами tmap и сравните результаты. Какой метод интерполяции дает, на ваш взгляд, более правдоподобный результат?\n\nПодсказка: перед построением сетки интерполяции трансформируйте данные в проекцию Меркатора. Чтобы полученное поле распределения покрывало только акваторию, маскируйте полученный растр с использованием слоя ocean из набора данных Natural Earth. Перед выполнением маскирования преобразуйте мультиполигон в обычные полигоны (в противном случае маскирование отработает некорректно).\n\n\n\n\n\nСамсонов Т.Е. Визуализация и анализ географических данных на языке R. М.: Географический факультет МГУ, 2023. DOI: 10.5281/zenodo.901911",
    "crumbs": [
      "Пространственный анализ",
      "<span class='chapter-number'>15</span>  <span class='chapter-title'>Интерполяция геополей</span>"
    ]
  },
  {
    "objectID": "16-NetworkAnalysis.html#кратчайший-путь-и-зоны-доступности",
    "href": "16-NetworkAnalysis.html#кратчайший-путь-и-зоны-доступности",
    "title": "16  Сетевой анализ",
    "section": "16.1 Кратчайший путь и зоны доступности",
    "text": "16.1 Кратчайший путь и зоны доступности\n\n16.1.1 Загрузка данных\n\nlibrary(sf)\nlibrary(tidyverse)\nlibrary(classInt)\nlibrary(osrm) # Использование онлайн-сервиса маршрутизации OSRM\nlibrary(sfnetworks)\nlibrary(tidygraph)\n\n# Чтение данных\n\ndb = 'data/moscow.gpkg'\nroads = read_sf(db, \"roads\") # Дороги\npoi = read_sf(db, \"poi\") # Точки интереса\nrayons = read_sf(db, \"districts\") # Границы районов\nstations = read_sf(db, \"metro_stations\") # Станции метро\nwater = read_sf(db, \"water\") # Водные объекты\n\n# Прочитаем текущие параметры компоновки\ndef = par(no.readonly = TRUE)\n\n# Уберем поля, чтобы карта занимала весь экран\npar(mar = c(0,0,0,0))\n\n# Получим ограничивающий прямоугольник слоя дорог в качестве общего охвата карты\nframe = roads |&gt;  \n  st_bbox() |&gt;\n  st_as_sfc() |&gt; \n  st_geometry()\n\npoi.food = poi |&gt;  \n    select(NAME, AMENITY) |&gt; \n    filter(AMENITY %in% c(\"restaurant\", \"bar\", \"cafe\", \"pub\", \"fast_food\"))\n\n## ОБЗОР ИСХОДНЫХ ДАННЫХ -------------------------------------\n\n# Визуализируем входные данные\nplot(frame)\nplot(water |&gt;  st_geometry(), \n     col = \"lightskyblue1\",\n     border = \"lightskyblue3\",\n     add = TRUE)\nplot(roads |&gt;  st_geometry(),\n     col = \"gray70\", \n     add = TRUE)\nplot(poi |&gt;  st_geometry(), \n     col = \"deepskyblue4\", \n     pch = 20, \n     cex = 0.2, \n     add = TRUE)\n\n\n\n\n\n\n\n\n\nplotBasemap = function(add = FALSE){\n  \n  plot(frame, add = add)\n\n  plot(water |&gt;  st_geometry(), \n       col = \"lightskyblue1\",\n       border = \"lightskyblue3\",\n       add = TRUE)\n  \n  plot(roads |&gt;  st_geometry(),\n       col = \"gray70\",\n       add = TRUE)\n  \n  plot(poi.food |&gt;  st_geometry(), \n       col = \"deepskyblue4\", \n       pch = 20, \n       cex = 0.3, \n       add = TRUE)\n  plot(stations |&gt;  st_geometry(), \n       col = \"slategray4\", \n       pch = 20, \n       cex = 2, \n       add = TRUE)\n  text(stations |&gt;  st_centroid() %&gt;% st_coordinates(),\n       labels = \"M\",\n       col = \"white\",\n       cex = 0.4)\n}\n\n\n\n16.1.2 Онлайн-анализ через сервис OSRM\n\n16.1.2.1 Анализ зон транспортной доступности\nЗоны транспортной доступности представляют из себя зоны окружения объектов, построенные не по евклидову расстоянию, а по расстоянию или времени движения по дорожной сети. В задачах логистики и геомаркетинга зоны транспортной доступности часто называют зонами обслуживания (service area), поскольку используются для определения территории, которую может покрыть объект, предоставляющий некоторые услуги. Например, для пожарного депо зона 10-минутной доступности показывает территорию города, в любую точку которой пожарная машина может доехать из данного депо в течение 10 минут. И наоборот, для торгового центра зона 10-минутной доступности показывает территорию города, из любой точки которой можно добраться до ТЦ в течение 10 минут. Очевидно, что продолжительность прямого и обратного маршрута неодинакова, на нее может оказывать влияние схема движения, приоритет дорог и так далее.\nЗадача, которую мы решим в данном разделе, звучит так: определить все заведения питания, находящиеся в 7 минутах езды от Центрального детского магазина. Для построения зоны доступности мы будем использовать пакет osrm, предоставляющий интерфейс R к онлайн-библиотеке маршрутизации OSRM, работающей на основе данных OSM. Для построения зоны доступности (изохроны) нам понадобится функция osrmIsochrone() из данного пакета.\n\nВнимание: для выполнения этого раздела модуля необходимо подключение к Интернету\n\nПоскольку данные, используемые в настоящем модуле, предварительно были конвертированы в проекцию UTM и хранятся в метрах, а OSRM решает все задачи в географических координатах (широте и долготе относительно эллипсоида WGS84), нам необходимо научиться работать с проекциями данных и преобразовывать системы координат между собой.\n\n\n## АНАЛИЗ ЗОН ТРАНСПОРТНОЙ ДОСТУПНОСТИ -------------------------------------\n\n# Инициализируем систему координат WGS84, используемую в OSRM\nWGS84 = st_crs(4326)\n\n# Извлечем информацию о системе координат исходных точек\nUTM = st_crs(poi)\n\n# Выберем целевой объект\npsel = poi |&gt;  \n  filter(NAME == \"Центральный детский магазин\" & SHOP == \"toys\")\n\n# Преобразуем координаты точки в WGS84\npsel.wgs = st_transform(psel, WGS84)\n\n# Получаем 5-минутную зону транспортной доступности\n# с помощью пакета osrm\nservice_area = osrmIsochrone(psel.wgs, breaks = 3)\n\n# Преобразуем зону обратно в UTM для дальнейших операций\nservice_area_utm = st_transform(st_as_sf(service_area), UTM)\n\n# Отбираем точки\nselected_poi = poi.food[service_area_utm, ]\n\n# Визуализируем результат\nplotBasemap()\n\nplot(service_area_utm |&gt; st_geometry(),\n     col = adjustcolor(\"violetred3\", alpha.f = 0.2),\n     border = \"violetred3\",\n     add = TRUE)\n\nplot(selected_poi |&gt; st_geometry(), \n     col = \"violetred3\", \n     pch = 20, \n     cex = 0.5, \n     add = TRUE)\n\nplot(psel |&gt; st_geometry(), \n     col = \"violetred4\", \n     pch = 20, \n     cex = 4, \n     add = TRUE)\n\n\n\n\n\n\n\n\nИтак, в данном разделе мы научились строить зоны транспортной доступности в виде полигонов, ограниченных изохроной времени движения.\n\n\n16.1.2.2 Построение маршрутов и матриц времени движения\nВ этом разделе модуля пространственного анализа мы посмотрим, каким образом можно построить оптимальный маршрут между двумя точками, а также получить матрицу времени движения между точками (на примере станций метро). Для решения этих задач используем следующие функции пакета osrm:\n\nosrmRoute(src, dest) — строит оптимальный маршрут между точками src и dest\nosrmTable(loc) — строит матрицу времени движения между всеми парами точек в loc\n\nТак же, как и в предыдущем разделе, нам понадобятся преобразования координат. Построим оптимальный маршрут между книжным магазином “Молодая Гвардия” на Полянке и чебуречной “Дружба” на метро Сухаревская:\n\n\n## ПОСТРОЕНИЕ МАРШРУТОВ -------------------------------------\n\n# Выбираем и проецируем начальную точку\norigin = poi |&gt; filter(NAME == 'Молодая Гвардия')\norigin_wgs = st_transform(origin, WGS84)\n  \n# Выбираем и проецируем конечную точку\ndestination = poi |&gt;  filter(NAME == 'Чебуречная \"Дружба\"')\ndestination_wgs = st_transform(destination, WGS84)\n\n# Строим маршрут\nroute = osrmRoute(origin_wgs, \n                  destination_wgs, \n                  overview = \"full\", # запретить генерализацию линий\n                  returnclass = 'sf') # вернуть результат в виде объекта класса Spatial\n\n# Преобразуем результат обратно в UTM\nroute.utm = st_transform(route, UTM)\n\n# Визуализируем результат:\nplotBasemap()\n\nplot(route.utm |&gt; st_geometry(),\n     lwd = 3,\n     col = \"orange\",\n     add = TRUE)\n\nplot(origin |&gt; st_geometry(), \n     col = \"tomato3\", \n     pch = 20, \n     cex = 3, \n     add = TRUE)\ntext(origin |&gt; st_coordinates(),\n     labels = \"O\",\n     col = \"tomato4\",\n     cex = 0.5)\n\nplot(destination |&gt; st_geometry(), \n     col = \"tomato\", \n     pch = 20, \n     cex = 4, \n     add = TRUE)\ntext(destination |&gt; st_coordinates(),\n     labels = \"D\",\n     col = \"tomato4\",\n     cex = 0.7)",
    "crumbs": [
      "Пространственный анализ",
      "<span class='chapter-number'>16</span>  <span class='chapter-title'>Сетевой анализ</span>"
    ]
  },
  {
    "objectID": "16-NetworkAnalysis.html#структурный-анализ",
    "href": "16-NetworkAnalysis.html#структурный-анализ",
    "title": "16  Сетевой анализ",
    "section": "16.2 Структурный анализ",
    "text": "16.2 Структурный анализ\n\n16.2.0.1 Подготовка данных\nПакет sfnetworks использует методы пакетов tidygraph и igraph для анализа сетевых данных. Если OSRM содержит только базовые функции сетевого анализа, то sfnetworks позволяет выполнять достаточно сложные теоретические расчеты на географических сетях. Рассмотрим их на примере имеющегося у нас датасета по центру Москвы.\nЧтобы граф построился корректно, необходимо продублировать линии, не являющиеся односторонними, а также округлить координаты. Первая операция нужна для того чтобы разрешить проеезд по двусторонним ребрам в обе стороны. Вторая операция важна для того чтобы устранить ошибки пристыковки линий, из-за которых они могут быть не распознаны как топологически связанные.\n\nlines = roads |&gt; \n  st_cast('LINESTRING')\n\ntwoway = lines |&gt;\n  filter(is.na(ONEWAY) | ONEWAY != 'yes') |&gt;\n  st_reverse() |&gt;\n  bind_rows(lines)\n\nnet = twoway |&gt;\n  st_geometry() |&gt;\n  lapply(function(x) round(x, 0)) |&gt;\n  st_sfc(crs = st_crs(roads)) |&gt;\n  as_sfnetwork()\n\n# net = as_sfnetwork(lines)\n\nnet\n## # A sfnetwork with 2133 nodes and 2825 edges\n## #\n## # CRS:  WGS 84 / UTM zone 37N \n## #\n## # A directed multigraph with 223 components with spatially explicit edges\n## #\n## # A tibble: 2,133 × 1\n##                  x\n##        &lt;POINT [m]&gt;\n## 1 (410948 6177750)\n## 2 (410947 6177750)\n## 3 (411054 6177640)\n## 4 (410947 6177557)\n## 5 (410978 6179110)\n## 6 (410947 6179112)\n## # ℹ 2,127 more rows\n## #\n## # A tibble: 2,825 × 3\n##    from    to                                                                  x\n##   &lt;int&gt; &lt;int&gt;                                                   &lt;LINESTRING [m]&gt;\n## 1     1     2                                   (410948 6177750, 410947 6177750)\n## 2     3     4 (411054 6177640, 411046 6177634, 411011 6177606, 410957 6177564, …\n## 3     5     6                   (410978 6179110, 410948 6179112, 410947 6179112)\n## # ℹ 2,822 more rows\n\nВизуализировать граф можно как посредством стандартной функции plot, так и с помощью функции autoplot, которая задействует функциональность ggplot2:\n\nplot(net)\n\n\n\n\n\n\n\nautoplot(net)\n\n\n\n\n\n\n\n\nДля того чтобы работать с компонентами графа (ребрами и вершинами), необходимо их активировать.\n\nnet |&gt; \n  activate(\"edges\")\n## # A sfnetwork with 2133 nodes and 2825 edges\n## #\n## # CRS:  WGS 84 / UTM zone 37N \n## #\n## # A directed multigraph with 223 components with spatially explicit edges\n## #\n## # A tibble: 2,825 × 3\n##    from    to                                                                  x\n##   &lt;int&gt; &lt;int&gt;                                                   &lt;LINESTRING [m]&gt;\n## 1     1     2                                   (410948 6177750, 410947 6177750)\n## 2     3     4 (411054 6177640, 411046 6177634, 411011 6177606, 410957 6177564, …\n## 3     5     6                   (410978 6179110, 410948 6179112, 410947 6179112)\n## 4     7     8                   (410947 6179209, 411033 6179201, 411040 6179200)\n## 5     9    10 (411022 6181910, 411004 6181900, 410992 6181894, 410988 6181892, …\n## 6    11    12                   (410947 6179043, 410959 6179044, 410962 6179044)\n## # ℹ 2,819 more rows\n## #\n## # A tibble: 2,133 × 1\n##                  x\n##        &lt;POINT [m]&gt;\n## 1 (410948 6177750)\n## 2 (410947 6177750)\n## 3 (411054 6177640)\n## # ℹ 2,130 more rows\n\nnet |&gt; \n  activate(\"nodes\")\n## # A sfnetwork with 2133 nodes and 2825 edges\n## #\n## # CRS:  WGS 84 / UTM zone 37N \n## #\n## # A directed multigraph with 223 components with spatially explicit edges\n## #\n## # A tibble: 2,133 × 1\n##                  x\n##        &lt;POINT [m]&gt;\n## 1 (410948 6177750)\n## 2 (410947 6177750)\n## 3 (411054 6177640)\n## 4 (410947 6177557)\n## 5 (410978 6179110)\n## 6 (410947 6179112)\n## # ℹ 2,127 more rows\n## #\n## # A tibble: 2,825 × 3\n##    from    to                                                                  x\n##   &lt;int&gt; &lt;int&gt;                                                   &lt;LINESTRING [m]&gt;\n## 1     1     2                                   (410948 6177750, 410947 6177750)\n## 2     3     4 (411054 6177640, 411046 6177634, 411011 6177606, 410957 6177564, …\n## 3     5     6                   (410978 6179110, 410948 6179112, 410947 6179112)\n## # ℹ 2,822 more rows\n\nВ частности, для выполнения анализа необходимо вычислить веса всех ребер графа. Обычно вес зависит от времени передвижения, но за неимением такой информации можно использовать и длину:\n\nnet = net |&gt; \n  activate(\"edges\") |&gt; \n  mutate(weight = edge_length())\n\n\n\n16.2.0.2 Вычисление центральности\n\nnet = net |&gt; \n  activate(\"edges\") |&gt; \n  mutate(bc = centrality_edge_betweenness())\n\nggplot() +\n  geom_sf(data = st_as_sf(net, \"edges\"), \n          aes(col = bc, linewidth = bc)) +\n  scale_color_viridis_c() +\n  ggtitle(\"Центральность по промежуточности\")",
    "crumbs": [
      "Пространственный анализ",
      "<span class='chapter-number'>16</span>  <span class='chapter-title'>Сетевой анализ</span>"
    ]
  },
  {
    "objectID": "16-NetworkAnalysis.html#temporal_review",
    "href": "16-NetworkAnalysis.html#temporal_review",
    "title": "16  Сетевой анализ",
    "section": "16.3 Краткий обзор",
    "text": "16.3 Краткий обзор\nДля просмотра презентации щелкните на ней один раз левой кнопкой мыши и листайте, используя кнопки на клавиатуре:\n\n\n\n\n\nПрезентацию можно открыть в отдельном окне или вкладке браузере. Для этого щелкните по ней правой кнопкой мыши и выберите соответствующую команду.",
    "crumbs": [
      "Пространственный анализ",
      "<span class='chapter-number'>16</span>  <span class='chapter-title'>Сетевой анализ</span>"
    ]
  },
  {
    "objectID": "16-NetworkAnalysis.html#qtasks_network_analysis",
    "href": "16-NetworkAnalysis.html#qtasks_network_analysis",
    "title": "16  Сетевой анализ",
    "section": "16.4 Контрольные вопросы и упражнения",
    "text": "16.4 Контрольные вопросы и упражнения\n\n16.4.1 Вопросы\n\n\n16.4.2 Упражнения\n\n\n\nСамсонов Т.Е. Визуализация и анализ географических данных на языке R. М.: Географический факультет МГУ, 2023. DOI: 10.5281/zenodo.901911",
    "crumbs": [
      "Пространственный анализ",
      "<span class='chapter-number'>16</span>  <span class='chapter-title'>Сетевой анализ</span>"
    ]
  },
  {
    "objectID": "references.html",
    "href": "references.html",
    "title": "Библиография",
    "section": "",
    "text": "Cleveland, William S. 1979. “Robust Locally Weighted\nRegression and Smoothing Scatterplots.”\nJournal of the American Statistical Association 74 (368): 829.\nhttps://doi.org/10.2307/2286407.\n\n\nMardia, K V, and P E Jupp. 2000. Directional Statistics.\nChichester New York: Wiley.\n\n\nOliveira, Ma’ria, Rosa M. Crujeiras, and Alberto Rod’riguez-Casal. 2014.\n“NPCirc : An R Package for\nNonparametric Circular Methods.” Journal of\nStatistical Software 61 (9): 1–26. https://doi.org/10.18637/jss.v061.i09.\n\n\nOliveira, M., R. M. Crujeiras, and A. Rod’riguez-Casal. 2012. “A\nPlug-in Rule for Bandwidth Selection in Circular Density\nEstimation.” Computational Statistics and Data Analysis\n56 (12): 3898–908. https://doi.org/10.1016/j.csda.2012.05.021.\n\n\nPewsey, Arthur, Markus Neuhäuser, and Graeme D. Ruxton. 2013.\nCircular Statistics in R. Oxford New\nYork: Oxford University Press.\n\n\nTomlin, Dana. 2012. GIS and Cartographic\nModeling. 2nd Editio. ESRI Press.\n\n\nWickham, Hadley. 2019. Advanced R. 2nd ed.\nChapman and Hall/CRC.\n\n\nПрохоров, Ю. С. 2011. “Математическая Статистика.” In\nБольшая Российская Энциклопедия. Том 19, 349–52.\nИздательство «Большая российская энциклопедия».",
    "crumbs": [
      "Библиография"
    ]
  }
]